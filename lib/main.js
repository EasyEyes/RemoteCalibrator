/*! For license information please see main.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.calibration=t():e.calibration=t()}(self,(function(){return(()=>{var e={40:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});var a=n(645),r=n.n(a)()((function(e){return e[1]}));r.push([e.id,"#eye-side {\n  font-weight: bold;\n}\n\n#blind-spot-canvas {\n  z-index: -1;\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n#blind-spot-instruction {\n  position: absolute;\n  top: 65%;\n  width: 100%;\n  text-align: center;\n}\n\n#face-video {\n  display: none;\n}\n\n#video-canvas {\n  z-index: 2;\n  position: absolute;\n  display: block;\n  bottom: 1rem;\n  left: 1rem;\n}\n",""]);const s=r},556:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});var a=n(645),r=n.n(a)()((function(e){return e[1]}));r.push([e.id,"/* background div */\n.calibration-background {\n  z-index: 9999999;\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  margin: 0;\n  /* background: #57068c; */\n  background: #fff;\n  overflow: hidden;\n}\n\n.calibration-background * {\n  margin: 0;\n  padding: 0;\n  line-height: 150%;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,\n    Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n}\n\n.calibration-instruction {\n  position: absolute;\n  margin: 2rem;\n  text-align: left;\n}\n\n.calibration-instruction p {\n  white-space: pre-line;\n}\n",""]);const s=r},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=e(t);return t[2]?"@media ".concat(t[2]," {").concat(n,"}"):n})).join("")},t.i=function(e,n,a){"string"==typeof e&&(e=[[null,e,""]]);var r={};if(a)for(var s=0;s<this.length;s++){var o=this[s][0];null!=o&&(r[o]=!0)}for(var i=0;i<e.length;i++){var u=[].concat(e[i]);a&&r[u[0]]||(n&&(u[2]?u[2]="".concat(n," and ").concat(u[2]):u[2]=n),t.push(u))}},t}},377:(e,t,n)=>{var a=n(832),r=n(652),s=n(801),o=n(30),i=n(618),u=n(49),l=n(971);l.alea=a,l.xor128=r,l.xorwow=s,l.xorshift7=o,l.xor4096=i,l.tychei=u,e.exports=l},832:function(e,t,n){var a;!function(e,r,s){function o(e){var t,n=this,a=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var a=.02519603282416938*(t+=e.charCodeAt(n));a-=t=a>>>0,t=(a*=t)>>>0,t+=4294967296*(a-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=a(" "),n.s1=a(" "),n.s2=a(" "),n.s0-=a(e),n.s0<0&&(n.s0+=1),n.s1-=a(e),n.s1<0&&(n.s1+=1),n.s2-=a(e),n.s2<0&&(n.s2+=1),a=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function u(e,t){var n=new o(e),a=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(a=function(){return u}.call(t,n,t,r))||(r.exports=a):this.alea=u}(0,e=n.nmd(e),n.amdD)},49:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function u(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(a=function(){return u}.call(t,n,t,r))||(r.exports=a):this.tychei=u}(0,e=n.nmd(e),n.amdD)},652:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function u(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(a=function(){return u}.call(t,n,t,r))||(r.exports=a):this.xor128=u}(0,e=n.nmd(e),n.amdD)},618:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this;t.next=function(){var e,n,a=t.w,r=t.X,s=t.i;return t.w=a=a+1640531527|0,n=r[s+34&127],e=r[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[s]=n^e,t.i=s,n+(a^a>>>16)|0},function(e,t){var n,a,r,s,o,i=[],u=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,u=Math.max(u,t.length)),r=0,s=-32;s<u;++s)t&&(a^=t.charCodeAt((s+32)%t.length)),0===s&&(o=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,s>=0&&(o=o+1640531527|0,r=0==(n=i[127&s]^=a+o)?r+1:0);for(r>=128&&(i[127&(t&&t.length||0)]=-1),r=127,s=512;s>0;--s)a=i[r+34&127],n=i[r=r+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,i[r]=a^n;e.w=o,e.X=i,e.i=r}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function u(e,t){null==e&&(e=+new Date);var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.X&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(a=function(){return u}.call(t,n,t,r))||(r.exports=a):this.xor4096=u}(0,e=n.nmd(e),n.amdD)},30:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this;t.next=function(){var e,n,a=t.x,r=t.i;return e=a[r],n=(e^=e>>>7)^e<<24,n^=(e=a[r+1&7])^e>>>10,n^=(e=a[r+3&7])^e>>>3,n^=(e=a[r+4&7])^e<<7,e=a[r+7&7],n^=(e^=e<<13)^e<<9,a[r]=n,t.i=r+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function u(e,t){null==e&&(e=+new Date);var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.x&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(a=function(){return u}.call(t,n,t,r))||(r.exports=a):this.xorshift7=u}(0,e=n.nmd(e),n.amdD)},801:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function u(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(a=function(){return u}.call(t,n,t,r))||(r.exports=a):this.xorwow=u}(0,e=n.nmd(e),n.amdD)},971:(e,t,n)=>{var a;!function(r,s){var o,i=this,u=256,l=s.pow(u,6),c=s.pow(2,52),d=2*c,p=255;function h(e,t,n){var a=[],p=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,x(r)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(u):(e=new Uint8Array(u),(i.crypto||i.msCrypto).getRandomValues(e)),x(e)}catch(e){var t=i.navigator,n=t&&t.plugins;return[+new Date,i,n,i.screen,x(r)]}}():e,3),a),h=new f(a),b=function(){for(var e=h.g(6),t=l,n=0;e<c;)e=(e+n)*u,t*=u,n=h.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return 0|h.g(4)},b.quick=function(){return h.g(4)/4294967296},b.double=b,y(x(h.S),r),(t.pass||n||function(e,t,n,a){return a&&(a.S&&m(a,h),e.state=function(){return m(h,{})}),n?(s.random=e,t):e})(b,p,"global"in t?t.global:this==s,t.state)}function f(e){var t,n=e.length,a=this,r=0,s=a.i=a.j=0,o=a.S=[];for(n||(e=[n++]);r<u;)o[r]=r++;for(r=0;r<u;r++)o[r]=o[s=p&s+e[r%n]+(t=o[r])],o[s]=t;(a.g=function(e){for(var t,n=0,r=a.i,s=a.j,o=a.S;e--;)t=o[r=p&r+1],n=n*u+o[p&(o[r]=o[s=p&s+t])+(o[s]=t)];return a.i=r,a.j=s,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,a=[],r=typeof e;if(t&&"object"==r)for(n in e)try{a.push(g(e[n],t-1))}catch(e){}return a.length?a:"string"==r?e:e+"\0"}function y(e,t){for(var n,a=e+"",r=0;r<a.length;)t[p&r]=p&(n^=19*t[p&r])+a.charCodeAt(r++);return x(t)}function x(e){return String.fromCharCode.apply(0,e)}if(s.seedrandom=h,y(s.random(),r),e.exports){e.exports=h;try{o=n(42)}catch(e){}}else void 0===(a=function(){return h}.call(t,n,t,e))||(e.exports=a)}([],Math)},379:(e,t,n)=>{"use strict";var a,r=function(){var e={};return function(t){if(void 0===e[t]){var n=document.querySelector(t);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}e[t]=n}return e[t]}}(),s=[];function o(e){for(var t=-1,n=0;n<s.length;n++)if(s[n].identifier===e){t=n;break}return t}function i(e,t){for(var n={},a=[],r=0;r<e.length;r++){var i=e[r],u=t.base?i[0]+t.base:i[0],l=n[u]||0,c="".concat(u," ").concat(l);n[u]=l+1;var d=o(c),p={css:i[1],media:i[2],sourceMap:i[3]};-1!==d?(s[d].references++,s[d].updater(p)):s.push({identifier:c,updater:m(p,t),references:1}),a.push(c)}return a}function u(e){var t=document.createElement("style"),a=e.attributes||{};if(void 0===a.nonce){var s=n.nc;s&&(a.nonce=s)}if(Object.keys(a).forEach((function(e){t.setAttribute(e,a[e])})),"function"==typeof e.insert)e.insert(t);else{var o=r(e.insert||"head");if(!o)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");o.appendChild(t)}return t}var l,c=(l=[],function(e,t){return l[e]=t,l.filter(Boolean).join("\n")});function d(e,t,n,a){var r=n?"":a.media?"@media ".concat(a.media," {").concat(a.css,"}"):a.css;if(e.styleSheet)e.styleSheet.cssText=c(t,r);else{var s=document.createTextNode(r),o=e.childNodes;o[t]&&e.removeChild(o[t]),o.length?e.insertBefore(s,o[t]):e.appendChild(s)}}function p(e,t,n){var a=n.css,r=n.media,s=n.sourceMap;if(r?e.setAttribute("media",r):e.removeAttribute("media"),s&&"undefined"!=typeof btoa&&(a+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s))))," */")),e.styleSheet)e.styleSheet.cssText=a;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(a))}}var h=null,f=0;function m(e,t){var n,a,r;if(t.singleton){var s=f++;n=h||(h=u(t)),a=d.bind(null,n,s,!1),r=d.bind(null,n,s,!0)}else n=u(t),a=p.bind(null,n,t),r=function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(n)};return a(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;a(e=t)}else r()}}e.exports=function(e,t){(t=t||{}).singleton||"boolean"==typeof t.singleton||(t.singleton=(void 0===a&&(a=Boolean(window&&document&&document.all&&!window.atob)),a));var n=i(e=e||[],t);return function(e){if(e=e||[],"[object Array]"===Object.prototype.toString.call(e)){for(var a=0;a<n.length;a++){var r=o(n[a]);s[r].references--}for(var u=i(e,t),l=0;l<n.length;l++){var c=o(n[l]);0===s[c].references&&(s[c].updater(),s.splice(c,1))}n=u}}}},410:()=>{},628:()=>{},42:()=>{}},t={};function n(a){var r=t[a];if(void 0!==r)return r.exports;var s=t[a]={id:a,loaded:!1,exports:{}};return e[a].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e);var a={};return(()=>{"use strict";n.r(a),n.d(a,{liveDistance:()=>S$,staticDistance:()=>E});var e={};n.r(e),n.d(e,{assertParamsValid:()=>ts,computeFlatOffset:()=>fs,computeOutShape:()=>as,getNormalizedAxes:()=>is,isSliceContinous:()=>hs,maskToAxes:()=>ns,parseSliceParams:()=>ms,sliceInfo:()=>gs,startForAxis:()=>ds,startIndicesWithElidedDims:()=>us,stopForAxis:()=>ps,stopIndicesWithElidedDims:()=>ls,stridesForAxis:()=>cs,stridesWithElidedDims:()=>rs});var t={};n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>fu,computeOutShape:()=>hu,segOpComputeOptimalWindowSize:()=>pu});var r={};n.r(r),n.d(r,{ERF_A1:()=>Yi,ERF_A2:()=>Qi,ERF_A3:()=>Zi,ERF_A4:()=>Ji,ERF_A5:()=>eu,ERF_P:()=>qi,PARALLELIZE_THRESHOLD:()=>Di,SELU_SCALE:()=>Xi,SELU_SCALEALPHA:()=>Ki,applyActivation:()=>_i,assertAndGetBroadcastShape:()=>go,assertAxesAreInnerMostDims:()=>Eo,assertParamsConsistent:()=>di,assignToTypedArray:()=>uu,axesAreInnerMostDims:()=>No,calculateShapes:()=>ji,combineLocations:()=>$o,complexWithEvenIndex:()=>su,complexWithOddIndex:()=>ou,computeConv2DInfo:()=>gi,computeConv3DInfo:()=>yi,computeDefaultPad:()=>xi,computeDilation2DInfo:()=>hi,computeOptimalWindowSize:()=>Mi,computeOutAndReduceShapes:()=>Co,computeOutShape:()=>pi,computePool2DInfo:()=>fi,computePool3DInfo:()=>mi,convertConv2DDataFormat:()=>$i,eitherStridesOrDilationsAreOne:()=>Ni,expandShapeToKeepDim:()=>To,exponent:()=>cu,exponents:()=>lu,fromStringArrayToUint8:()=>gu,fromUint8ToStringArray:()=>mu,getAxesPermutation:()=>So,getBroadcastDims:()=>fo,getComplexWithIndex:()=>iu,getFusedBiasGradient:()=>Fi,getFusedDyActivation:()=>Ai,getImageCenter:()=>Li,getInnerMostAxes:()=>Ao,getPermuted:()=>Bi,getReductionAxes:()=>mo,getReshaped:()=>Pi,getReshapedPermuted:()=>Vi,getSliceBeginCoords:()=>Wi,getSliceSize:()=>zi,getUndoAxesPermutation:()=>Ro,log:()=>nu,mergeRealAndImagArrays:()=>au,prepareAndValidate:()=>Ui,prepareSplitSize:()=>du,segment_util:()=>t,shouldFuse:()=>Oi,slice_util:()=>e,splitRealAndImagArrays:()=>ru,tupleValuesAreOne:()=>Ii,upcastType:()=>za,validateInput:()=>Hi,validateUpdateShape:()=>Gi,warn:()=>tu});var s={};n.r(s),n.d(s,{json:()=>Su});var o={};n.r(o),n.d(o,{json:()=>Ru});var i={};n.r(i),n.d(i,{json:()=>Au});var u={};n.r(u),n.d(u,{json:()=>Fu});var l={};n.r(l),n.d(l,{json:()=>_u});var c={};n.r(c),n.d(c,{json:()=>Ou});var d={};n.r(d),n.d(d,{json:()=>Du});var p={};n.r(p),n.d(p,{json:()=>Mu});var h={};n.r(h),n.d(h,{json:()=>Lu});var f={};n.r(f),n.d(f,{json:()=>Pu});var m={};n.r(m),n.d(m,{json:()=>Bu});var g={};n.r(g),n.d(g,{json:()=>Vu});var y={};n.r(y),n.d(y,{json:()=>Wu});var x={};n.r(x),n.d(x,{json:()=>zu});var b={};n.r(b),n.d(b,{json:()=>Uu});var v={};n.r(v),n.d(v,{json:()=>Gu});var k={};n.r(k),n.d(k,{json:()=>Hu});var w={};n.r(w),n.d(w,{addImpl:()=>gh,bincountImpl:()=>vh,bincountReduceImpl:()=>kh,ceilImpl:()=>$h,concatImpl:()=>Eh,expImpl:()=>Sh,expm1Impl:()=>Fh,floorImpl:()=>Dh,gatherV2Impl:()=>Ph,greaterImpl:()=>Bh,lessImpl:()=>zh,linSpaceImpl:()=>Hh,logImpl:()=>jh,maxImpl:()=>qh,maximumImpl:()=>Yh,minimumImpl:()=>Jh,multiplyImpl:()=>nf,negImpl:()=>of,notEqualImpl:()=>lf,prodImpl:()=>mf,rangeImpl:()=>yf,rsqrtImpl:()=>xf,simpleAbsImpl:()=>nh,sliceImpl:()=>kf,squaredDifferenceImpl:()=>Nf,stridedSliceImpl:()=>Tf,subImpl:()=>Ef,tileImpl:()=>Ff,topKImpl:()=>_f,transposeImpl:()=>pf,uniqueImpl:()=>Of}),function(){for(var e=0,t=["ms","moz","webkit","o"],n=0;n<t.length&&!window.requestAnimationFrame;++n)window.requestAnimationFrame=window[t[n]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[t[n]+"CancelAnimationFrame"]||window[t[n]+"CancelRequestAnimationFrame"];window.requestAnimationFrame||(window.requestAnimationFrame=function(t,n){var a=(new Date).getTime(),r=Math.max(0,16-(a-e)),s=window.setTimeout((function(){t(a+r)}),r);return e=a+r,s}),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(e){clearTimeout(e)})}();var I=n(379),N=n.n(I),$=n(40);N()($.Z,{insert:"head",singleton:!1}),$.Z.locals;function C(e,t){return"left"===e?[(t+32+40)/2,t-20]:[20,(t-32-40)/2]}function T(e,t,n){let a=!0,r=0,s=0;const o=document.createElement("div");o.className="blind-spot-container",o.innerHTML='\n<p id="blind-spot-instruction">Now, please close your <span id="eye-side"></span> eye.</p>\n<canvas id="blind-spot-canvas"></canvas>',e.appendChild(o);const i=document.querySelector("#blind-spot-canvas"),u=i.getContext("2d"),l=document.getElementById("eye-side");let c,d=l.innerText="left";const p=()=>{i.style.width=(i.width=window.innerWidth)+"px",i.style.height=(i.height=window.innerHeight)+"px",c=C(d,i.width)},h=new ResizeObserver((()=>{p()}));h.observe(e),p();let f=c["left"===d?0:1],m=f,g="left"===d?1:-1;"activeElement"in document&&document.activeElement.blur(),document.addEventListener("keydown",(function o(u){if(" "===u.key){if(u.preventDefault(),s+=1,r=(r*(s-1)/s+function(e,t,n){return Math.abs(t/2-e)/108/(13.5,Math.tan(13.5*Math.PI/180))/.3937}(f,window.innerWidth)/s).toFixed(3),s%t.repeatTesting==0)return n(r),a=!1,h.unobserve(document.body),document.removeEventListener("keydown",o),void document.body.removeChild(e);d=l.innerText="left"===d?"right":"left",c=C(d,i.width),f=c["left"===d?0:1],g="left"===d?1:-1}}));const y=()=>{u.fillStyle="#ddd",u.fillRect(0,0,i.width,i.height),function(e,t,n){e.fillStyle="#000",e.fillRect(t-16,n-2,32,4),e.fillRect(t-2,n-16,4,32)}(u,i.width/2,i.height/2),function(e,t,n){e.beginPath(),e.arc(t,n,20,0,2*Math.PI),e.closePath(),e.fillStyle="#ee0000",e.fill()}(u,f,i.height/2),f+=5*g,m=function(e,t,n){return e<t?t:e>n?n:e}(f,...c),f!==m&&(f=m,g=-g),a&&requestAnimationFrame(y)};requestAnimationFrame(y)}function E(e,t={}){(t=Object.assign({fullscreen:!0,quitFullscreenOnFinished:!1,repeatTesting:2},t)).fullscreen&&function(){if(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled){const e=document.documentElement;e.requestFullscreen?e.requestFullscreen():e.mozRequestFullScreen?e.mozRequestFullScreen():e.webkitRequestFullscreen?e.webkitRequestFullscreen():e.msRequestFullscreen&&e.msRequestFullscreen()}}();const n=document.createElement("div");n.className="calibration-background",n.innerHTML="\n<div class=\"calibration-instruction\">\n\t<h1>📏 Viewing Distance Calibration</h1>\n\t<p>\n\t\tWe'll measure your viewing distance. To do this, we'll perform a <em>blind spot test</em>.\n\t\tCover or close one of your eyes and focus on the black cross.\n\t\tPress <b>SPACE</b> when the red circle disappears.\n\t\tIf it doesn't disappear, you may have to move closer or farther from the screen.\n\t</p>\n</div>",document.body.appendChild(n),T(n,t,e)}class S{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class R{refCount(e){return A("refCount")}incRef(e){return A("incRef")}timerAvailable(){return!0}time(e){return A("time")}read(e){return A("read")}readSync(e){return A("readSync")}numDataIds(){return A("numDataIds")}disposeData(e,t){return A("disposeData")}write(e,t,n){return A("write")}move(e,t,n,a,r){return A("move")}memory(){return A("memory")}floatPrecision(){return A("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return A("dispose")}}function A(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function F(e,t,n){return Math.max(e,Math.min(t,n))}function _(e){return e%2==0?e:e+1}function O(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function D(e,t,n=""){O(B(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function M(e){O(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function L(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||Y(e)&&!n)for(let a=0;a<e.length;++a)L(e[a],t,n);else t.push(e);return t}function P(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function B(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function V(e){return e%1==0}function W(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function z(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function U(e,t=(e=>0),n){return new Promise(((a,r)=>{let s=0;const o=()=>{if(e())return void a();s++;const i=t(s);null!=n&&s>=n?r():setTimeout(o,i)};o()}))}function G(e,t){let n=1,a=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==a)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${t}`);a=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===a){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[a]=t/n,r}function H(e,t){const n=t.length;return O((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),O(e.every((e=>V(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function j(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||r?null:H(t,e).sort();let o=0;for(let t=0;t<e.length;++t){if(null!=s){if(s[o]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==s[o]||s[o]>t)&&1===e[t]&&(n.push(e[t]),a.push(t)),s[o]<=t&&o++}1!==e[t]&&(n.push(e[t]),a.push(t))}return{newShape:n,keptDims:a}}function K(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function X(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function q(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function Y(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function Q(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Z(e){return"string"==typeof e||e instanceof String}function J(e){return Array.isArray(e)?J(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":"number"==typeof e?"float32":Z(e)?"string":"boolean"==typeof e?"bool":"float32"}function ee(e){return!!(e&&e.constructor&&e.call&&e.apply)}function te(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function ne(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function ae(e,t,n){const a=new Array;if(1===t.length){const r=t[0];for(let t=0;t<r;t++)a[t]=n[e+t]}else{const r=t[0],s=t.slice(1),o=s.reduce(((e,t)=>e*t));for(let t=0;t<r;t++)a[t]=ae(e+t*o,s,n)}return a}function re(e,t){if(0===e.length)return t[0];const n=e.reduce(((e,t)=>e*t));if(0===n)return[];if(n!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}.`);return ae(0,e,t)}function se(e,t){const n=oe(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function oe(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function ie(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return re(e,new Float32Array(n));if("int32"===t)return re(e,new Int32Array(n));if("bool"===t)return re(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function ue(e){e.forEach((t=>{O(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function le(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let t=0;t<e.length-1;++t)a+=n[t]*e[t];return a}function ce(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let t=0;t<a.length-1;++t)a[t]=Math.floor(e/n[t]),e-=a[t]*n[t];return a[a.length-1]=e,a}function de(e){return e&&e.then&&"function"==typeof e.then}class pe{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(de(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=function(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)}))}}function he(){return me}let fe,me=null;function ge(){if(null==fe){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}fe=e}return fe}function ye(e,t){const n=function(){const e=ge();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const xe="Abs",be="Acos",ve="Acosh",ke="Add",we="AddN",Ie="All",Ne="Any",$e="ArgMax",Ce="ArgMin",Te="Asin",Ee="Asinh",Se="Atan",Re="Atanh",Ae="Atan2",Fe="AvgPool",_e="AvgPoolGrad",Oe="AvgPool3D",De="AvgPool3DGrad",Me="BatchMatMul",Le="BatchToSpaceND",Pe="Bincount",Be="Cast",Ve="Ceil",We="ClipByValue",ze="Complex",Ue="ComplexAbs",Ge="Concat",He="Conv2D",je="Conv2DBackpropFilter",Ke="Conv2DBackpropInput",Xe="Conv3D",qe="Conv3DBackpropFilterV2",Ye="Conv3DBackpropInputV2",Qe="Cos",Ze="Cosh",Je="Cumsum",et="CropAndResize",tt="DenseBincount",nt="DepthToSpace",at="DepthwiseConv2dNative",rt="DepthwiseConv2dNativeBackpropFilter",st="DepthwiseConv2dNativeBackpropInput",ot="Diag",it="Dilation2D",ut="RealDiv",lt="Elu",ct="EluGrad",dt="Erf",pt="Equal",ht="Exp",ft="ExpandDims",mt="Expm1",gt="FFT",yt="Fill",xt="FlipLeftRight",bt="Floor",vt="FloorDiv",kt="FusedBatchNorm",wt="GatherV2",It="GatherNd",Nt="Greater",$t="GreaterEqual",Ct="Identity",Tt="IFFT",Et="Imag",St="IsFinite",Rt="IsInf",At="IsNan",Ft="LeakyRelu",_t="Less",Ot="LessEqual",Dt="LinSpace",Mt="Log",Lt="Log1p",Pt="LogicalAnd",Bt="LogicalNot",Vt="LogicalOr",Wt="LRN",zt="LRNGrad",Ut="Max",Gt="Maximum",Ht="MaxPool",jt="MaxPoolGrad",Kt="MaxPool3D",Xt="MaxPool3DGrad",qt="MaxPoolWithArgmax",Yt="Mean",Qt="Min",Zt="Minimum",Jt="MirrorPad",en="Mod",tn="Multinomial",nn="Multiply",an="Neg",rn="NotEqual",sn="NonMaxSuppressionV3",on="NonMaxSuppressionV4",un="NonMaxSuppressionV5",ln="OnesLike",cn="OneHot",dn="Pack",pn="PadV2",hn="Pow",fn="Prelu",mn="Prod",gn="Range",yn="Real",xn="Reciprocal",bn="Relu",vn="Reshape",kn="ResizeNearestNeighbor",wn="ResizeNearestNeighborGrad",In="ResizeBilinear",Nn="ResizeBilinearGrad",$n="Relu6",Cn="Reverse",Tn="Round",En="Rsqrt",Sn="ScatterNd",Rn="Select",An="Selu",Fn="Slice",_n="Sin",On="Sinh",Dn="Sign",Mn="Sigmoid",Ln="Softplus",Pn="Sqrt",Bn="Sum",Vn="SpaceToBatchND",Wn="SplitV",zn="Softmax",Un="SquaredDifference",Gn="Square",Hn="Sub",jn="SparseToDense",Kn="StridedSlice",Xn="Tan",qn="Tanh",Yn="Tile",Qn="TopK",Zn="Transform",Jn="Transpose",ea="Unique",ta="Unpack",na="UnsortedSegmentSum",aa="ZerosLike",ra="Step",sa="FromPixels",oa="RotateWithOffset",ia="_FusedMatMul",ua="FusedConv2D",la="FusedDepthwiseConv2D",ca=ye("kernelRegistry",(()=>new Map)),da=ye("gradRegistry",(()=>new Map));function pa(e,t){const n=ga(e,t);return ca.get(n)}function ha(e){return da.get(e)}function fa(e){const t=ca.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[s,o]=r,[i]=s.split("_");i===e&&n.push(o)}return n}function ma(e){const{kernelName:t,backendName:n}=e,a=ga(t,n);ca.has(a)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),ca.set(a,e)}function ga(e,t){return`${t}_${e}`}function ya(e,t){return"string"===t?va(e):xa([e],t)}function xa(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=L(e)),he().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function ba(){return he().platform.now()}function va(e,t="utf-8"){return t=t||"utf-8",he().platform.encode(e,t)}function ka(e,t="utf-8"){return t=t||"utf-8",he().platform.decode(e,t)}class wa{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Na)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let s;const o=ba();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();s=Promise.resolve({kernelMs:ba()-o})}if(he().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<a.length;t++){const n=a[t];n.data().then((t=>{Ia(t,n.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),a,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function Ia(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const a=e[t];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${n}'`),!0}return!1}class Na{logKernelProfile(e,t,n,a,r,s){const o="number"==typeof a?z(`${a}ms`,9):a.error,i=z(e,25),u=t.rank,l=t.size,c=z(t.shape.toString(),14);let d="";for(const e in r){const n=r[e];if(null!=n){const a=n.shape||t.shape,r=a.length;d+=`${e}: ${r}D ${r>0?a:""} `}}console.log(`%c${i}\t%c${o}\t%c${u}D ${c}\t%c${l}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function $a(e,t,n,a){const r=ne(t),s=function(e,t,n,a){const r=P(t),s=a[a.length-1],o=new Array(s).fill(0),i=t.length,u="complex64"===n?Sa(e):e;if(i>1)for(let e=0;e<r/s;e++){const t=e*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],Ca(u[t+e],0,n).length)}return o}(e,t,n,r),o=t.length,i=Ea(e,t,n,r,s),u=["Tensor"];return a&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map((e=>"    "+e)).join("\n")),u.join("\n")}function Ca(e,t,n){let a;return a=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Z(e)?`'${e}'`:"bool"===n?Ta(e):parseFloat(e.toFixed(7)).toString(),z(a,t)}function Ta(e){return 0===e?"false":"true"}function Ea(e,t,n,a,r,s=!0){const o="complex64"===n?2:1,i=t[0],u=t.length;if(0===u)return"complex64"===n?[Ca(Sa(e)[0],0,n)]:"bool"===n?[Ta(e[0])]:[e[0].toString()];if(1===u){if(i>20){const t=3*o;let a=Array.from(e.slice(0,t)),s=Array.from(e.slice((i-3)*o,i*o));return"complex64"===n&&(a=Sa(a),s=Sa(s)),["["+a.map(((e,t)=>Ca(e,r[t],n))).join(", ")+", ..., "+s.map(((e,t)=>Ca(e,r[i-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?Sa(e):Array.from(e)).map(((e,t)=>Ca(e,r[t],n))).join(", ")+"]"]}const l=t.slice(1),c=a.slice(1),d=a[0]*o,p=[];if(i>20){for(let t=0;t<3;t++){const a=t*d,s=a+d;p.push(...Ea(e.slice(a,s),l,n,c,r,!1))}p.push("...");for(let t=i-3;t<i;t++){const a=t*d,s=a+d;p.push(...Ea(e.slice(a,s),l,n,c,r,t===i-1))}}else for(let t=0;t<i;t++){const a=t*d,s=a+d;p.push(...Ea(e.slice(a,s),l,n,c,r,t===i-1))}const h=2===u?",":"";p[0]="["+p[0]+h;for(let e=1;e<p.length-1;e++)p[e]=" "+p[e]+h;let f=",\n";for(let e=2;e<u;e++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(s?"":f),p}function Sa(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Ra{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=P(e),null!=n){const e=n.length;O(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||X(t,this.size),this.strides=ne(e)}set(e,...t){0===t.length&&(t=[0]),O(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Aa().makeTensor(this.values,this.shape,this.dtype)}}let Aa=null,Fa=null,_a=null;class Oa{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=P(e),this.strides=ne(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Fa.buffer(this.shape,this.dtype,e)}bufferSync(){return Fa.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return re(this.shape,e)}arraySync(){return re(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const e=Aa().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>ka(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=Aa().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>ka(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Aa().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Aa().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Fa.print(this,e)}clone(){return this.throwIfDisposed(),Fa.clone(this)}toString(e=!1){return $a(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Fa.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Aa().makeVariable(this,e,t,n)}}Object.defineProperty(Oa,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),ye("Tensor",(()=>Oa));class Da extends Oa{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!B(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Aa().disposeTensor(this),this.dataId=e.dataId,Aa().incRef(this,null)}dispose(){Aa().disposeVariable(this),this.isDisposedInternal=!0}}var Ma,La,Pa,Ba,Va;Object.defineProperty(Da,Symbol.hasInstance,{value:e=>e instanceof Oa&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Ma||(Ma={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(La||(La={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Pa||(Pa={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Ba||(Ba={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Va||(Va={}));const Wa={float32:Ba,int32:La,bool:Pa,complex64:Va};function za(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Wa[e][t]}function Ua(e){return za(e,"int32")}function Ga(e,t){if(e.dtype===t.dtype)return[e,t];const n=za(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Ha(e){const t=[];return ja(e,t,new Set),t}function ja(e,t,n){if(null==e)return;if(e instanceof Oa)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!=typeof a)return;var a;const r=e;for(const e in r){const a=r[e];n.has(a)||(n.add(a),ja(a,t,n))}}function Ka(e){return null!=e.kernelName}class Xa{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class qa{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Xa}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new wa(this.backendInstance),!0}setupRegisteredKernels(){fa(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){fa(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof R||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0)))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(t){return console.warn(`Initialization of backend ${e} failed`),console.warn(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),s=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return qa.nextTensorId++}nextVariableId(){return qa.nextVariableId++}clone(e){const t=Qa.runKernel(Ct,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e};return Qa.runKernel(Be,t,{dtype:"float32"})}})),[],{}),t}runKernel(e,t,n){if(null==pa(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=a-t-r-s;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=Ka(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Ka(e)){const{kernelName:t,inputs:r,attrs:s}=e;null==this.backendName&&this.backend;const u=pa(t,this.backendName);O(null!=u,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),o=()=>{const e=this.backend.numDataIds();i=u.kernelFunc({inputs:r,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);const l=o.map((e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:a}=e;return this.makeTensorFromDataId(t,n,a)}));if(a){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};o=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,d=Ka(e)?null:e.backwardsFunc;let p;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,l,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs):t=o()})),a&&this.addTapeNode(u,l,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const a=ha(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let s;a.saveAllInputs?(O(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const o=n.filter(((e,t)=>r[t]));return s.concat(o)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&Z(e[0])&&(r=e.map((e=>va(e))));const s=a.write(r,t,n),o=new Oa(t,n,s,this.nextTensorId());if(this.trackTensor(o,a),"string"===n){const e=this.state.tensorInfo.get(s),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,a){const r=new Oa(t,n=n||"float32",e,this.nextTensorId());return this.trackTensor(r,a),r}makeVariable(e,t=!0,n,a){n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new Da(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Q(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Da||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Q(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,s){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=ha(e);null!=i&&(a=i.gradFunc),null!=a&&(o.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=oe(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,s))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Ha(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n,a=!1){if(O(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));O(r instanceof Oa,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const a={},r={};for(let e=0;e<t.length;e++)a[t[e].id]=!0;for(let n=0;n<e.length;n++){const s=e[n],o=s.inputs;for(const e in o){const n=o[e];let i=!1;for(let e=0;e<t.length;e++)if(a[n.id]){s.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[s.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let t=e.length-1;t>=0;t--){const n=e[t],a=n.inputs;for(let e=0;e<n.outputs.length;e++)if(s[n.outputs[e].id]){for(const e in a)s[a[e].id]=!0,o[n.id]=!0;break}}const i=[];for(let t=0;t<e.length;t++){const n=e[t];if(r[n.id]&&o[n.id]){const e={};for(const t in n.inputs){const r=n.inputs[t];a[r.id]&&(e[t]=r)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,i.push(t)}}return i}(this.state.activeTape,t,r);if(!a&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=se(P(e),"float32");return Qa.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const s=t[r],o=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const i=s.gradient(o);for(const t in s.inputs){if(!(t in i))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(i)}.`);const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${r.dtype}'`);const o=s.inputs[t];if(!B(r.shape,o.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${r.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=r;else{const t=e[o.id];e[o.id]=a(t,r),t.dispose()}}}}(e,s,(e=>this.tidy(e)),Za);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){return O(ee(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;O(t.every((e=>e instanceof Oa)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const a={};return t.forEach(((e,t)=>{a[t]=e})),this.runKernelFunc({forwardFunc:(a,r)=>(n=e(...t,r),O(n.value instanceof Oa,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),O(ee(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,a)=>{const r=n.gradFunc(e,a),s=Array.isArray(r)?r:[r];O(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),O(s.every((e=>e instanceof Oa)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return s.forEach(((e,t)=>{o[t]=()=>e})),o},inputs:a})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=ba(),n=await this.backend.time(e);return n.wallMs=ba()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Xa;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Ya(){const e=ge();if(null==e._tfengine){const t=new pe(e);e._tfengine=new qa(t)}var t;return t=e._tfengine.ENV,me=t,Aa=()=>e._tfengine,e._tfengine}qa.nextTensorId=0,qa.nextVariableId=0;const Qa=Ya();function Za(e,t){const n={a:e,b:t};return Qa.runKernel(ke,n)}function Ja(){if("undefined"!=typeof navigator&&null!=navigator){const e=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function er(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const tr=he();function nr(e,t){let n=e;if(Y(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||Y(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&he().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ar(e,a,[]),a}function ar(e,t,n){if(n=n||[],!Array.isArray(e)&&!Y(e))return void O(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));O(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),O(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const a=t.slice(1);for(let t=0;t<e.length;++t)ar(e[t],a,n.concat(t))}function rr(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function sr(e,t,n,a="numeric"){if(e instanceof Oa)return rr(a,e.dtype,t,n),e;let r=J(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),rr(a,r,t,n),null==e||!Y(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const a=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${a}'`)}const s=nr(e,r);Y(e)||Array.isArray(e)||(e=[e]);const o="string"!==r?xa(e,r):L(e,[],!0);return Qa.makeTensor(o,s,r)}function or(e,t,n,a="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,r)=>sr(e,`${t}[${r}]`,n,a)))}function ir(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=(...e)=>{Qa.startScope(n);try{const t=a(...e);return de(t)&&console.error("Cannot return a Promise inside of tidy."),Qa.endScope(t),t}catch(e){throw Qa.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}tr.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),tr.registerFlag("IS_BROWSER",(()=>er())),tr.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),tr.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),tr.registerFlag("PROD",(()=>!1)),tr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>tr.getBool("DEBUG"))),tr.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),tr.registerFlag("IS_TEST",(()=>!1)),tr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),tr.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1));const ur=ir({complex_:function(e,t){const n=sr(e,"real","complex"),a=sr(t,"imag","complex");D(n.shape,a.shape,`real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);const r={real:n,imag:a};return Qa.runKernel(ze,r)}});function lr(e,t,n,a){if(null==a&&(a=J(e)),"complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Y(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){ue(t);const e=P(t),a=P(n);O(e===a,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${a}`));for(let e=0;e<n.length;++e){const a=n[e],r=e!==n.length-1||a!==P(t.slice(e));O(n[e]===t[e]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return Y(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?xa(e,a):L(e,[],!0),Qa.makeTensor(e,t,a)}function cr(e,t,n){return lr(e,t,nr(e,n),n)}const dr={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};const pr="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function hr(e){return pr?Buffer.byteLength(e):new Blob([e]).size}function fr(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let a=0;return e.forEach((e=>{n.set(new Uint8Array(e),a),a+=e.byteLength})),n.buffer}function mr(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:hr(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:hr(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function gr(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{const r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let r=0;r<a.length;r++){const o=a[r],i=e[n[o>>10]+(1023&o)]+t[o>>10];s[r]=i}return new Float32Array(r)}}class yr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==yr.instance&&(yr.instance=new yr),yr.instance}static registerSaveRouter(e){yr.getInstance().saveRouters.push(e)}static registerLoadRouter(e){yr.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return yr.getHandlers(e,"save")}static getLoadHandlers(e,t){return yr.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?yr.getInstance().loadRouters:yr.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}}const xr="tensorflowjs",br="models_store",vr="model_info_store";function kr(){if(!he().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function wr(e){const t=e.result;t.createObjectStore(br,{keyPath:"modelPath"}),t.createObjectStore(vr,{keyPath:"modelPath"})}class Ir{constructor(e){if(this.indexedDB=kr(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(xr,1);a.onupgradeneeded=()=>wr(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction(br,"readonly"),a=t.objectStore(br).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{const a=mr(t),s=r.transaction(vr,"readwrite");let o=s.objectStore(vr);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:a});let u;i.onsuccess=()=>{u=r.transaction(br,"readwrite");const i=u.objectStore(br).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});i.onsuccess=()=>e({modelArtifactsInfo:a}),i.onerror=e=>{o=s.objectStore(vr);const t=o.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(i.error)),t.onerror=e=>(r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==u?r.close():u.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}}Ir.URL_SCHEME="indexeddb://";const Nr=e=>{return he().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ir.URL_SCHEME)?(t=e.slice(Ir.URL_SCHEME.length),new Ir(t)):null;var t};yr.registerSaveRouter(Nr),yr.registerLoadRouter(Nr);class $r{constructor(){this.indexedDB=kr()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(xr,1);n.onupgradeneeded=()=>wr(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(vr,"readonly"),s=r.objectStore(vr).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(Ir.URL_SCHEME)?t.slice(Ir.URL_SCHEME.length):t,new Promise(((t,n)=>{const a=this.indexedDB.open(xr,1);a.onupgradeneeded=()=>wr(a),a.onsuccess=()=>{const r=a.result,s=r.transaction(vr,"readwrite"),o=s.objectStore(vr),i=o.get(e);let u;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const a=o.delete(e),s=()=>{u=r.transaction(br,"readwrite");const a=u.objectStore(br).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=s,a.onerror=e=>(s(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==u?r.close():u.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}}const Cr="/",Tr="tensorflowjs_models",Er="info",Sr="model_topology",Rr="weight_specs",Ar="weight_data",Fr="model_metadata";function _r(e){return{info:[Tr,e,Er].join(Cr),topology:[Tr,e,Sr].join(Cr),weightSpecs:[Tr,e,Rr].join(Cr),weightData:[Tr,e,Ar].join(Cr),modelMetadata:[Tr,e,Fr].join(Cr)}}function Or(e){const t=e.split(Cr);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Cr)}class Dr{constructor(e){if(!he().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=_r(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=mr(e);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(pr)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,a=t.length;e<a;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(e.weightData));const r={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(r)),{modelArtifactsInfo:a}}catch(e){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(pr){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(s),t}}Dr.URL_SCHEME="localstorage://";const Mr=e=>{return he().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Dr.URL_SCHEME)?(t=e.slice(Dr.URL_SCHEME.length),new Dr(t)):null;var t};yr.registerSaveRouter(Mr),yr.registerLoadRouter(Mr);class Lr{constructor(){O(he().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),O("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Tr+Cr,n=Cr+Er;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);r.startsWith(t)&&r.endsWith(n)&&(e[Or(r)]=JSON.parse(this.LS.getItem(r)))}return e}async removeModel(e){var t;const n=_r(e=(t=e).startsWith(Dr.URL_SCHEME)?t.slice(Dr.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const a=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),a}}class Pr{constructor(){this.managers={}}static getInstance(){return null==Pr.instance&&(Pr.instance=new Pr),Pr.instance}static registerManager(e,t){O(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),O(e.length>0,(()=>"scheme must not be an empty string."));const n=Pr.getInstance();O(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}class Br{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(he().get("IS_BROWSER")){he().setPlatform("browser",new Br);try{Pr.registerManager(Dr.URL_SCHEME,new Lr)}catch(e){}try{Pr.registerManager(Ir.URL_SCHEME,new $r)}catch(e){}}let Vr;function Wr(e,t="float32",n){return t=t||"float32",ue(e),new Ra(e,t,n)}he().get("IS_NODE")&&he().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=he().global.fetch?he().global.fetch(e,t):(null==Vr&&(Vr=n(410)),Vr(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});const zr=ir({cast_:function(e,t){const n=sr(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return Qa.runKernel(Be,a,r)}}),Ur=ir({clone_:function(e){const t={x:sr(e,"x","clone","string_or_numeric")};return Qa.runKernel(Ct,t)}});function Gr(e){return new Promise((e=>setTimeout(e))).then(e)}Ya(),Fa={buffer:Wr,cast:zr,clone:Ur,print:function(e,t=!1){console.log(e.toString(t))}};class Hr{constructor(e){if(!he().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Hr.URL_SCHEME)&&(e=e.slice(Hr.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer);const r=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),s=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(s.download=this.modelTopologyFileName,s.href=r,await Gr((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await Gr((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:mr(e)}}}}function jr(e,t,n,a){!function(e){O(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){O(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),O(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),O(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map((s=>(s.then((s=>{const o=n+ ++r/e.length*(a-n);return t(o),s})),s))))}async function Kr(e,t){null==t&&(t={});const n=null==t.fetchFunc?he().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await jr(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await jr(r,t.onProgress,.5,1)}Hr.URL_SCHEME="downloads://",yr.registerSaveRouter((e=>he().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Hr.URL_SCHEME)?function(e="model"){return new Hr(e)}(e.slice(Hr.URL_SCHEME.length)):null));class Xr{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(O("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=he().platform.fetch,O(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&O(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),t.body.append("model.json",new Blob([JSON.stringify(a)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:mr(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,a=t.weightsManifest,r=t.generatedBy,s=t.convertedBy,o=t.format,i=t.signature,u=t.userDefinedMetadata;if(null==n&&null==a)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let l,c;if(null!=a){const e=await this.loadWeights(a);[l,c]=e}const d={modelTopology:n,weightSpecs:l,weightData:c,generatedBy:r,convertedBy:s,format:o};null!=i&&(d.signature=i),null!=u&&(d.userDefinedMetadata=u);const p=t.modelInitializer;return p&&(d.modelInitializer=p),d}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),r=this.weightPathPrefix||n,s=[];for(const t of e)s.push(...t.weights);const o=[],i=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):o.push(r+e+a);return this.weightUrlConverter&&o.push(...await Promise.all(i)),[s,fr(await Kr(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function qr(e){return null!=e.match(Xr.URL_SCHEME_REGEX)}Xr.URL_SCHEME_REGEX=/^https?:\/\//;const Yr=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>qr(e))):qr(e),n)return Qr(e,t)}return null};function Qr(e,t){return new Xr(e,t)}function Zr(e,t){return Qr(e,t)}let Jr;yr.registerSaveRouter(Yr),yr.registerLoadRouter(Yr);const es=ir({fromPixels_:function(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)r=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);i=!0}if(r){const t=2;if(r&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=pa(sa,Qa.backendName)){const n={pixels:e},a={numChannels:t};return Qa.runKernel(sa,n,a)}const[u,l]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(o?c=e.getContext("2d").getImageData(0,0,u,l).data:a||n?c=e.data:(s||r||i)&&(null==Jr&&(Jr=document.createElement("canvas").getContext("2d")),Jr.canvas.width=u,Jr.canvas.height=l,Jr.drawImage(e,0,0,u,l),c=Jr.getImageData(0,0,u,l).data),4===t)d=new Int32Array(c);else{const e=u*l;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}return function(e,t,n){if(M(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=nr(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return lr(e,t,a,n)}(d,[l,u,t],"int32")}});function ts(e,t,n){const a=e.shape.length;O(a===t.length,(()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`)),O(a===n.length,(()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`));for(let r=0;r<a;++r)O(t[r]+n[r]<=e.shape[r],(()=>`Error in slice${a}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`))}function ns(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function as(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function rs(e,t,n,a){const r=[...e];for(let e=r.length;e<a.length;e++)r.push(1);for(let e=0;e<n;e++)0===e?r[t]=1:(r.splice(t,0,1),r.pop());return r}function ss(e,t,n){return n<=e?n:n-(t-1)}function os(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function is(e,t,n,a,r,s,o,i,u){const l=e.length;let c=new Array(l),d=new Array(l),p=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=us(o,u,l,a,e),d=ls(i,u,l,r,e),p=rs(s,u,l,e)}else for(let t=0;t<l;t++)c[t]=ds(o,a,s,e,t,u),d[t]=ps(i,r,s,e,t,u),p[t]=cs(s,t,u);return{begin:c,end:d,strides:p}}function us(e,t,n,a,r){const s=[...r],o=os(n,t);for(let r=0;r<s.length;r++)if(o.indexOf(r)>-1)s[r]=0;else{const o=ss(t,n,r);let i=a[o];e&1<<o&&(i=0),s[r]=i}return s}function ls(e,t,n,a,r){const s=[...r],o=os(n,t);for(let r=0;r<s.length;r++)if(o.indexOf(r)>-1)s[r]=Number.MAX_SAFE_INTEGER;else{const o=ss(t,n,r);let i=a[o];e&1<<o&&(i=Number.MAX_SAFE_INTEGER),s[r]=i}for(let e=0;e<s.length;e++){const t=r[e];s[e]<0&&(s[e]+=t),s[e]=F(0,s[e],r[e])}return s}function cs(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function ds(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=a[r];return o<0&&(o+=u),o=F(0,o,u-1),o}function ps(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=a[r];return o<0&&(o+=u),o=i>0?F(0,o,u):F(-1,o,u-1),o}function hs(e,t,n){let a=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){a=e;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function fs(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function ms(e,t,n){let a;const r=e.shape.length;let s;return a="number"==typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{O(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(O(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-a[n]))),[a,s]}function gs(e,t,n,a,r,s,o,i,u){let l=t.slice(),c=n.slice(),d=a;null==a&&(d=new Array(l.length));const p=ns(o);if(p.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==o&&0!==i)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==o&&0!==u)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const h=e.length-l.length,f=ns(i),m=e.slice();f.forEach((e=>{l[e]=0,c[e]=1,m.splice(e,0,1)}));const{begin:g,end:y,strides:x}=is(m,p,h,l,c,d,r,s,o);l=g,c=y,d=x;const b=ns(u);b.forEach((e=>{c[e]=l[e]+1,d[e]=1}));const v=as(l,c,d),k=v.filter(((e,t)=>-1===b.indexOf(t)));return{nonStrided:d.every((e=>1===e)),$begin:l,$end:c,$strides:d,size:v,newShape:m,outShape:k}}const ys=ir({add_:function(e,t){let n=sr(e,"a","add"),a=sr(t,"b","add");[n,a]=Ga(n,a);const r={a:n,b:a};return Qa.runKernel(ke,r)}}),xs=ir({concat_:function(e,t=0){O(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=or(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Ur(n[0]);const a=n,r={axis:t};return Qa.runKernel(Ge,a,r)}}),bs=ir({concat2d_:function(e,t){return xs(e,t)}}),vs=ir({floorDiv_:function(e,t){let n=sr(e,"a","floorDiv"),a=sr(t,"b","floorDiv");[n,a]=Ga(n,a);const r={a:n,b:a};return Qa.runKernel(vt,r)}}),ks=ir({div_:function(e,t){let n=sr(e,"a","div"),a=sr(t,"b","div");if([n,a]=Ga(n,a),"int32"===n.dtype&&"int32"===a.dtype)return vs(n,a);const r={a:n,b:a};return Qa.runKernel(ut,r,{})}}),ws=ir({expandDims_:function(e,t=0){const n=sr(e,"x","expandDims","string_or_numeric");O(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return Qa.runKernel(ft,a,r)}}),Is=ir({mul_:function(e,t){let n=sr(e,"a","mul"),a=sr(t,"b","mul");[n,a]=Ga(n,a);const r={a:n,b:a};return Qa.runKernel(nn,r)}}),Ns=ir({reshape_:function(e,t){const n={x:sr(e,"x","reshape","string_or_numeric")},a={shape:t};return Qa.runKernel(vn,n,a)}});function $s(e,t){if((Y(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Y(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return lr(e,[],[],t)}const Cs=ir({sigmoid_:function(e){const t={x:sr(e,"x","sigmoid")};return Qa.runKernel(Mn,t)}}),Ts=ir({slice_:function(e,t,n){const a=sr(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},s={begin:t,size:n};return Qa.runKernel(Fn,r,s)}}),Es=ir({squeeze_:function(e,t){const n=sr(e,"x","squeeze");return Ns(n,j(n.shape,t).newShape)}}),Ss=ir({stack_:function(e,t=0){const n=or(e,"tensors","stack","string_or_numeric");O(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&O(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return Qa.runKernel(dn,a,r)}}),Rs=ir({sub_:function(e,t){let n=sr(e,"a","sub"),a=sr(t,"b","sub");[n,a]=Ga(n,a);const r={a:n,b:a};return Qa.runKernel(Hn,r)}});function As(e,t){M(e);const n=nr(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return lr(e,null,n,t)}function Fs(e,t,n){if(M(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=nr(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return lr(e,t,a,n)}const _s=ir({unstack_:function(e,t=0){const n=sr(e,"x","unstack","string_or_numeric");O(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const a={value:n},r={axis:t};return Qa.runKernel(ta,a,r)}});function Os(e,t="float32"){if("complex64"===t){const t=Os(e,"float32"),n=Os(e,"float32");return ur(t,n)}const n=oe(P(e),t);return Qa.makeTensor(n,e,t)}const Ds=ir({imag_:function(e){const t={input:sr(e,"input","imag")};return Qa.runKernel(Et,t)}}),Ms=ir({real_:function(e){const t={input:sr(e,"input","real")};return Qa.runKernel(yn,t)}}),Ls=ir({split_:function(e,t,n=0){const a={x:sr(e,"x","split")},r={numOrSizeSplits:t,axis:n};return Qa.runKernel(Wn,a,r)}}),Ps=ir({zerosLike_:function(e){const t={x:sr(e,"x","zerosLike")};return Qa.runKernel(aa,t)}}),Bs=ir({fft_:function(e){O("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Qa.runKernel(gt,t)}}),Vs=ir({rfft_:function(e,t){O("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,r=Ts(e,a,s),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=xs([e,Os(a)],e.shape.length-1),n=t}else r=e;const s=Ps(r),o=Ns(ur(r,s),[a,n]),i=Bs(o),u=Math.floor(n/2)+1,l=Ms(i),c=Ds(i),d=Ls(l,[u,n-u],l.shape.length-1),p=Ls(c,[u,n-u],c.shape.length-1),h=r.shape.slice();return h[r.shape.length-1]=u,Ns(ur(d[0],p[0]),h)}}),Ws=ir({ifft_:function(e){O("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Qa.runKernel(Tt,t)}}),zs=ir({reverse_:function(e,t){const n={x:sr(e,"x","reverse")},a={dims:t};return Qa.runKernel(Cn,n,a)}}),Us=ir({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=Ns(e,[n,t]);a=Ws(r)}else{const r=[n,2*(t-1)],s=Ns(Ms(e),[n,t]),o=Ns(Ds(e),[n,t]),i=zs(Ts(s,[0,1],[n,t-2]),1),u=Is(zs(Ts(o,[0,1],[n,t-2]),1),$s(-1)),l=xs([s,i],1),c=xs([o,u],1),d=Ns(ur(l,c),[r[0],r[1]]);a=Ws(d)}if(a=Ms(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=Ns(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});function Gs(e,t,n){const a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){const o=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(o)}return As(r,"float32")}ir({hammingWindow_:function(e){return Gs(e,.54,.46)}});const Hs=ir({hannWindow_:function(e){return Gs(e,.5,.5)}});function js(e,t,n){const a={shape:e,value:t,dtype:n};return Qa.runKernel(yt,{},a)}const Ks=ir({frame_:function(e,t,n,a=!1,r=0){let s=0;const o=[];for(;s+t<=e.size;)o.push(Ts(e,s,t)),s+=n;if(a)for(;s<e.size;){const a=s+t-e.size,i=xs([Ts(e,s,t-a),js([a],r)]);o.push(i),s+=n}return 0===o.length?Fs([],[0,t]):Ns(xs(o),[o.length,t])}});ir({stft_:function(e,t,n,a,r=Hs){var s;null==a&&(s=t,a=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));const o=Ks(e,t,n),i=Is(o,r(t)),u=[];for(let e=0;e<o.shape[0];e++)u.push(Vs(Ts(i,[e,0],[1,t]),a));return xs(u)}});const Xs=ir({cropAndResize_:function(e,t,n,a,r="bilinear",s=0){const o=sr(e,"image","cropAndResize"),i=sr(t,"boxes","cropAndResize","float32"),u=sr(n,"boxInd","cropAndResize","int32"),l=i.shape[0];O(4===o.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`)),O(2===i.rank&&4===i.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`)),O(1===u.rank&&u.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`)),O(2===a.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`)),O(a[0]>=1&&a[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${a}`)),O("bilinear"===r||"nearest"===r,(()=>`method must be bilinear or nearest, but was ${r}`));const c={image:o,boxes:i,boxInd:u},d={method:r,extrapolationValue:s,cropSize:a};return Qa.runKernel(et,c,d)}}),qs=ir({flipLeftRight_:function(e){const t=sr(e,"image","flipLeftRight","float32");O(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return Qa.runKernel(xt,n,{})}}),Ys=ir({rotateWithOffset_:function(e,t,n=0,a=.5){const r=sr(e,"image","rotateWithOffset","float32");O(4===r.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`));const s={image:r},o={radians:t,fillValue:n,center:a};return Qa.runKernel(oa,s,o)}});function Qs(e,t,n,a,r,s){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=e.shape[0];return n=Math.min(n,o),O(0<=a&&a<=1,(()=>`iouThreshold must be in [0, 1], but was '${a}'`)),O(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),O(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),O(1===t.rank,(()=>"scores must be a 1D tensor")),O(t.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`)),O(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}const Zs=ir({nonMaxSuppression_:function(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){const s=sr(e,"boxes","nonMaxSuppression"),o=sr(t,"scores","nonMaxSuppression"),i=Qs(s,o,n,a,r),u={maxOutputSize:n=i.maxOutputSize,iouThreshold:a=i.iouThreshold,scoreThreshold:r=i.scoreThreshold};return Qa.runKernel(sn,{boxes:s,scores:o},u)}});function Js(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,s=0,o=!1;for(;a<r;){s=a+(r-a>>>1);const i=n(t,e[s]);i>0?a=s+1:(r=s,o=!i)}return o?a:-a-1}(e,t,n||eo)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function eo(e,t){return e>t?1:e<t?-1:0}function to(e,t,n,a,r){return ro(e,t,n,a,r,0)}function no(e,t,n,a,r,s){return ro(e,t,n,a,r,0,!1,s,!0)}function ao(e,t,n,a,r,s){return ro(e,t,n,a,r,s,!0)}function ro(e,t,n,a,r,s,o=!1,i=!1,u=!1){const l=[];for(let e=0;e<t.length;e++)t[e]>r&&l.push({score:t[e],boxIndex:e,suppressBeginIndex:0});l.sort(io);const c=s>0?-.5/s:0,d=[],p=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=t;if(n<r)break;let i=!1;for(let n=d.length-1;n>=o;--n){const o=so(e,s,d[n]);if(o>=a){i=!0;break}if(t.score=t.score*oo(a,c,o),t.score<=r)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(s),p.push(t.score)):t.score>r&&Js(l,t,io))}const h=d.length,f=n-h;i&&f>0&&(d.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const m={selectedIndices:d};return o&&(m.selectedScores=p),u&&(m.validOutputs=h),m}function so(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),s=Math.min(a[0],a[2]),o=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),u=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),h=(i-s)*(u-o),f=(d-l)*(p-c);if(h<=0||f<=0)return 0;const m=Math.max(s,l),g=Math.max(o,c),y=Math.min(i,d),x=Math.min(u,p),b=Math.max(y-m,0)*Math.max(x-g,0);return b/(h+f-b)}function oo(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function io(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const uo=ir({nonMaxSuppressionWithScore_:function(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=sr(e,"boxes","nonMaxSuppression"),i=sr(t,"scores","nonMaxSuppression"),u=Qs(o,i,n,a,r,s),l={boxes:o,scores:i},c={maxOutputSize:n=u.maxOutputSize,iouThreshold:a=u.iouThreshold,scoreThreshold:r=u.scoreThreshold,softNmsSigma:s=u.softNmsSigma},d=Qa.runKernel(un,l,c);return{selectedIndices:d[0],selectedScores:d[1]}}}),lo=ir({nonMaxSuppressionPadded_:function(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=sr(e,"boxes","nonMaxSuppression"),i=sr(t,"scores","nonMaxSuppression"),u=Qs(o,i,n,a,r,null),l={boxes:o,scores:i},c={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:s},d=Qa.runKernel(on,l,c);return{selectedIndices:d[0],validOutputs:d[1]}}}),co=ir({resizeBilinear_:function(e,t,n=!1,a=!1){const r=sr(e,"images","resizeBilinear");O(3===r.rank||4===r.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`)),O(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),O(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=Ns(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},u={alignCorners:n,halfPixelCenters:a,size:t},l=Qa.runKernel(In,i,u);return o?Ns(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),po=ir({resizeNearestNeighbor_:function(e,t,n=!1,a=!1){const r=sr(e,"images","resizeNearestNeighbor");O(3===r.rank||4===r.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`)),O(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),O("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),O(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=Ns(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},u={alignCorners:n,halfPixelCenters:a,size:t},l=Qa.runKernel(kn,i,u);return o?Ns(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),ho=ir({transform_:function(e,t,n="nearest",a="constant",r=0,s){const o=sr(e,"image","transform","float32"),i=sr(t,"transforms","transform","float32");O(4===o.rank,(()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`)),O(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),O(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const u={image:o,transforms:i},l={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return Qa.runKernel(Zn,u,l)}});function fo(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const s=n-1-r,o=e[s]||1;(t[t.length-1-r]||1)>1&&1===o&&a.unshift(s)}return a}function mo(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],s=t.length-a-1,o=t[s];(null==r||1===r&&o>1)&&n.unshift(s)}return n}function go(e,t){const n=[],a=Math.max(e.length,t.length);for(let r=0;r<a;r++){let a=e[e.length-r-1];null==a&&(a=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===a)n.unshift(s);else if(1===s)n.unshift(a);else{if(a!==s)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(a)}}return n}const yo=ir({greaterEqual_:function(e,t){let n=sr(e,"a","greaterEqual"),a=sr(t,"b","greaterEqual");[n,a]=Ga(n,a),go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel($t,r)}}),xo=ir({lessEqual_:function(e,t){let n=sr(e,"a","lessEqual"),a=sr(t,"b","lessEqual");[n,a]=Ga(n,a),go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(Ot,r)}}),bo=ir({logicalAnd_:function(e,t){const n=sr(e,"a","logicalAnd","bool"),a=sr(t,"b","logicalAnd","bool");go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(Pt,r)}});function vo(e,t,n=1,a="float32"){if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return Qa.runKernel(gn,{},r)}const ko=ir({broadcastTo_:function(e,t){let n=sr(e,"broadcastTo","x");const a=n.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Ns(n,e)}const r=n.shape,s=Array.from(t);for(let e=t.length-1;e>=0;e--)if(r[e]===t[e])s[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Ur(n);const o={x:n},i={reps:s};return Qa.runKernel(Yn,o,i)}}),wo=ir({where_:function(e,t,n){const a=sr(t,"a","where"),r=sr(n,"b","where"),s=sr(e,"condition","where","bool"),o=go(a.shape,r.shape),i=ko(a,o),u=ko(r,o);1===s.rank&&O(s.shape[0]===a.shape[0],(()=>"The first dimension of `a` must match the size of `condition`.")),1!==s.rank&&D(s.shape,u.shape,"Error in where: ");const l={condition:s,t:i,e:u};return Qa.runKernel(Rn,l)}});ir({bandPart_:function(e,t,n){O(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),O(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const a=sr(e,"a","bandPart");O(a.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${a.rank}.`));const r=a.shape,[s,o]=a.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);t<0&&(t=s),n<0&&(n=o);const i=Ns(vo(0,s,1,"int32"),[-1,1]),u=vo(0,o,1,"int32"),l=Rs(i,u),c=bo(xo(l,$s(+t,"int32")),yo(l,$s(-n,"int32"))),d=Os([s,o],a.dtype);return Ns(Ss(_s(Ns(a,[-1,s,o])).map((e=>wo(c,e,d)))),r)}});const Io=ir({abs_:function(e){const t=sr(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Qa.runKernel(Ue,e)}{const e={x:t};return Qa.runKernel(xe,e)}}});function No(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function $o(e,t,n){const a=e.length+t.length,r=[];let s=0,o=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[s++]):r.push(t[o++]);return r}function Co(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function To(e,t){return $o(e,t.map((e=>1)),t)}function Eo(e,t,n){O(No(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function So(e,t){if(No(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function Ro(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Ao(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const Fo=ir({max_:function(e,t=null,n=!1){const a={x:sr(e,"x","max")},r={reductionIndices:t,keepDims:n};return Qa.runKernel(Ut,a,r)}}),_o=ir({min_:function(e,t=null,n=!1){const a={x:sr(e,"x","min")},r={axis:t,keepDims:n};return Qa.runKernel(Qt,a,r)}}),Oo=ir({pow_:function(e,t){let n=sr(e,"base","pow"),a=sr(t,"exp","pow");[n,a]=Ga(n,a);const r={a:n,b:a};return Qa.runKernel(hn,r)}}),Do=ir({sqrt_:function(e){const t={x:sr(e,"x","sqrt")};return Qa.runKernel(Pn,t)}}),Mo=ir({square_:function(e){const t=sr(e,"x","square");return Qa.runKernel("Square",{x:t},{})}}),Lo=ir({sum_:function(e,t=null,n=!1){let a=sr(e,"x","sum");"bool"===a.dtype&&(a=zr(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return Qa.runKernel(Bn,r,s)}});function Po(e,t,n=null){if(0===e.rank)return Io(e);if(1!==e.rank&&null===n)return Po(Ns(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Lo(Io(e),n);if(t===1/0)return Fo(Io(e),n);if(t===-1/0)return _o(Io(e),n);if("euclidean"===t||2===t)return Do(Lo(Oo(Io(e),$s(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Fo(Lo(Io(e),n[0]),n[1]-1);if(t===1/0)return Fo(Lo(Io(e),n[1]),n[0]);if(t===-1/0)return _o(Lo(Io(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Do(Lo(Mo(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Bo=ir({norm_:function(e,t="euclidean",n=null,a=!1){const r=Po(e=sr(e,"x","norm"),t,n);let s=r.shape;if(a){const t=H(n,e.shape);s=To(r.shape,t)}return Ns(r,s)}});function Vo(){return Qa}function Wo(e,t){return Qa.tidy(e,t)}function zo(e){return Qa.keep(e)}function Uo(e,t,n=1){return Qa.registerBackend(e,t,n)}ir({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,O(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)O(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=Ls(e,e.shape[0],0).map((e=>Es(e,[0])));O(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],a=e;for(let t=0;t<e.length;++t)n.push(Qa.tidy((()=>{let e=a[t];if(t>0)for(let a=0;a<t;++a){const t=Is(Lo(Is(n[a],e)),n[a]);e=Rs(e,t)}return ks(e,Bo(e,"euclidean"))})));return t?Ss(n,0):n}}),_a=function(e){he().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const Go=ir({tile_:function(e,t){const n=sr(e,"x","tile","string_or_numeric");O(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const a={x:n},r={reps:t};return Qa.runKernel(Yn,a,r)}}),Ho=ir({eye_:function(e,t,n,a="float32"){null==t&&(t=e);const r=Wr([e,t],a),s=e<=t?e:t;for(let e=0;e<s;++e)r.set(1,e,e);const o=Ns(r.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return Go(ws(o,0),[n[0],1,1]);if(2===n.length)return Go(ws(ws(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Go(ws(ws(ws(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),jo=ir({greater_:function(e,t){let n=sr(e,"a","greater"),a=sr(t,"b","greater");[n,a]=Ga(n,a),go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(Nt,r)}}),Ko=ir({matMul_:function(e,t,n=!1,a=!1){let r=sr(e,"a","matMul"),s=sr(t,"b","matMul");[r,s]=Ga(r,s);const o={a:r,b:s},i={transposeA:n,transposeB:a};return Qa.runKernel(Me,o,i)}}),Xo=ir({neg_:function(e){const t={x:sr(e,"x","neg")};return Qa.runKernel(an,t)}}),qo=ir({transpose_:function(e,t){const n=sr(e,"x","transpose");if(null==t&&(t=n.shape.map(((e,t)=>t)).reverse()),O(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`)),t.forEach((e=>{O(e>=0&&e<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`))})),n.rank<=1)return n.clone();const a={x:n},r={perm:t};return Qa.runKernel(Jn,a,r)}});function Yo(e,t=!1){return Qa.tidy((()=>{O(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],a=e.shape[1];let r=Ho(n),s=Ur(e);const o=Fs([[1]],[1,1]);let i=Ur(o);const u=n>=a?a:n;for(let e=0;e<u;++e){const t=s,u=i,l=r;[i,s,r]=Qa.tidy((()=>{const t=Ts(s,[e,e],[n-e,1]),u=Bo(t),l=Ts(s,[e,e],[1,1]),c=wo(jo(l,0),Fs([[-1]]),Fs([[1]])),d=Rs(l,Is(c,u)),p=ks(t,d);i=1===p.shape[0]?Ur(o):xs([o,Ts(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);const h=Xo(ks(Ko(c,d),u)),f=Ts(s,[e,0],[n-e,a]),m=Is(h,i),g=qo(i);if(0===e)s=Rs(f,Ko(m,Ko(g,f)));else{const t=Rs(f,Ko(m,Ko(g,f)));s=xs([Ts(s,[0,0],[e,a]),t],0)}const y=qo(m),x=Ts(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=Rs(x,Ko(Ko(x,i),y));else{const t=Rs(x,Ko(Ko(x,i),y));r=xs([Ts(r,[0,0],[n,e]),t],1)}return[i,s,r]})),Ha([t,u,l]).forEach((e=>e.dispose()))}return!t&&n>a&&(r=Ts(r,[0,0],[n,a]),s=Ts(s,[0,0],[a,a])),[r,s]}))}var Qo;ir({qr_:function(e,t=!1){if(O(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Yo(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=_s(Ns(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];return a.forEach((e=>{const[n,a]=Yo(e,t);r.push(n),s.push(a)})),[Ns(Ss(r,0),e.shape),Ns(Ss(s,0),e.shape)]}}}),function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Qo||(Qo={}));const Zo=ir({mean_:function(e,t=null,n=!1){const a={x:sr(e,"x","mean")},r={axis:t,keepDims:n};return Qa.runKernel(Yt,a,r)}}),Jo=ir({notEqual_:function(e,t){let n=sr(e,"a","notEqual"),a=sr(t,"b","notEqual");[n,a]=Ga(n,a),go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(rn,r)}});function ei(e,t="float32"){if("complex64"===t){const t=ei(e,"float32"),n=Os(e,"float32");return ur(t,n)}const n=se(P(e),t);return Qa.makeTensor(n,e,t)}const ti=ir({computeWeightedLoss_:function(e,t,n=Qo.SUM_BY_NONZERO_WEIGHTS){const a=sr(e,"losses","computeWeightedLoss");let r=null;null!=t&&(r=sr(t,"weights","computeWeightedLoss"));const s=null==r?a:Is(a,r);if(n===Qo.NONE)return s;if(n===Qo.SUM)return Lo(s);if(n===Qo.MEAN){if(null==r)return Zo(s);{const e=a.size/r.size,t=ks(Lo(s),Lo(r));return e>1?ks(t,$s(e)):t}}if(n===Qo.SUM_BY_NONZERO_WEIGHTS){if(null==r)return ks(Lo(s),$s(a.size));{const e=Is(r,ei(a.shape)),t=zr(Lo(Jo(e,$s(0))),"float32");return ks(Lo(s),t)}}throw Error(`Unknown reduction: ${n}`)}});ir({absoluteDifference_:function(e,t,n,a=Qo.SUM_BY_NONZERO_WEIGHTS){const r=sr(e,"labels","absoluteDifference"),s=sr(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=sr(n,"weights","absoluteDifference")),D(r.shape,s.shape,"Error in absoluteDifference: ");const i=Io(Rs(r,s));return ti(i,o,a)}}),ir({cosineDistance_:function(e,t,n,a,r=Qo.SUM_BY_NONZERO_WEIGHTS){const s=sr(e,"labels","cosineDistance"),o=sr(t,"predictions","cosineDistance");let i=null;null!=a&&(i=sr(a,"weights","cosineDistance")),D(s.shape,o.shape,"Error in cosineDistance: ");const u=$s(1),l=Rs(u,Lo(Is(s,o),n,!0));return ti(l,i,r)}});const ni=ir({relu_:function(e){const t={x:sr(e,"x","relu")};return Qa.runKernel(bn,t)}});ir({hingeLoss_:function(e,t,n,a=Qo.SUM_BY_NONZERO_WEIGHTS){let r=sr(e,"labels","hingeLoss");const s=sr(t,"predictions","hingeLoss");let o=null;null!=n&&(o=sr(n,"weights","hingeLoss")),D(r.shape,s.shape,"Error in hingeLoss: ");const i=$s(1);r=Rs(Is($s(2),r),i);const u=ni(Rs(i,Is(r,s)));return ti(u,o,a)}});const ai=ir({minimum_:function(e,t){let n=sr(e,"a","minimum"),a=sr(t,"b","minimum");[n,a]=Ga(n,a),"bool"===n.dtype&&(n=zr(n,"int32"),a=zr(a,"int32")),go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(Zt,r)}});ir({huberLoss_:function(e,t,n,a=1,r=Qo.SUM_BY_NONZERO_WEIGHTS){const s=sr(e,"labels","huberLoss"),o=sr(t,"predictions","huberLoss");let i=null;null!=n&&(i=sr(n,"weights","huberLoss")),D(s.shape,o.shape,"Error in huberLoss: ");const u=$s(a),l=Io(Rs(o,s)),c=ai(l,u),d=Rs(l,c),p=ys(Is($s(.5),Mo(c)),Is(u,d));return ti(p,i,r)}});const ri=ir({log_:function(e){const t={x:sr(e,"x","log")};return Qa.runKernel(Mt,t)}});ir({logLoss_:function(e,t,n,a=1e-7,r=Qo.SUM_BY_NONZERO_WEIGHTS){const s=sr(e,"labels","logLoss"),o=sr(t,"predictions","logLoss");let i=null;null!=n&&(i=sr(n,"weights","logLoss")),D(s.shape,o.shape,"Error in logLoss: ");const u=$s(1),l=$s(a),c=Xo(Is(s,ri(ys(o,l)))),d=Is(Rs(u,s),ri(ys(Rs(u,o),l))),p=Rs(c,d);return ti(p,i,r)}});const si=ir({squaredDifference_:function(e,t){let n=sr(e,"a","squaredDifference"),a=sr(t,"b","squaredDifference");[n,a]=Ga(n,a),go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(Un,r,{})}});ir({meanSquaredError_:function(e,t,n,a=Qo.SUM_BY_NONZERO_WEIGHTS){const r=sr(e,"labels","meanSquaredError"),s=sr(t,"predictions","meanSquaredError");let o=null;null!=n&&(o=sr(n,"weights","meanSquaredError")),D(r.shape,s.shape,"Error in meanSquaredError: ");const i=si(r,s);return ti(i,o,a)}});const oi=ir({exp_:function(e){const t={x:sr(e,"x","exp")};return Qa.runKernel(ht,t)}}),ii=ir({log1p_:function(e){const t={x:sr(e,"x","log1p")};return Qa.runKernel(Lt,t)}});function ui(e){return Qa.customGrad(e)}ir({sigmoidCrossEntropy_:function(e,t,n,a=0,r=Qo.SUM_BY_NONZERO_WEIGHTS){let s=sr(e,"multiClassLabels","sigmoidCrossEntropy");const o=sr(t,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=sr(n,"weights","sigmoidCrossEntropy")),D(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),a>0){const e=$s(a),t=$s(1),n=$s(.5);s=ys(Is(s,Rs(t,e)),Is(n,e))}const u=function(e,t){const n=sr(e,"labels","sigmoidCrossEntropyWithLogits"),a=sr(t,"logits","sigmoidCrossEntropyWithLogits");D(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=ni(a),s=Is(a,n),o=ii(oi(Xo(Io(a))));return ys(Rs(r,s),o)}(s,o);return ti(u,i,r)}});const li=ir({logSumExp_:function(e,t=null,n=!1){const a=sr(e,"x","logSumExp"),r=H(t,a.shape),s=Fo(a,r,!0),o=Rs(a,s),i=oi(o),u=Lo(i,r),l=ri(u),c=ys(Ns(s,l.shape),l);if(n){const e=To(c.shape,r);return Ns(c,e)}return c}});ir({softmaxCrossEntropy_:function(e,t,n,a=0,r=Qo.SUM_BY_NONZERO_WEIGHTS){let s=sr(e,"onehotLabels","softmaxCrossEntropy");const o=sr(t,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=sr(n,"weights","softmaxCrossEntropy")),D(s.shape,o.shape,"Error in softmaxCrossEntropy: "),a>0){const e=$s(a),t=$s(1),n=$s(s.shape[1]);s=ys(Is(s,Rs(t,e)),ks(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return ui(((e,t,a)=>{const r=li(t,[n],!0),s=Rs(zr(t,"float32"),r);a([e,s]);const o=Xo(Is(s,e));return{value:Lo(o,[n]),gradFunc:(e,t)=>{const[a,r]=t,s=To(e.shape,[n]);return[Is(Ns(e,s),Rs(zr(a,"float32"),oi(r))),Is(Ns(e,s),Rs(oi(r),zr(a,"float32")))]}}}))(e,t)}(s,o);return ti(u,i,r)}});const ci={flipLeftRight:qs,resizeNearestNeighbor:po,resizeBilinear:co,rotateWithOffset:Ys,cropAndResize:Xs,nonMaxSuppression:Zs,nonMaxSuppressionAsync:async function(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){const s=sr(e,"boxes","nonMaxSuppressionAsync"),o=sr(t,"scores","nonMaxSuppressionAsync"),i=Qs(s,o,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const u=await Promise.all([s.data(),o.data()]),l=u[0],c=u[1],{selectedIndices:d}=to(l,c,n,a,r);return s!==e&&s.dispose(),o!==t&&o.dispose(),As(d,"int32")},nonMaxSuppressionWithScore:uo,nonMaxSuppressionWithScoreAsync:async function(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){const o=sr(e,"boxes","nonMaxSuppressionAsync"),i=sr(t,"scores","nonMaxSuppressionAsync"),u=Qs(o,i,n,a,r,s);n=u.maxOutputSize,a=u.iouThreshold,r=u.scoreThreshold,s=u.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),c=l[0],d=l[1],{selectedIndices:p,selectedScores:h}=ao(c,d,n,a,r,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:As(p,"int32"),selectedScores:As(h)}},nonMaxSuppressionPadded:lo,nonMaxSuppressionPaddedAsync:async function(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){const o=sr(e,"boxes","nonMaxSuppressionAsync"),i=sr(t,"scores","nonMaxSuppressionAsync"),u=Qs(o,i,n,a,r,null),l=u.maxOutputSize,c=u.iouThreshold,d=u.scoreThreshold,[p,h]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:m}=no(p,h,l,c,d,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:As(f,"int32"),validOutputs:$s(m,"int32")}},transform:ho};function di(e,t){const n=e[0].length;e.forEach(((e,t)=>{O(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),O(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const a=e[0];e.forEach(((e,r)=>{for(let s=0;s<n;s++)O(s===t||e[s]===a[s],(()=>`Error in concat${n}D: Shape of tensors[${r}] (${e}) does not match the shape of the rest (${a}) along the non-concatenated axis ${r}.`))}))}function pi(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}function hi(e,t,n,a,r="NHWC",s){return gi(e,[...t,e[3]],n,s,a,null,null,$i(r))}function fi(e,t,n,a,r,s,o="channelsLast"){const[i,u]=bi(t);let l;if("channelsLast"===o)l=[i,u,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);l=[i,u,e[1],e[1]]}return gi(e,l,n,a,r,s,!1,o)}function mi(e,t,n,a,r,s,o="NDHWC"){const[i,u,l]=vi(t);let c,d;if("NDHWC"===o)d="channelsLast",c=[i,u,l,e[4],e[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",c=[i,u,l,e[1],e[1]]}return yi(e,c,n,a,r,!1,d,s)}function gi(e,t,n,a,r,s,o=!1,i="channelsLast"){let[u,l,c,d]=[-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,l,c]=e}const[p,h,,f]=t,[m,g]=bi(n),[y,x]=bi(a),b=ki(p,y),v=ki(h,x),{padInfo:k,outHeight:w,outWidth:I}=function(e,t,n,a,r,s,o,i,u){let l,c,d;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=xi(e,t,n));const s=e[1];return[wi((e[0]-t+2*a)/n+1,r),wi((s-t+2*a)/n+1,r)]}([t,n],s,a,e,i);c=r[0],d=r[1]}else if("same"===e){c=Math.ceil(t/a),d=Math.ceil(n/r);const e=Math.max(0,(c-1)*a+s-t),i=Math.max(0,(d-1)*r+o-n),u=Math.floor(e/2),p=e-u,h=Math.floor(i/2);l={top:u,bottom:p,left:h,right:i-h,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/a),d=Math.ceil((n-o+1)/r);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const p="channelsLast"===u?e[1][0]:e[2][0],h="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:p,bottom:h,left:f,right:m,type:0===p&&0===h&&0===f&&0===m?"VALID":"EXPLICIT"},c=wi((t-s+p+h)/a+1,i),d=wi((n-o+f+m)/r+1,i)}}return{padInfo:l,outHeight:c,outWidth:d}}(r,l,c,m,g,b,v,s,i),N=o?f*d:f;let $;return"channelsFirst"===i?$=[u,N,w,I]:"channelsLast"===i&&($=[u,w,I,N]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:d,outHeight:w,outWidth:I,outChannels:N,padInfo:k,strideHeight:m,strideWidth:g,filterHeight:p,filterWidth:h,effectiveFilterHeight:b,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:x,inShape:e,outShape:$,filterShape:t}}function yi(e,t,n,a,r,s=!1,o="channelsLast",i){let[u,l,c,d,p]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,d,p]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,p,l,c,d]=e}const[h,f,m,,g]=t,[y,x,b]=vi(n),[v,k,w]=vi(a),I=ki(h,v),N=ki(f,k),$=ki(m,w),{padInfo:C,outDepth:T,outHeight:E,outWidth:S}=function(e,t,n,a,r,s,o,i,u,l,c){let d,p,h,f;if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,a,r,s){null==r&&(r=xi(e,t,a));const o=e[1],i=e[2];return[wi((e[0]-t+2*r)/a+1,s),wi((o-t+2*r)/a+1,s),wi((i-t+2*r)/a+1,s),1]}([t,n,a,1],i,0,r,e,c);p=s[0],h=s[1],f=s[2]}else if("same"===e){p=Math.ceil(t/r),h=Math.ceil(n/s),f=Math.ceil(a/o);const e=(p-1)*r+i-t,c=(h-1)*s+u-n,m=(f-1)*o+l-a,g=Math.floor(e/2),y=e-g,x=Math.floor(c/2),b=c-x,v=Math.floor(m/2);d={top:x,bottom:b,left:v,right:m-v,front:g,back:y,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((t-i+1)/r),h=Math.ceil((n-u+1)/s),f=Math.ceil((a-l+1)/o)}return{padInfo:d,outDepth:p,outHeight:h,outWidth:f}}(r,l,c,d,y,x,b,I,N,$,i),R=s?g*p:g;let A;return"channelsFirst"===o?A=[u,R,T,E,S]:"channelsLast"===o&&(A=[u,T,E,S,R]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:c,inWidth:d,inChannels:p,outDepth:T,outHeight:E,outWidth:S,outChannels:R,padInfo:C,strideDepth:y,strideHeight:x,strideWidth:b,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:N,effectiveFilterWidth:$,dilationDepth:v,dilationHeight:k,dilationWidth:w,inShape:e,outShape:A,filterShape:t}}function xi(e,t,n,a=1){const r=ki(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function bi(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function vi(e){return"number"==typeof e?[e,e,e]:e}function ki(e,t){return t<=1?e:e+(e-1)*(t-1)}function wi(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ii(e){const[t,n,a]=bi(e);return 1===t&&1===n&&1===a}function Ni(e,t){return Ii(e)||Ii(t)}function $i(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}const Ci=ir({elu_:function(e){const t={x:sr(e,"x","elu")};return Qa.runKernel(lt,t)}}),Ti=ir({leakyRelu_:function(e,t=.2){const n={x:sr(e,"x","leakyRelu")},a={alpha:t};return Qa.runKernel(Ft,n,a)}}),Ei=ir({prelu_:function(e,t){const n={x:sr(e,"x","prelu"),alpha:sr(t,"alpha","prelu")};return Qa.runKernel(fn,n)}}),Si=ir({relu6_:function(e){const t={x:sr(e,"x","relu6")};return Qa.runKernel($n,t)}}),Ri=ir({step_:function(e,t=0){const n={x:sr(e,"x","step")},a={alpha:t};return Qa.runKernel(ra,n,a)}});function Ai(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Is(e,Ri(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Fi(e,t){let n=t;const a=mo(e.shape,t.shape);return a.length>0&&(n=Lo(n,a)),Ns(n,e.shape)}function _i(e,t,n,a){if("linear"===t)return e;if("relu"===t)return ni(e);if("elu"===t)return Ci(e);if("relu6"===t)return Si(e);if("prelu"===t)return Ei(e,n);if("leakyrelu"===t)return Ti(e,a);throw new Error(`Unknown fused activation ${t}.`)}const Oi=(e,t)=>!(e>0)||"linear"===t,Di=30;function Mi(e){return e<=Di?e:te(e,Math.floor(Math.sqrt(e)))}function Li(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Pi(e,t,n,a=!0){let r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function Bi(e,t,n=!0){const a=[];if(n){a.push(t);for(let n=t+1;n<e;++n)n<=2*t?(a.push(n),a.push(n-(t+1))):a.push(n)}else{const n=[],r=[];for(let a=1;a<e;++a)a>=2*t+1||a%2==1?r.push(a):n.push(a);a.push(...n),a.push(0),a.push(...r)}return a}function Vi(e,t,n,a=!0){const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?a?r.push(t[n-1]*e[n]):r.push(e[n]/t[n-1]):r.push(e[n]);return r}function Wi(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function zi(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}function Ui(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(0===P(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const r=t.shape,s=r[r.length-1];let o=1;for(let e=0;e<r.length-1;++e)o*=r[e];const i=e.shape,u=r.slice();u.pop();let l=1;for(let e=s;e<n;++e)l*=i[e],u.push(i[e]);const c=[...ne(e.shape).map((e=>e/l)),1].slice(0,s);return[u,o,l,c]}function Gi(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(e.length<a+(n.rank-r))throw new Error(s+` Output shape length < ${a+(n.rank-r)}`);if(n.rank!==r+e.length-a)throw new Error(s+" update.rank != "+(r+e.length-a));for(let e=0;e<r;++e)if(n.shape[e]!==t.shape[e])throw new Error(s+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-r;++t)if(n.shape[t+r]!==e[t+a])throw new Error(s+` updates.shape[${t+r}] (${n.shape[t+r]}) != shape[${t+r}] (${e[t+r]})`)}function Hi(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Gi(n,t,e)}function ji(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length;let o=1;for(let e=r;e<s;++e)o*=n[e];const i=r<1?1:r;return{sliceRank:r,numUpdates:P(t.shape)/i,sliceSize:o,strides:[...ne(n.slice(0,r)),1],outputSize:P(n)}}const Ki=1.7580993408473768,Xi=1.0507009873554805,qi=.3275911,Yi=.254829592,Qi=-.284496736,Zi=1.421413741,Ji=-1.453152027,eu=1.061405429;function tu(...e){he().getBool("IS_TEST")||console.warn(...e)}function nu(...e){he().getBool("IS_TEST")||console.log(...e)}function au(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function ru(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function su(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],a[Math.floor(t/4)]=e[t+1];return{real:n,imag:a}}function ou(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],a[Math.floor(t/4)]=e[t+1];return{real:n,imag:a}}function iu(e,t){return{real:e[2*t],imag:e[2*t+1]}}function uu(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function lu(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function cu(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}function du(e,t,n=0){let a=[];if("number"==typeof t)O(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{O(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));const r=t.indexOf(-1);if(-1!==r){const a=t.reduce(((e,t)=>t>0?e+t:e));t[r]=e.shape[n]-a}O(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}function pu(e,t){let n,a=!1;for(e<=Di?(n=e,a=!0):n=te(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=te(e,n+1);return n}function hu(e,t,n){const a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function fu(e,t,n,a){const r=t.shape.length,s=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);if(a<0&&(a+=r),a>s)throw new Error(`batchDims (${a}) must be less than rank(x) (\n    ${s}).`);if(n<a)throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);for(let n=0;n<a;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const o=e.shape[n],i=[];let u=1,l=1,c=1;for(let t=0;t<a;++t)i.push(e.shape[t]),u*=e.shape[t];for(let t=a;t<n;t++)i.push(e.shape[t]),l*=e.shape[t];for(let e=a;e<r;e++)i.push(t.shape[e]);for(let t=n+1;t<s;t++)i.push(e.shape[t]),c*=e.shape[t];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}function mu(e){try{return e.map((e=>ka(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function gu(e){return e.map((e=>va(e)))}function yu(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const a=Wr(e,"int32"),r=Wr([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const s=a.indexToLoc(n[t]),o=t*e.length;r.values.set(s,o)}return r.toTensor()}var xu,bu;!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(xu||(xu={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(bu||(bu={}));const vu={};function ku(e){return vu[e]}function wu(e,t,n,a,r){const s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){const e=s.inputIndexStart,o=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd;if("tensor"===s.type)return Iu(t.inputNames[s.inputIndexStart],n,a,r);if("tensors"===s.type)return t.inputNames.slice(e,o).map((e=>Iu(e,n,a,r)));const i=Iu(t.inputNames.slice(e)[0],n,a,r),u=i.dataSync();return"number"===s.type?u[0]:re(i.shape,u)}const o=t.attrParams[e];return o&&o.value}function Iu(e,t,n,a){const[r,s]=Cu(e);if(null!=a){const e=a.getHashTableHandleByName(r);if(null!=e)return e}const o=n.currentContextIds.find((e=>!!t[$u(r,e)]));return void 0!==o?t[$u(r,o)][s]:void 0}function Nu(e,t){const[n,a]=Cu(e);return[$u(n,t&&t.currentContextId),a]}function $u(e,t){return t?`${e}-${t}`:e}function Cu(e){const t=e.split(":");return 1===t.length?[e,0]:[t[0],Number(t[t.length-1])]}function Tu(e,t,n){let a=wu("pad",e,t,n);if("explicit"===a){a=wu("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)r[e][0]=a[2*e],r[e][1]=a[2*e+1];return r}return a}function Eu(e){return e.kept?e:Ur(e)}const Su=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ru=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Au=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],Fu=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],_u=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Ou=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Du=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Mu=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Lu=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],Pu=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],Bu=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Vu=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Wu=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],zu=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Uu=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],Gu=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Hu=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];class ju{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[s,o,i,u,l,c,d,m,f,p,g,y,x,b,v,k,h].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const n=e.node,a=[],r=[],s=[],o=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e)),{});let i=[];const u=[];let l={},c={};null!=t&&(l=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach((e=>{const t=o[e];t.inputNames.forEach((e=>{const[n]=Nu(e);t.inputs.push(o[n]),o[n].children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{const t=o[e];0===t.children.length&&u.push(t)})):Object.keys(c).forEach((e=>{const[t]=Nu(e),n=o[t];null!=n&&(n.signatureKey=c[e],u.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((e=>{const[t]=Nu(e),n=o[t];n&&(n.signatureKey=l[e],i.push(n))})):i=a;let p={};null!=e.library&&null!=e.library.function&&(p=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const h={nodes:o,inputs:i,outputs:u,weights:r,placeholders:a,signature:t,functions:p};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=ku(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.substr(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const a=n.type;let r;switch(n.type){case"string":r=Xu(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Xu(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=rl(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=rl(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=Yu(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=Yu(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=al(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=al(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=qu(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=qu(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=ol(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=ol(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=nl(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=nl(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=sl(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=sl(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=Ju(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Ju(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=el(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=el(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=Zu(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=Zu(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let a={};null!=t&&(a=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const r=[],s=[];e.signature.inputArg.forEach((e=>{const[t]=Nu(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Qu(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,r.push(n),a[t]=n})),Object.keys(a).forEach((e=>{const t=a[e];t.inputNames.forEach((e=>{const[n]=Nu(e);t.inputs.push(a[n]),a[n].children.push(t)}))}));const o=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=Nu(o[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,s.push(r))}));const i=this.mapArgsToSignature(e);return{nodes:a,inputs:r,outputs:s,weights:n,placeholders:[],signature:i}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function Ku(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=he().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function Xu(e,t,n,a=!1){const r=e[t];return null!=r?Ku(r.s,a):n}function qu(e,t,n){const a=e[t];return a?a.b:n}function Yu(e,t,n){const a=e[t]||{},r=null!=a.i?a.i:null!=a.f?a.f:n;return"number"==typeof r?r:parseInt(r,10)}function Qu(e){switch("string"==typeof e&&(e=xu[e]),e){case xu.DT_FLOAT:return"float32";case xu.DT_INT32:case xu.DT_INT64:case xu.DT_INT8:case xu.DT_UINT8:return"int32";case xu.DT_BOOL:return"bool";case xu.DT_DOUBLE:return"float32";case xu.DT_STRING:return"string";default:return null}}function Zu(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function Ju(e,t,n){const a=e[t];return a&&a.type?Qu(a.type):n}function el(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map((e=>Qu(e))):n}function tl(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function nl(e,t,n){const a=e[t];return a&&a.shape?tl(a.shape):n}function al(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function rl(e,t,n,a=!1){const r=e[t];return r&&r.list&&r.list.s?r.list.s.map((e=>Ku(e,a))):n}function sl(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map((e=>tl(e))):n}function ol(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}class il{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Iu(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Iu(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Yu(this.node.rawAttrs,e,t);if(null!=n.s)return Xu(this.node.rawAttrs,e,t);if(null!=n.b)return qu(this.node.rawAttrs,e,t);if(null!=n.shape)return nl(this.node.rawAttrs,e,t);if(null!=n.type)return Ju(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return al(this.node.rawAttrs,e,t);if(null!=n.list.s)return rl(this.node.rawAttrs,e,t);if(null!=n.list.shape)return sl(this.node.rawAttrs,e,t);if(null!=n.list.b)return ol(this.node.rawAttrs,e,t);if(null!=n.list.type)return el(this.node.rawAttrs,e,t)}return t}}const ul=ir({addN_:function(e){O(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),O(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>sr(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!B(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const a=t;return Qa.runKernel(we,a)}}),ll=ir({mod_:function(e,t){let n=sr(e,"a","mod"),a=sr(t,"b","mod");[n,a]=Ga(n,a);const r={a:n,b:a};return Qa.runKernel(en,r)}}),cl=ir({equal_:function(e,t){let n=sr(e,"a","equal"),a=sr(t,"b","equal");[n,a]=Ga(n,a),go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(pt,r)}}),dl=ir({divNoNan_:function(e,t){let n=sr(e,"a","div"),a=sr(t,"b","div");[n,a]=Ga(n,a);const r=ks(n,a),s=Ps(r),o=cl(a,s);return wo(o,s,r)}}),pl=ir({maximum_:function(e,t){let n=sr(e,"a","maximum"),a=sr(t,"b","maximum");[n,a]=Ga(n,a),"bool"===n.dtype&&(n=zr(n,"int32"),a=zr(a,"int32")),go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(Gt,r)}}),hl=ir({acos_:function(e){const t={x:sr(e,"x","acos")};return Qa.runKernel(be,t)}}),fl=ir({acosh_:function(e){const t={x:sr(e,"x","acosh")};return Qa.runKernel(ve,t)}}),ml=ir({asin_:function(e){const t={x:sr(e,"x","asin")};return Qa.runKernel(Te,t)}}),gl=ir({asinh_:function(e){const t={x:sr(e,"x","asinh")};return Qa.runKernel(Ee,t)}}),yl=ir({atan_:function(e){const t={x:sr(e,"x","atan")};return Qa.runKernel(Se,t)}}),xl=ir({atan2_:function(e,t){let n=sr(e,"a","atan2"),a=sr(t,"b","atan2");[n,a]=Ga(n,a);const r={a:n,b:a};return Qa.runKernel(Ae,r)}}),bl=ir({atanh_:function(e){const t={x:sr(e,"x","atanh")};return Qa.runKernel(Re,t)}}),vl=ir({ceil_:function(e){const t={x:sr(e,"x","ceil")};return Qa.runKernel(Ve,t)}}),kl=ir({cos_:function(e){const t={x:sr(e,"x","cos")};return Qa.runKernel(Qe,t)}}),wl=ir({cosh_:function(e){const t={x:sr(e,"x","cosh")};return Qa.runKernel(Ze,t)}}),Il=ir({erf_:function(e){let t=sr(e,"x","erf");O("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=zr(t,"float32"));const n={x:t};return Qa.runKernel(dt,n)}}),Nl=ir({expm1_:function(e){const t={x:sr(e,"x","expm1")};return Qa.runKernel(mt,t)}}),$l=ir({floor_:function(e){const t={x:sr(e,"x","floor")};return Qa.runKernel(bt,t)}}),Cl=ir({reciprocal_:function(e){const t={x:sr(e,"x","reciprocal")};return Qa.runKernel(xn,t)}}),Tl=ir({round_:function(e){const t={x:sr(e,"x","round")};return Qa.runKernel(Tn,t)}}),El=ir({selu_:function(e){const t={x:sr(e,"x","selu")};return Qa.runKernel(An,t)}}),Sl=ir({sin_:function(e){const t={x:sr(e,"x","sin")};return Qa.runKernel(_n,t)}}),Rl=ir({sign_:function(e){const t={x:sr(e,"x","sign")};return Qa.runKernel(Dn,t)}}),Al=ir({sinh_:function(e){const t={x:sr(e,"x","sinh")};return Qa.runKernel(On,t)}}),Fl=ir({softplus_:function(e){const t={x:sr(e,"x","softplus")};return Qa.runKernel(Ln,t)}}),_l=ir({tanh_:function(e){const t={x:sr(e,"x","tanh")};return Qa.runKernel(qn,t)}}),Ol=ir({tan_:function(e){const t={x:sr(e,"x","tan")};return Qa.runKernel(Xn,t)}}),Dl=ir({clipByValue_:function(e,t,n){const a=sr(e,"x","clipByValue");O(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));const r={x:a},s={clipValueMin:t,clipValueMax:n};return Qa.runKernel(We,r,s)}}),Ml=ir({rsqrt_:function(e){const t={x:sr(e,"x","rsqrt")};return Qa.runKernel(En,t)}}),Ll=ir({prod_:function(e,t=null,n=!1){let a=sr(e,"x","prod");"bool"===a.dtype&&(a=zr(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return Qa.runKernel(mn,r,s)}});function Pl(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){O(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let a=0;a<e.length;a++){const r=e[a],s=t[a];O(r<0||s<0||r===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function Bl(e){return"number"!=typeof e&&!e.some((e=>e<0))}function Vl(e,t,n){let a=Wl(e,n);const r=!Bl(a);if(r&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(r&&t.forEach((e=>{a=Wl(e.shape,a)})),!Bl(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function Wl(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let a=0;a<e.length;++a){const r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[a]=r>=0?r:s}return n}class zl{constructor(e,t,n,a,r,s,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=$s(0),zo(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),Pl(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,zo(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return cr([],[0].concat(this.elementShape));const n=this.readMany(e);return Pl(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ss(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return cr([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return Pl(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),xs(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,_s(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const a=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const r=0===n?0:t.size/n,s=[];Wo((()=>{t=Ns(t,[1,n,r]);for(let n=0;n<e.length;++n){const o=[0,0===n?0:a[n-1],0],i=[1,e[n],r];s[n]=Ns(Ts(t,o,i),this.elementShape)}return s}));const o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,s)}}class Ul{constructor(e,t,n,a=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);Pl(t,e.shape,"TensorList shape mismatch: "),zo(e)})),this.idTensor=$s(0),this.maxNumElements=a,zo(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ul([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Pl(e,this.elementShape,"TensorList shape mismatch: ");const a=Vl(this.elementShape,this.tensors,e);return Wo((()=>{const e=this.tensors.map((e=>Ns(e,a)));return Ss(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=Vl(this.elementShape,this.tensors,e),a=this.tensors.pop();return Pl(a.shape,e,"TensorList shape mismatch: "),Ns(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Pl(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");zo(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);Pl(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=Vl(this.elementShape,this.tensors,t);return Ns(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Pl(this.elementShape,t.shape,"TensorList shape mismatch: "),zo(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Pl(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=Vl(this.elementShape,this.tensors,n);return 0===e.length?cr([],[0].concat(a)):Wo((()=>{const t=e.map((e=>Ns(this.tensors[e],a)));return Ss(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Pl(this.elementShape,t,"TensorList shape mismatch: ");const n=Vl(this.elementShape,this.tensors,t);return 0===this.size()?cr([],[0].concat(n)):Wo((()=>{const e=this.tensors.map((e=>Ns(e,n)));return xs(e,0)}))}}const Gl=ir({conv2d_:function(e,t,n,a,r="NHWC",s=[1,1],o){const i=sr(e,"x","conv2d"),u=sr(t,"filter","conv2d");let l=i,c=!1;3===i.rank&&(c=!0,l=Ns(i,[1,i.shape[0],i.shape[1],i.shape[2]])),O(4===l.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`)),O(4===u.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`)),null!=o&&O(V(a),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`));const d="NHWC"===r?l.shape[3]:l.shape[1];O(d===u.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`)),O(Ni(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));const p={x:l,filter:u},h={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},f=Qa.runKernel(He,p,h);return c?Ns(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Hl=ir({conv1d_:function(e,t,n,a,r="NWC",s=1,o){const i=sr(e,"x","conv1d"),u=sr(t,"filter","conv1d");let l=i,c=!1;2===i.rank&&(c=!0,l=Ns(i,[1,i.shape[0],i.shape[1]])),O(3===l.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`)),O(3===u.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`)),null!=o&&O(V(a),(()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`)),O(l.shape[2]===u.shape[1],(()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`)),O(Ni(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),O("NWC"===r,(()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`));const d=Ns(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=Ns(l,[l.shape[0],1,l.shape[1],l.shape[2]]),h=Gl(p,d,[1,n],a,"NHWC",[1,s],o);return Ns(h,c?[h.shape[2],h.shape[3]]:[h.shape[0],h.shape[2],h.shape[3]])}}),jl=ir({conv2DBackpropFilter_:function(e,t,n,a,r,s="NHWC",o){let i=e;3===e.rank&&(i=Ns(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Ns(t,[1,t.shape[0],t.shape[1],t.shape[2]])),O(4===i.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`)),O(4===u.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`)),O(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const l="NHWC"===s?i.shape[3]:i.shape[1],c="NHWC"===s?u.shape[3]:u.shape[1];O(l===n[2],(()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`)),O(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),null!=o&&O(V(r),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const d={x:i,dy:u},p={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:n};return Qa.runKernel(je,d,p)}}),Kl=ir({conv2DBackpropInput_:function(e,t,n,a,r,s="NHWC",o){O(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let i=e,u=t,l=!1;3===t.rank&&(l=!0,u=Ns(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),O(4===i.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`)),O(4===u.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`)),O(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===s?i[3]:i[1],d="NHWC"===s?u.shape[3]:u.shape[1];O(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),O(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),null!=o&&O(V(r),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const p={dy:u,filter:n},h={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:i},f=Qa.runKernel(Ke,p,h);return l?Ns(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Xl=ir({fusedConv2d_:function({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",!1===Oi(Qa.state.gradientDepth,u)){let d=Gl(e,t,n,a,r,s,o);return null!=i&&(d=ys(d,i)),_i(d,u,l,c)}const d=sr(e,"x","conv2d"),p=sr(t,"filter","conv2d");let h=d,f=!1;3===d.rank&&(f=!0,h=Ns(d,[1,d.shape[0],d.shape[1],d.shape[2]])),O(4===h.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`)),O(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),null!=o&&O(V(a),(()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`)),O(h.shape[3]===p.shape[2],(()=>`Error in conv2d: depth of input (${h.shape[3]}) must match input depth for filter ${p.shape[2]}.`)),O(Ni(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),O("NHWC"===r,(()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`));const m=gi(h.shape,p.shape,n,s,a,o);let g,y;null!=i&&(g=sr(i,"bias","fused conv2d"),[g]=Ga(g,d),go(m.outShape,g.shape)),null!=l&&(y=sr(l,"prelu weights","fused conv2d"));const x=(e,t)=>{const[r,o,i,l]=t,c=Ai(e,i,u);O(Ii(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));const d=[Kl(o.shape,c,r,n,a),jl(o,c,r.shape,n,a)];if(null!=l){const e=Fi(l,c);d.push(e)}return d},b={x:h,filter:p,bias:g,preluActivationWeights:y},v={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return null==i?ui(((e,t,n)=>{let a=Qa.runKernel(ua,b,v);return n([t,e,a]),f&&(a=Ns(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}))(h,p):ui(((e,t,n,a)=>{let r=Qa.runKernel(ua,b,v);return a([t,e,r,n]),f&&(r=Ns(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}))(h,p,g)}}),ql=ir({depthwiseConv2d_:function(e,t,n,a,r="NHWC",s=[1,1],o){const i=sr(e,"x","depthwiseConv2d"),u=sr(t,"filter","depthwiseConv2d");let l=i,c=!1;3===i.rank&&(c=!0,l=Ns(i,[1,i.shape[0],i.shape[1],i.shape[2]])),O(4===l.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`)),O(4===u.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`)),O(l.shape[3]===u.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),null!=o&&O(V(a),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`));const d={x:l,filter:u},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},h=Qa.runKernel(at,d,p);return c?Ns(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Yl=ir({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r,s=[1,1],o){let i=e;3===e.rank&&(i=Ns(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Ns(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:u},c={strides:a,pad:r,dimRoundingMode:o,dilations:s,filterShape:n};return Qa.runKernel(rt,l,c)}}),Ql=ir({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r,s=[1,1],o){let i=t,u=!1;3===t.rank&&(u=!0,i=Ns(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i,filter:n},c={strides:a,pad:r,dimRoundingMode:o,dilations:s,inputShape:e},d=Qa.runKernel(st,l,c);return u?Ns(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Zl=ir({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Oi(Qa.state.gradientDepth,u)){let d=ql(e,t,n,a,r,s,o);return null!=i&&(d=ys(d,i)),_i(d,u,l,c)}const d=sr(e,"x","depthwiseConv2d"),p=sr(t,"filter","depthwiseConv2d");let h=d,f=!1;3===d.rank&&(f=!0,h=Ns(d,[1,d.shape[0],d.shape[1],d.shape[2]])),O(4===h.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`)),O(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),O(h.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==s&&(s=[1,1]),O(Ni(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),null!=o&&O(V(a),(()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${a}.`));const m=gi(h.shape,p.shape,n,s,a,o,!0);let g,y;null!=i&&(g=sr(i,"bias","fused conv2d"),[g]=Ga(g,d),go(m.outShape,g.shape)),null!=l&&(y=sr(l,"prelu weights","fused depthwiseConv2d"));const x=(e,t)=>{O(Ii(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));const[r,i,l,c]=t,d=Ai(e,l,u),p=Ql(i.shape,d,r,n,a,s,o),h=Yl(i,d,r.shape,n,a,s,o);return null!=c?[p,h,Fi(g,d)]:[p,h]},b={x:h,filter:p,bias:g,preluActivationWeights:y},v={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return null==i?ui(((e,t,n)=>{let a=Qa.runKernel(la,b,v);return n([t,e,a]),f&&(a=Ns(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}))(h,p):ui(((e,t,n,a)=>{let r=Qa.runKernel(la,b,v);return a([t,e,r,n]),f&&(r=Ns(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}))(h,p,g)}}),Jl=ir({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:a=!1,bias:r,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:i}){if(!1===Oi(Qa.state.gradientDepth,s)){let u=Ko(e,t,n,a);return null!=r&&(u=ys(u,r)),_i(u,s,o,i)}let u=sr(e,"a","fused matMul"),l=sr(t,"b","fused matMul");[u,l]=Ga(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],d=a?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],h=a?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=P(f),y=P(m);O(u.rank>=2&&l.rank>=2&&u.rank===l.rank,(()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`)),O(B(f,m),(()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`)),O(c===d,(()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${a} must match.`));const x=u.shape.slice(0,-2).concat([p,h]),b=Ns(u,n?[g,c,p]:[g,p,c]),v=Ns(l,a?[y,h,d]:[y,d,h]);let k,w;null!=r&&(k=sr(r,"bias","fused matMul"),[k]=Ga(k,u),go(x,k.shape)),null!=o&&(w=sr(o,"prelu weights","fused matMul"));const I=(e,t)=>{const[o,i,u,l]=t,c=Ai(Ns(e,u.shape),u,s);let d,p;return n||a?!n&&a?(d=Ko(c,i,!1,!1),p=Ko(c,o,!0,!1)):n&&!a?(d=Ko(i,c,!1,!0),p=Ko(o,c,!1,!1)):(d=Ko(i,c,!0,!0),p=Ko(c,o,!0,!0)):(d=Ko(c,i,!1,!0),p=Ko(o,c,!0,!1)),null!=r?[d,p,Fi(l,c)]:[d,p]},N={a:b,b:v,bias:k,preluActivationWeights:w},$={transposeA:n,transposeB:a,activation:s,leakyreluAlpha:i};return null==r?ui(((e,t,n)=>{const a=Qa.runKernel(ia,N,$);return n([e,t,a]),{value:Ns(a,x),gradFunc:I}}))(b,v):ui(((e,t,n,a)=>{const r=Qa.runKernel(ia,N,$);return a([e,t,r,n]),{value:Ns(r,x),gradFunc:I}}))(b,v,k)}}),ec=ir({conv2dTranspose_:function(e,t,n,a,r,s){const o=sr(e,"x","conv2dTranspose"),i=sr(t,"filter","conv2dTranspose");return Kl(n,o,i,a,r,"NHWC",s)}}),tc=ir({conv3d_:function(e,t,n,a,r="NDHWC",s=[1,1,1]){const o=sr(e,"x","conv3d"),i=sr(t,"filter","conv3d");let u=o,l=!1;4===o.rank&&(l=!0,u=Ns(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),O(5===u.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`)),O(5===i.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`)),O(u.shape[4]===i.shape[3],(()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`)),O(Ni(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),O("NDHWC"===r,(()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`));const c={x:u,filter:i},d={strides:n,pad:a,dataFormat:r,dilations:s},p=Qa.runKernel(Xe,c,d);return l?Ns(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),nc=ir({avgPool_:function(e,t,n,a,r){const s=sr(e,"x","avgPool","float32");O(Ni(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let o=s,i=!1;3===s.rank&&(i=!0,o=Ns(s,[1,s.shape[0],s.shape[1],s.shape[2]])),O(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),null!=r&&O(V(a),(()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${a}.`));const u={x:o},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let c=Qa.runKernel(Fe,u,l);return c=zr(c,s.dtype),i?Ns(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),ac=ir({maxPool_:function(e,t,n,a,r){const s=sr(e,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=Ns(s,[1,s.shape[0],s.shape[1],s.shape[2]])),O(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),O(Ni(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),null!=r&&O(V(a),(()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${a}.`));const u={x:o},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},c=Qa.runKernel(Ht,u,l);return i?Ns(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),rc=ir({maxPoolWithArgmax_:function(e,t,n,a,r=!1){const s={x:sr(e,"x","maxPoolWithArgmax")},o={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},i=Qa.runKernel(qt,s,o);return{result:i[0],indexes:i[1]}}}),sc=ir({avgPool3d_:function(e,t,n,a,r,s="NDHWC"){const o=sr(e,"x","avgPool3d","float32");let i=o,u=!1;4===o.rank&&(u=!0,i=Ns(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),O(5===i.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`)),O("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),null!=r&&O(V(a),(()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${a}.`));const l={x:i},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s};let d=Qa.runKernel(Oe,l,c);return d=zr(d,i.dtype),u?Ns(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),oc=ir({maxPool3d_:function(e,t=[1,1,1],n,a,r,s="NDHWC"){const o=sr(e,"x","maxPool3d");let i=o,u=!1;4===o.rank&&(u=!0,i=Ns(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),O(5===i.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`)),O("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),null!=r&&O(V(a),(()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${a}.`));const l={x:i},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},d=Qa.runKernel(Kt,l,c);return u?Ns(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),ic=ir({dilation2d_:function(e,t,n,a,r=[1,1],s="NHWC"){const o=sr(e,"x","dilation2d"),i=sr(t,"filter","dilation2d");O(3===o.rank||4===o.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`)),O(3===i.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`)),O("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let u=o,l=!1;3===o.rank&&(u=Ns(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);const c={x:u,filter:i},d={strides:n,pad:a,dilations:r},p=Qa.runKernel(it,c,d);return l?Ns(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});function uc(e,t,n){const[a,r]=wu("fusedOps",e,t,n),s="biasadd"===a,o="prelu"===r,i="fusedbatchnorm"===a,u=wu("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(i)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const l=wu("strides",e,t,n),c=Tu(e,t,n),d=wu("dataFormat",e,t,n).toUpperCase(),p=wu("dilations",e,t,n),[h,f]=wu("args",e,t,n);return{stride:l,pad:c,dataFormat:d,dilations:p,biasArg:h,preluArg:f,activationFunc:r,leakyreluAlpha:wu("leakyreluAlpha",e,t,n)}}function lc(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return Qa.runKernel(Dt,{},a)}const cc=ir({multinomial_:function(e,t,n,a=!1){const r=sr(e,"logits","multinomial"),s=r.size,o=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const i={logits:1===o?Ns(r,[1,-1]):r},u={numSamples:t,seed:n,normalized:a},l=Qa.runKernel(tn,i,u);return 1===o?Ns(l,[l.size]):l}}),dc=ir({oneHot_:function(e,t,n=1,a=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const r={indices:sr(e,"indices","oneHot","int32")},s={depth:t,onValue:n,offValue:a};return Qa.runKernel(cn,r,s)}}),pc=ir({onesLike_:function(e){const t={x:sr(e,"x","onesLike")};return Qa.runKernel(ln,t)}});var hc=n(377);class fc{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=r||Math.random();this.random=hc.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,s;do{a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*o,t=this.mean+this.stdDev*r*o,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class mc{constructor(e=0,t=1,n,a){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"==typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=hc.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const gc=ir({randomUniform_:function(e,t=0,n=1,a="float32",r){const s=Wr(e,a),o=new mc(t,n,null,r);for(let e=0;e<s.values.length;e++)s.values[e]=o.nextValue();return s.toTensor()}}),yc=ir({truncatedNormal_:function(e,t=0,n=1,a,r){if(null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const s=new fc(t,n,a,!0,r),o=Wr(e,a);for(let e=0;e<o.values.length;e++)o.values[e]=s.nextValue();return o.toTensor()}}),xc=async function(e){const t=sr(e,"condition","whereAsync","bool"),n=await t.data(),a=yu(t.shape,n);return e!==t&&t.dispose(),a};function bc(e,t,n){return{boxes:wu("boxes",e,t,n),scores:wu("scores",e,t,n),maxOutputSize:wu("maxOutputSize",e,t,n),iouThreshold:wu("iouThreshold",e,t,n),scoreThreshold:wu("scoreThreshold",e,t,n),softNmsSigma:wu("softNmsSigma",e,t,n)}}const vc=ir({topk_:function(e,t=1,n=!0){const a=sr(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const s={x:a},o={k:t,sorted:n},[i,u]=Qa.runKernel(Qn,s,o);return{values:i,indices:u}}}),kc=ir({unique_:function(e,t=0){const n=sr(e,"x","unique","string_or_numeric");O(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[s,o]=Qa.runKernel(ea,a,r);return{values:s,indices:o}}});class wc{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=$s(0),this.tensorMap=new Map,zo(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return $s(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),Wo((()=>{const e=_s(t),a=n.length,r=e.length;O(a===r,(()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${r} elements.`));for(let t=0;t<a;t++){const a=n[t],r=e[t];zo(r),this.tensorMap.set(a,r)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Wo((()=>{const e=[];for(let a=0;a<n.length;a++){const r=n[a],s=this.findWithDefault(r,t);e.push(s)}return Ss(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const Ic=ir({less_:function(e,t){let n=sr(e,"a","less"),a=sr(t,"b","less");[n,a]=Ga(n,a),go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(_t,r)}}),Nc=ir({logicalNot_:function(e){const t={x:sr(e,"x","logicalNot","bool")};return Qa.runKernel(Bt,t)}}),$c=ir({logicalOr_:function(e,t){const n=sr(e,"a","logicalOr","bool"),a=sr(t,"b","logicalOr","bool");go(n.shape,a.shape);const r={a:n,b:a};return Qa.runKernel(Vt,r)}}),Cc=ir({batchNorm_:function(e,t,n,a,r,s){null==s&&(s=.001);const o=sr(e,"x","batchNorm"),i=sr(t,"mean","batchNorm"),u=sr(n,"variance","batchNorm");let l,c;null!=r&&(l=sr(r,"scale","batchNorm")),null!=a&&(c=sr(a,"offset","batchNorm")),O(i.rank===u.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),O(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),O(null==l||i.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:function(e){let t;return t=0===e.rank||1===e.rank?Ns(e,[1,1,1,e.size]):2===e.rank?Ns(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Ns(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(o),scale:l,offset:c,mean:i,variance:u},p={varianceEpsilon:s},h=Qa.runKernel(kt,d,p);return Ns(h,o.shape)}}),Tc=ir({localResponseNormalization_:function(e,t=5,n=1,a=1,r=.5){const s=sr(e,"x","localResponseNormalization");O(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),O(V(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let o=s,i=!1;3===s.rank&&(i=!0,o=Ns(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const u={x:o},l={depthRadius:t,bias:n,alpha:a,beta:r},c=Qa.runKernel(Wt,u,l);return i?Ns(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Ec=ir({softmax_:function(e,t=-1){const n=sr(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const a={logits:n},r={dim:t};return Qa.runKernel(zn,a,r)}}),Sc=ir({logSoftmax_:function(e,t=-1){const n=sr(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return ui(((e,n)=>{const a=Fo(e,t,!0),r=Rs(e,a),s=Rs(zr(r,"float32"),ri(Lo(oi(r),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{const[a]=n,r=oi(a);return Rs(e,Is(Lo(e,t,!0),r))}}}))(n)}}),Rc=ir({sparseToDense_:function(e,t,n,a=0){const r=sr(e,"sparseIndices","sparseToDense","int32"),s=sr(t,"sparseValues","sparseToDense"),o=sr(a,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,a){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const o=t.size;if(0!==t.rank&&(1!==t.rank||o!==r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,s,n,o);const i={sparseIndices:r,sparseValues:s,defaultValue:o},u={outputShape:n};return Qa.runKernel(jn,i,u)}}),Ac=ir({all_:function(e,t=null,n=!1){const a={x:sr(e,"x","all","bool")},r={axis:t,keepDims:n};return Qa.runKernel(Ie,a,r)}}),Fc=ir({any_:function(e,t=null,n=!1){const a={x:sr(e,"x","any","bool")},r={axis:t,keepDims:n};return Qa.runKernel(Ne,a,r)}}),_c=ir({argMax_:function(e,t=0){const n={x:sr(e,"x","argMax")},a={axis:t};return Qa.runKernel($e,n,a)}}),Oc=ir({argMin_:function(e,t=0){const n={x:sr(e,"x","argMin")},a={axis:t};return Qa.runKernel(Ce,n,a)}}),Dc=ir({cumsum_:function(e,t=0,n=!1,a=!1){const r={x:sr(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:a};return Qa.runKernel(Je,r,s)}}),Mc=ir({bincount_:function(e,t,n){const a=sr(e,"x","bincount"),r=sr(t,"weights","bincount");O("int32"===a.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${a.dtype}`)),O(n>=0,(()=>`size must be non-negative, but got ${n}.`)),O(r.size===a.size||0===r.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`));const s={x:a,weights:r},o={size:n};return Qa.runKernel(Pe,s,o)}}),Lc=ir({denseBincount_:function(e,t,n,a=!1){const r=sr(e,"x","denseBincount"),s=sr(t,"weights","denseBincount");O("int32"===r.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`)),O(r.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`)),O(n>=0,(()=>`size must be non-negative, but got ${n}.`)),O(s.size===r.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`));const o={x:r,weights:s},i={size:n,binaryOutput:a};return Qa.runKernel(tt,o,i)}}),Pc=ir({gather_:function(e,t,n=0,a=0){const r={x:sr(e,"x","gather"),indices:sr(t,"indices","gather","int32")},s={axis:n,batchDims:a};return Qa.runKernel(wt,r,s)}}),Bc=ir({stridedSlice_:function(e,t,n,a,r=0,s=0,o=0,i=0,u=0){const l={x:sr(e,"x","stridedSlice")},c={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return Qa.runKernel(Kn,l,c)}}),Vc=ir({scatterND_:function(e,t,n){const a=sr(e,"indices","scatterND","int32"),r=sr(t,"updates","scatterND");Hi(r,a,n);const s={indices:a,updates:r},o={shape:n};return Qa.runKernel(Sn,s,o)}}),Wc=ir({gatherND_:function(e,t){const n=sr(t,"indices","gatherND","int32"),a={params:sr(e,"x","gatherND"),indices:n};return Qa.runKernel(It,a)}}),zc=ir({mirrorPad_:function(e,t,n){O("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const a=sr(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");O(t.length===a.rank,(()=>`Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`));const r="reflect"===n?1:0;for(let e=0;e<a.rank;e++)O(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),O(t[e][0]>=0&&t[e][0]<=a.shape[e]-r&&t[e][1]>=0&&t[e][1]<=a.shape[e]-r,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${a.shape[e]-r} or less than 0 for input of shape ${a.shape}`));const s={paddings:t,mode:n},o={x:a};return Qa.runKernel(Jt,o,s)}}),Uc=ir({pad_:function(e,t,n=0){const a=sr(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},s={x:a};return Qa.runKernel(pn,s,r)}}),Gc=ir({spaceToBatchND_:function(e,t,n){const a=sr(e,"x","spaceToBatchND");O(a.rank>=1+t.length,(()=>`input rank ${a.rank} should be > than [blockShape] ${t.length}`)),O(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),O(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]==0:e),!0),(()=>`input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const r={x:a},s={blockShape:t,paddings:n};return Qa.runKernel(Vn,r,s)}}),Hc=ir({batchToSpaceND_:function(e,t,n){const a=sr(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));O(a.rank>=1+t.length,(()=>`input rank is ${a.rank} but should be > than blockShape.length ${t.length}`)),O(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),O(a.shape[0]%r==0,(()=>`input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`));const s={x:a},o={blockShape:t,crops:n};return Qa.runKernel(Le,s,o)}}),jc=ir({depthToSpace_:function(e,t,n="NHWC"){const a=sr(e,"x","depthToSpace"),r="NHWC"===n?a.shape[1]:a.shape[2],s="NHWC"===n?a.shape[2]:a.shape[3],o="NHWC"===n?a.shape[3]:a.shape[1];O(r*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${a.shape}`)),O(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${a.shape}`)),O(o%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${a.shape}`));const i={x:a},u={blockSize:t,dataFormat:n};return Qa.runKernel(nt,i,u)}});function Kc(e,t,n,a){const r=((e,t,n)=>{switch(e.category){case"arithmetic":return Wo((()=>((e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[ys(wu("a",e,t,n),wu("b",e,t,n))];case"AddN":return[ul(wu("tensors",e,t,n))];case"FloorMod":case"Mod":return[ll(wu("a",e,t,n),wu("b",e,t,n))];case"Mul":return[Is(wu("a",e,t,n),wu("b",e,t,n))];case"RealDiv":case"Div":return[ks(wu("a",e,t,n),wu("b",e,t,n))];case"DivNoNan":return[dl(wu("a",e,t,n),wu("b",e,t,n))];case"FloorDiv":return[vs(wu("a",e,t,n),wu("b",e,t,n))];case"Sub":return[Rs(wu("a",e,t,n),wu("b",e,t,n))];case"Minimum":return[ai(wu("a",e,t,n),wu("b",e,t,n))];case"Maximum":return[pl(wu("a",e,t,n),wu("b",e,t,n))];case"Pow":return[Oo(wu("a",e,t,n),wu("b",e,t,n))];case"SquaredDifference":return[si(wu("a",e,t,n),wu("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return Wo((()=>((e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[Io(wu("x",e,t,n))];case"Acos":return[hl(wu("x",e,t,n))];case"Acosh":return[fl(wu("x",e,t,n))];case"Asin":return[ml(wu("x",e,t,n))];case"Asinh":return[gl(wu("x",e,t,n))];case"Atan":return[yl(wu("x",e,t,n))];case"Atan2":return[xl(wu("x",e,t,n),wu("y",e,t,n))];case"Atanh":return[bl(wu("x",e,t,n))];case"Ceil":return[vl(wu("x",e,t,n))];case"Complex":return[ur(wu("real",e,t,n),wu("imag",e,t,n))];case"Cos":return[kl(wu("x",e,t,n))];case"Cosh":return[wl(wu("x",e,t,n))];case"Elu":return[Ci(wu("x",e,t,n))];case"Erf":return[Il(wu("x",e,t,n))];case"Exp":return[oi(wu("x",e,t,n))];case"Expm1":return[Nl(wu("x",e,t,n))];case"Floor":return[$l(wu("x",e,t,n))];case"Log":return[ri(wu("x",e,t,n))];case"Log1p":return[ii(wu("x",e,t,n))];case"Imag":return[Ds(wu("x",e,t,n))];case"Neg":return[Xo(wu("x",e,t,n))];case"Reciprocal":return[Cl(wu("x",e,t,n))];case"Real":return[Ms(wu("x",e,t,n))];case"Relu":return[ni(wu("x",e,t,n))];case"Round":return[Tl(wu("x",e,t,n))];case"Selu":return[El(wu("x",e,t,n))];case"Sigmoid":return[Cs(wu("x",e,t,n))];case"Sin":return[Sl(wu("x",e,t,n))];case"Sign":return[Rl(wu("x",e,t,n))];case"Sinh":return[Al(wu("x",e,t,n))];case"Softplus":return[Fl(wu("x",e,t,n))];case"Sqrt":return[Do(wu("x",e,t,n))];case"Square":return[Mo(wu("x",e,t,n))];case"Tanh":return[_l(wu("x",e,t,n))];case"Tan":return[Ol(wu("x",e,t,n))];case"ClipByValue":return[Dl(wu("x",e,t,n),wu("clipValueMin",e,t,n),wu("clipValueMax",e,t,n))];case"Relu6":return[Si(wu("x",e,t,n))];case"Rsqrt":return[Ml(Iu(e.inputNames[0],t,n))];case"Prod":return[Ll(wu("x",e,t,n),wu("axes",e,t,n))];case"LeakyRelu":return[Ti(wu("x",e,t,n),wu("alpha",e,t,n))];case"Prelu":return[Ei(wu("x",e,t,n),wu("alpha",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return(async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=wu("thenBranch",e,t,n),r=wu("elseBranch",e,t,n),s=wu("cond",e,t,n),o=wu("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=wu("body",e,t,n),r=wu("cond",e,t,n),s=wu("args",e,t,n),o=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),i=s.map((e=>e.id));let u=await o[0].data();o.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()}));let l=s;for(;u[0];){const e=l;l=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const s=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await s[0].data(),s.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return l}case"LoopCond":return[Eu(wu("pred",e,t,n))];case"Switch":{const a=wu("pred",e,t,n);let r=wu("data",e,t,n);return r.kept||(r=Eu(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const a=e.inputNames.find((e=>void 0!==Iu(e,t,n)));return a?[Eu(Iu(a,t,n))]:void 0}case"Enter":{const a=wu("frameName",e,t,n),r=wu("tensor",e,t,n);return n.enterFrame(a),[Eu(r)]}case"Exit":{const a=wu("tensor",e,t,n);return n.exitFrame(),[Eu(a)]}case"NextIteration":{const a=wu("tensor",e,t,n);return n.nextIteration(),[Eu(a)]}case"TensorArrayV3":{const a=wu("size",e,t,n),r=wu("dtype",e,t,n),s=wu("elementShape",e,t,n),o=wu("dynamicSize",e,t,n),i=wu("clearAfterRead",e,t,n),u=wu("identicalElementShapes",e,t,n),l=wu("name",e,t,n),c=new zl(l,r,a,s,u,o,i);return n.addTensorArray(c),[c.idTensor,$s(1)]}case"TensorArrayWriteV3":{const a=wu("tensorArrayId",e,t,n),r=wu("index",e,t,n),s=wu("tensor",e,t,n),o=n.getTensorArray(a.id);return o.write(r,s),[o.idTensor]}case"TensorArrayReadV3":{const a=wu("tensorArrayId",e,t,n),r=wu("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{const a=wu("tensorArrayId",e,t,n),r=wu("indices",e,t,n),s=wu("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{const a=wu("tensorArrayId",e,t,n),r=wu("indices",e,t,n),s=wu("tensor",e,t,n),o=n.getTensorArray(a.id);return o.scatter(r,s),[o.idTensor]}case"TensorArrayConcatV3":{const a=wu("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=wu("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{const a=wu("tensorArrayId",e,t,n),r=wu("tensor",e,t,n),s=wu("lengths",e,t,n),o=n.getTensorArray(a.id);return o.split(s,r),[o.idTensor]}case"TensorArraySizeV3":{const a=wu("tensorArrayId",e,t,n);return[$s(n.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{const a=wu("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const a=wu("tensorListId",e,t,n),r=wu("index",e,t,n),s=wu("tensor",e,t,n),o=n.getTensorList(a.id);return o.setItem(r,s),[o.idTensor]}case"TensorListGetItem":{const a=wu("tensorListId",e,t,n),r=wu("index",e,t,n),s=wu("elementShape",e,t,n),o=wu("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const a=wu("indices",e,t,n),r=function(e,t,n,a){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(null!=a&&-1!==a&&r>=a)throw new Error(`Max index must be < array size (${r}  vs. ${a})`);const s=new Ul([],n,e.dtype,a),o=_s(e,0);return t.forEach(((e,t)=>{s.setItem(e,o[t])})),s}(wu("tensor",e,t,n),a,wu("elementShape",e,t,n),wu("numElements",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=wu("elementShape",e,t,n),r=wu("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=function(e,t,n){return new Ul([],e,t,n)}(a,r,wu(s,e,t,n));return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const a=wu("tensorListId",e,t,n),r=wu("indices",e,t,n),s=wu("elementShape",e,t,n),o=wu("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,o,s)]}case"TensorListStack":{const a=wu("tensorListId",e,t,n),r=wu("elementShape",e,t,n),s=wu("elementDType",e,t,n),o=wu("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,o)]}case"TensorListFromTensor":{const a=function(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);Pl(e.shape.slice(1),t,"TensorList shape mismatch: ");const r=_s(e);return new Ul(r,t,a)}(wu("tensor",e,t,n),wu("elementShape",e,t,n),wu("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":{const a=wu("tensorListId",e,t,n),r=n.getTensorList(a.id),s=wu("dtype",e,t,n),o=wu("elementShape",e,t,n);return[r.concat(s,o)]}case"TensorListPushBack":{const a=wu("tensorListId",e,t,n),r=wu("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{const a=wu("tensorListId",e,t,n),r=wu("elementShape",e,t,n),s=wu("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{const a=wu("tensor",e,t,n),r=wu("elementShape",e,t,n),s=function(e,t,n){let a=0;const r=t.map((e=>(a+=e,a)));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${e.shape}`);const s=Wl(e.shape.slice(1),n),o=0===a?0:e.size/a,i=Wo((()=>{const n=[];e=Ns(e,[1,a,o]);for(let a=0;a<t.length;++a){const i=[0,0===a?0:r[a-1],0],u=[1,t[a],o];n[a]=Ns(Ts(e,i,u),s)}return e.dispose(),n})),u=new Ul([],n,e.dtype,t.length);for(let e=0;e<i.length;e++)u.setItem(e,i[e]);return u}(a,wu("lengths",e,t,n),r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"convolution":return Wo((()=>((e,t,n)=>{switch(e.op){case"Conv1D":{const a=wu("stride",e,t,n),r=wu("pad",e,t,n),s=wu("dataFormat",e,t,n).toUpperCase(),o=wu("dilation",e,t,n);return[Hl(wu("x",e,t,n),wu("filter",e,t,n),a,r,s,o)]}case"Conv2D":{const a=wu("strides",e,t,n),r=Tu(e,t,n),s=wu("dataFormat",e,t,n).toUpperCase(),o=wu("dilations",e,t,n);return[Gl(wu("x",e,t,n),wu("filter",e,t,n),[a[1],a[2]],r,s,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:a,pad:r,dataFormat:s,dilations:o,biasArg:i,preluArg:u,activationFunc:l,leakyreluAlpha:c}=uc(e,t,n);return[Xl({x:wu("x",e,t,n),filter:wu("filter",e,t,n),strides:[a[1],a[2]],pad:r,dataFormat:s,dilations:[o[1],o[2]],bias:i,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:r,dataFormat:s,dilations:o,biasArg:i,preluArg:u,activationFunc:l,leakyreluAlpha:c}=uc(e,t,n);return[Zl({x:wu("x",e,t,n),filter:wu("filter",e,t,n),strides:[a[1],a[2]],pad:r,dataFormat:s,dilations:[o[1],o[2]],bias:i,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=wu("outputShape",e,t,n),r=wu("strides",e,t,n),s=Tu(e,t,n);return[ec(wu("x",e,t,n),wu("filter",e,t,n),a,[r[1],r[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=wu("strides",e,t,n),r=Tu(e,t,n),s=wu("dilations",e,t,n),o=wu("dataFormat",e,t,n).toUpperCase();return[ql(wu("input",e,t,n),wu("filter",e,t,n),[a[1],a[2]],r,o,[s[1],s[2]])]}case"Conv3D":{const a=wu("strides",e,t,n),r=wu("pad",e,t,n),s=wu("dataFormat",e,t,n).toUpperCase(),o=wu("dilations",e,t,n);return[tc(wu("x",e,t,n),wu("filter",e,t,n),[a[1],a[2],a[3]],r,s,[o[1],o[2],o[3]])]}case"AvgPool":{const a=wu("strides",e,t,n),r=wu("pad",e,t,n),s=wu("kernelSize",e,t,n);return[nc(wu("x",e,t,n),[s[1],s[2]],[a[1],a[2]],r)]}case"MaxPool":{const a=wu("strides",e,t,n),r=wu("pad",e,t,n),s=wu("kernelSize",e,t,n);return[ac(wu("x",e,t,n),[s[1],s[2]],[a[1],a[2]],r)]}case"MaxPoolWithArgmax":{const a=wu("strides",e,t,n),r=wu("pad",e,t,n),s=wu("kernelSize",e,t,n),o=wu("includeBatchInIndex",e,t,n),{result:i,indexes:u}=rc(wu("x",e,t,n),[s[1],s[2]],[a[1],a[2]],r,o);return[i,u]}case"AvgPool3D":{const a=wu("strides",e,t,n),r=wu("pad",e,t,n),s=wu("kernelSize",e,t,n);return[sc(wu("x",e,t,n),[s[1],s[2],s[3]],[a[1],a[2],a[3]],r)]}case"MaxPool3D":{const a=wu("strides",e,t,n),r=wu("pad",e,t,n),s=wu("kernelSize",e,t,n);return[oc(wu("x",e,t,n),[s[1],s[2],s[3]],[a[1],a[2],a[3]],r)]}case"Dilation2D":{const a=wu("strides",e,t,n),r=wu("pad",e,t,n),s=wu("dilations",e,t,n),o=a[1],i=a[2],u=s[1],l=s[2];return[ic(wu("x",e,t,n),wu("filter",e,t,n),[o,i],r,[u,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return Wo((()=>((e,t,n)=>{switch(e.op){case"Fill":{const a=wu("shape",e,t,n),r=wu("dtype",e,t,n);return[js(a,wu("value",e,t,n),r)]}case"LinSpace":return[lc(wu("start",e,t,n),wu("stop",e,t,n),wu("num",e,t,n))];case"Multinomial":{const a=wu("logits",e,t,n),r=wu("numSamples",e,t,n),s=wu("seed",e,t,n);return[cc(a,r,s)]}case"OneHot":{const a=wu("indices",e,t,n),r=wu("depth",e,t,n),s=wu("onValue",e,t,n),o=wu("offValue",e,t,n);return[dc(a,r,s,o)]}case"Ones":return[ei(wu("shape",e,t,n),wu("dtype",e,t,n))];case"OnesLike":return[pc(wu("x",e,t,n))];case"RandomUniform":return[gc(wu("shape",e,t,n),wu("minval",e,t,n),wu("maxval",e,t,n),wu("dtype",e,t,n))];case"Range":return[vo(wu("start",e,t,n),wu("stop",e,t,n),wu("step",e,t,n),wu("dtype",e,t,n))];case"TruncatedNormal":{const a=wu("shape",e,t,n),r=wu("mean",e,t,n),s=wu("stdDev",e,t,n),o=wu("seed",e,t,n);return[yc(a,r,s,wu("dtype",e,t,n),o)]}case"Zeros":return[Os(wu("shape",e,t,n),wu("dtype",e,t,n))];case"ZerosLike":return[Ps(wu("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}=bc(e,t,n),l=await ci.nonMaxSuppressionWithScoreAsync(a,r,s,o,i,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:i}=bc(e,t,n),u=wu("padToMaxOutputSize",e,t,n),l=await ci.nonMaxSuppressionPaddedAsync(a,r,s,o,i,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:r,maxOutputSize:s,iouThreshold:o,scoreThreshold:i}=bc(e,t,n);return[await ci.nonMaxSuppressionAsync(a,r,s,o,i)]}case"Where":{const a=zr(wu("condition",e,t,n),"bool"),r=[await xc(a)];return a.dispose(),r}case"ListDiff":return async function(e,t){const n=sr(e,"x","setdiff1d"),a=sr(t,"y","setdiff1d");O(n.dtype===a.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`)),O(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),O(1===a.rank,(()=>`y should be 1D tensor, but got y (${a.shape}).`));const r=await n.data(),s=await a.data(),o=new Set(s);let i=0;for(let e=0;e<r.length;e++)o.has(r[e])||i++;const u=new Ra([i],n.dtype),l=new Ra([i],"int32");for(let e=0,t=0;e<r.length;e++)o.has(r[e])||(u.values[t]=r[e],l.values[t]=e,t++);return[u.toTensor(),l.toTensor()]}(wu("x",e,t,n),wu("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return Wo((()=>((e,t,n)=>{switch(e.op){case"TopKV2":{const a=wu("x",e,t,n),r=wu("k",e,t,n),s=wu("sorted",e,t,n),o=vc(a,r,s);return[o.values,o.indices]}case"Unique":{const a=wu("x",e,t,n),r=kc(a);return[r.values,r.indices]}case"UniqueV2":{const a=wu("x",e,t,n),r=wu("axis",e,t,n),s=kc(a,r);return[s.values,s.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return Wo((()=>((e,t,n)=>{switch(e.op){case"ResizeBilinear":{const a=wu("images",e,t,n),r=wu("size",e,t,n),s=wu("alignCorners",e,t,n),o=wu("halfPixelCenters",e,t,n);return[ci.resizeBilinear(a,[r[0],r[1]],s,o)]}case"ResizeNearestNeighbor":{const a=wu("images",e,t,n),r=wu("size",e,t,n),s=wu("alignCorners",e,t,n),o=wu("halfPixelCenters",e,t,n);return[ci.resizeNearestNeighbor(a,[r[0],r[1]],s,o)]}case"CropAndResize":{const a=wu("image",e,t,n),r=wu("boxes",e,t,n),s=wu("boxInd",e,t,n),o=wu("cropSize",e,t,n),i=wu("method",e,t,n),u=wu("extrapolationValue",e,t,n);return[ci.cropAndResize(a,r,s,o,i,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return Wo((()=>((e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const a=wu("default",e,t,n);return[Iu(e.name,t,n)||a];case"Placeholder":return[Iu(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[Eu(wu("x",e,t,n))];case"IdentityN":return wu("x",e,t,n).map((e=>Eu(e)));case"Snapshot":return[Eu(wu("x",e,t,n))];case"Shape":return[As(wu("x",e,t,n).shape,"int32")];case"ShapeN":return wu("x",e,t,n).map((e=>As(e.shape)));case"Size":return[$s(wu("x",e,t,n).size,"int32")];case"Rank":return[$s(wu("x",e,t,n).rank,"int32")];case"NoOp":return[$s(1)];case"Print":const r=wu("x",e,t,n),s=wu("data",e,t,n),o=wu("message",e,t,n),i=wu("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<s.length;e++)console.log(Array.prototype.slice.call(s[e].dataSync()).slice(0,i));return[r];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return Wo((()=>((e,t,n)=>{switch(e.op){case"Equal":return[cl(wu("a",e,t,n),wu("b",e,t,n))];case"NotEqual":return[Jo(wu("a",e,t,n),wu("b",e,t,n))];case"Greater":return[jo(wu("a",e,t,n),wu("b",e,t,n))];case"GreaterEqual":return[yo(wu("a",e,t,n),wu("b",e,t,n))];case"Less":return[Ic(wu("a",e,t,n),wu("b",e,t,n))];case"LessEqual":return[xo(wu("a",e,t,n),wu("b",e,t,n))];case"LogicalAnd":return[bo(wu("a",e,t,n),wu("b",e,t,n))];case"LogicalNot":return[Nc(wu("a",e,t,n))];case"LogicalOr":return[$c(wu("a",e,t,n),wu("b",e,t,n))];case"Select":case"SelectV2":return[wo(wu("condition",e,t,n),wu("a",e,t,n),wu("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return Wo((()=>((e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ko(wu("a",e,t,n),wu("b",e,t,n),wu("transposeA",e,t,n),wu("transposeB",e,t,n))];case"Transpose":return[qo(wu("x",e,t,n),wu("perm",e,t,n))];case"_FusedMatMul":const[a,r]=wu("fusedOps",e,t,n),s="biasadd"===a,o="prelu"===r,i=wu("numArgs",e,t,n),u=wu("leakyreluAlpha",e,t,n);if(s){if(o&&2!==i)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==i)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,c]=wu("args",e,t,n);return[Jl({a:wu("a",e,t,n),b:wu("b",e,t,n),transposeA:wu("transposeA",e,t,n),transposeB:wu("transposeB",e,t,n),bias:l,activation:r,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return Wo((()=>((e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Cc(wu("x",e,t,n),wu("mean",e,t,n),wu("variance",e,t,n),wu("offset",e,t,n),wu("scale",e,t,n),wu("epsilon",e,t,n))];case"LRN":return[Tc(wu("x",e,t,n),wu("radius",e,t,n),wu("bias",e,t,n),wu("alpha",e,t,n),wu("beta",e,t,n))];case"Softmax":return[Ec(wu("x",e,t,n))];case"LogSoftmax":return[Sc(wu("x",e,t,n))];case"SparseToDense":return[Rc(wu("sparseIndices",e,t,n),wu("outputShape",e,t,n),wu("sparseValues",e,t,n),wu("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return Wo((()=>((e,t,n)=>{switch(e.op){case"Max":{const a=wu("axis",e,t,n),r=wu("keepDims",e,t,n);return[Fo(wu("x",e,t,n),a,r)]}case"Mean":{const a=wu("axis",e,t,n),r=wu("keepDims",e,t,n);return[Zo(wu("x",e,t,n),a,r)]}case"Min":{const a=wu("axis",e,t,n),r=wu("keepDims",e,t,n);return[_o(wu("x",e,t,n),a,r)]}case"Sum":{const a=wu("axis",e,t,n),r=wu("keepDims",e,t,n);return[Lo(wu("x",e,t,n),a,r)]}case"All":{const a=wu("axis",e,t,n),r=wu("keepDims",e,t,n);return[Ac(wu("x",e,t,n),a,r)]}case"Any":{const a=wu("axis",e,t,n),r=wu("keepDims",e,t,n);return[Fc(wu("x",e,t,n),a,r)]}case"ArgMax":{const a=wu("axis",e,t,n);return[_c(wu("x",e,t,n),a)]}case"ArgMin":{const a=wu("axis",e,t,n);return[Oc(wu("x",e,t,n),a)]}case"Prod":{const a=wu("axis",e,t,n),r=wu("keepDims",e,t,n);return[Ll(wu("x",e,t,n),a,r)]}case"Cumsum":{const a=wu("axis",e,t,n),r=wu("exclusive",e,t,n),s=wu("reverse",e,t,n);return[Dc(wu("x",e,t,n),a,r,s)]}case"Bincount":const a=wu("x",e,t,n),r=wu("weights",e,t,n),s=wu("size",e,t,n);return[Mc(a,r,s)];case"DenseBincount":{const a=wu("x",e,t,n),r=wu("weights",e,t,n),s=wu("size",e,t,n),o=wu("binaryOutput",e,t,n);return[Lc(a,r,s,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return Wo((()=>((e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const a=wu("n",e,t,n),r=wu("axis",e,t,n);let s=wu("tensors",e,t,n);return s=s.slice(0,a),[xs(s,r)]}case"Gather":{const a=wu("x",e,t,n),r=wu("indices",e,t,n);return[Pc(a,zr(r,"int32"),0)]}case"GatherV2":{const a=wu("axis",e,t,n),r=wu("batchDims",e,t,n),s=wu("x",e,t,n),o=wu("indices",e,t,n);return[Pc(s,zr(o,"int32"),a,r)]}case"Reverse":{const a=wu("dims",e,t,n),r=[];for(let e=0;e<a.length;e++)a[e]&&r.push(e);const s=wu("x",e,t,n);return[zs(s,r)]}case"ReverseV2":{const a=wu("axis",e,t,n),r=wu("x",e,t,n);return[zs(r,a)]}case"Slice":{const a=wu("begin",e,t,n),r=wu("size",e,t,n);return[Ts(wu("x",e,t,n),a,r)]}case"StridedSlice":{const a=wu("begin",e,t,n),r=wu("end",e,t,n),s=wu("strides",e,t,n),o=wu("beginMask",e,t,n),i=wu("endMask",e,t,n),u=wu("ellipsisMask",e,t,n),l=wu("newAxisMask",e,t,n),c=wu("shrinkAxisMask",e,t,n),d=wu("x",e,t,n);return[Bc(d,a,r,s,o,i,u,l,c)]}case"Pack":return Wo((()=>{const a=wu("axis",e,t,n),r=wu("tensors",e,t,n),s=r[0].shape,o=Es(r[0]).shape,i=r.map((e=>{const t=B(e.shape,s);if(!t&&!B(Es(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:Ns(e,s)}));return[Ss(i,a)]}));case"Unpack":{const a=wu("axis",e,t,n),r=wu("tensor",e,t,n);return _s(r,a)}case"Tile":{const a=wu("reps",e,t,n);return[Go(wu("x",e,t,n),a)]}case"Split":case"SplitV":{const a=wu("axis",e,t,n),r=wu("numOrSizeSplits",e,t,n),s=wu("x",e,t,n);return Ls(s,r,a)}case"ScatterNd":{const a=wu("indices",e,t,n),r=wu("values",e,t,n),s=wu("shape",e,t,n);return[Vc(a,r,s)]}case"GatherNd":{const a=wu("x",e,t,n),r=wu("indices",e,t,n);return[Wc(a,r)]}case"SparseToDense":{const a=wu("sparseIndices",e,t,n),r=wu("outputShape",e,t,n),s=wu("sparseValues",e,t,n),o=wu("defaultValue",e,t,n);return[Rc(a,s,r,s.dtype===o.dtype?o:zr(o,s.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return Wo((()=>((e,t,n)=>{switch(e.op){case"FFT":return[Bs(wu("x",e,t,n))];case"IFFT":return[Ws(wu("x",e,t,n))];case"RFFT":return[Vs(wu("x",e,t,n))];case"IRFFT":return[Us(wu("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return Wo((()=>((e,t,n)=>{switch(e.op){case"Cast":return[zr(wu("x",e,t,n),wu("dtype",e,t,n))];case"ExpandDims":{const a=wu("axis",e,t,n);return[ws(wu("x",e,t,n),a)]}case"Squeeze":{const a=wu("axis",e,t,n);return[Es(wu("x",e,t,n),a)]}case"Reshape":return[Ns(wu("x",e,t,n),wu("shape",e,t,n))];case"MirrorPad":return[zc(wu("x",e,t,n),wu("padding",e,t,n),wu("mode",e,t,n))];case"PadV2":case"Pad":return[Uc(wu("x",e,t,n),wu("padding",e,t,n),wu("constantValue",e,t,n))];case"SpaceToBatchND":{const a=wu("blockShape",e,t,n),r=wu("paddings",e,t,n);return[Gc(wu("x",e,t,n),a,r)]}case"BatchToSpaceND":{const a=wu("blockShape",e,t,n),r=wu("crops",e,t,n);return[Hc(wu("x",e,t,n),a,r)]}case"DepthToSpace":{const a=wu("blockSize",e,t,n),r=wu("dataFormat",e,t,n).toUpperCase();return[jc(wu("x",e,t,n),a,r)]}case"BroadcastTo":return[ko(wu("x",e,t,n),wu("shape",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return(async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=wu("keyDType",e,t,n),s=wu("valueDType",e,t,n),o=new wc(r,s);return a.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=wu("tableHandle",e,t,n,a),s=wu("keys",e,t,n),o=wu("values",e,t,n),i=a.getHashTableById(r.id);return[await i.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=wu("tableHandle",e,t,n,a),s=wu("keys",e,t,n),o=wu("defaultValue",e,t,n),i=a.getHashTableById(r.id);return[await i.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=wu("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,a);case"custom":const r=ku(e.op);if(r&&r.customExecutor)return r.customExecutor(new il(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return de(r)?r.then((e=>[].concat(e))):[].concat(r)}class Xc{constructor(e={},t={},n={},a={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function qc(e,t,n,a){const r=new Set,s=[];let o=null,i=null;const u=new Set,l=Object.keys(e).map((e=>Cu(e)[0]));let c=[];null!=a&&(c=a.map((e=>Cu(e.name)[0])));const d=[...t];for(;d.length>0;){const e=d.pop();(Jc(e)||ed(e)||td(e))&&null==o&&(o=e,i=o.children.map((e=>e.name)).filter((e=>r.has(e)))),r.add(e.name),null==n[e.name]&&-1===l.indexOf(e.name)&&-1===c.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{u.has(e.name)||(u.add(e.name),d.push(e))})):s.push(e.name))}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:o,syncInputs:i}}const Yc=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Qc=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Zc=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Jc(e){return Yc.indexOf(e.op)>=0}function ed(e){return Qc.indexOf(e.op)>=0}function td(e){return Zc.indexOf(e.op)>=0}class nd{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new nd(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),a=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+a.join(this.SEPERATOR)}compile(e,t){const n=qc(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:r,syncInputs:s}=n;if(null!=r)throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(a.length>0){const n=t.map((e=>e.name)),r=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${r}]. Missing the following inputs: [${a}]`)}return function(e,t,n){const{usedNodes:a,inputs:r}=n,s=[],o=Object.keys(r).map((e=>Cu(e)[0])).map((t=>e.nodes[t])),i=e.initNodes;o.forEach((e=>{a.has(e.name)&&s.push(e)})),e.weights.forEach((e=>{a.has(e.name)&&s.push(e)})),null!=i&&i.forEach((e=>{a.has(e.name)&&s.push(e)}));const u=new Set,l=[];for(;s.length>0;){const e=s.pop();u.add(e.name),t[e.name]||l.push(e),e.children.forEach((e=>{!u.has(e.name)&&a.has(e.name)&&e.inputs.every((e=>u.has(e.name)))&&s.push(e)}))}return l}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=n.map((e=>this.graph.nodes[Cu(e)[0]])),r=t.map((e=>Cu(e)[0]));let s=r.map((e=>this.graph.nodes[e]));0===s.length&&(s=this._outputs);const o=this.getCompilationKey(a,s);let i=this.compiledMap.get(o);null==i&&(i=this.compile(e,s),this.compiledMap.set(o,i));const u={},l={};return Wo((()=>{const n=new Xc(this.weightMap,u,l,this.functionExecutorMap),a=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=Cu(t),s=[];s[r]=e[t],a[n]=s}));const s=this.getFrozenTensorIds(a),o={};for(let e=0;e<i.length;e++){const t=i[e];if(!a[t.name]){const e=Kc(t,a,n,this._resourceManager);if(de(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);a[t.name]=e,this.checkTensorForDisposal(t.name,t,a,n,s,r,o)}}return null==this.parent&&n.dispose(s),t.map((e=>Iu(e,a,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,a,r,s,o){"control"!==t.category&&-1===s.indexOf(e)&&(n[e].forEach((e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const t=function(e,t,n){return t[$u(e,n.currentContextId)]}(e.name,n,a);null!=t&&t.forEach((e=>{if(e&&!r.has(e.id)){const t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,n=!1,a={},r={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const s=new Xc(this.weightMap,a,r,this.functionExecutorMap),o=await this.executeWithControlFlow(e,s,t,n),i=t.map((e=>Iu(e,o,s))),u=i.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id)),c=new Set([...u,...l,...this.weightIds]);return Object.keys(o).forEach((e=>{o[e].forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&s.dispose(c),i}async executeFunctionAsync(e,t,n){const a=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){const r=Object.keys(e),s=r.map((e=>this.graph.nodes[Cu(e)[0]])),o=n.map((e=>Cu(e)[0]));let i=o.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const{usedNodes:u,missingInputs:l,dynamicNode:c,syncInputs:d}=qc(e,i,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),h=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,a]=Cu(t),r=[];r[a]=e[t],h[n]=r}));const f={},m=this.getFrozenTensorIds(h),g={};for(;p.length>0;){const e=this.processStack(s,p,t,h,g,m,o,f,u);await Promise.all(e)}null!=c||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=i.filter((e=>!Jc(e)&&!Iu(e.name,h,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${r}]. Consider providing the following inputs: [${l}]. ${e}`)}return h}processStack(e,t,n,a,r,s,o,i,u){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&wu("isConstant",e.node,a,n)&&([c]=Nu(e.node.name,n)),null==a[e.node.name]){const d=Kc(e.node,a,n,this._resourceManager);c||([c]=Nu(e.node.name,n));const p=n.currentContext;de(d)?l.push(d.then((l=>(a[c]=l,n.currentContext=p,this.checkTensorForDisposal(c,e.node,a,n,s,o,i),this.processChildNodes(e.node,t,n,a,r,u),l)))):(a[c]=d,this.checkTensorForDisposal(c,e.node,a,n,s,o,i),this.processChildNodes(e.node,t,n,a,r,u))}else this.processChildNodes(e.node,t,n,a,r,u)}return l}processChildNodes(e,t,n,a,r,s){e.children.forEach((e=>{const[o]=Nu(e.name,n);!r[o]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!Iu(e,a,n)))&&(r[o]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!Iu(e,a,n)))&&(r[o]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[a]=Cu(t),r=this.graph.nodes[a];if(r.attrParams.shape&&r.attrParams.shape.value){const e=r.attrParams.shape.value;O(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}r.attrParams.dtype&&r.attrParams.dtype.value&&O(n.dtype===r.attrParams.dtype.value,(()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){const t={};for(const n in e)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]?t[this._signature.inputs[n].name]=e[n]:t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=Cu(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e),{})}checkOutputs(e){e.forEach((e=>{const[t]=Cu(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class ad{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class rd{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new ad}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=Zr(e,this.loadOptions);else{const a=(t=e,n=this.loadOptions,yr.getLoadHandlers(t,n));if(0===a.length)a.push(Zr(e,this.loadOptions));else if(a.length>1)throw new Error(`Found more than one (${a.length}) load handlers for URL '${[e]}'`);this.handler=a[0]}var t,n}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const a=function(e,t){const n={};let a,r=0;for(const s of t){const t=s.name,o=s.dtype,i=s.shape,u=P(i);let l;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const i=dr[n.dtype],c=e.slice(r,r+u*i),d="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(d.length);for(let e=0;e<d.length;e++){const t=d[e];l[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===a&&(a=gr()),l=a(d)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${t}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);l=new Int32Array(d.length);for(let e=0;e<d.length;e++){const t=d[e];l[e]=Math.round(t*n.scale+n.min)}}r+=u*i}else if("string"===o){const t=P(s.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(r,r+4))[0];r+=4;const n=new Uint8Array(e.slice(r,r+t));l.push(n),r+=t}}else{const a=dr[o],s=e.slice(r,r+u*a);if("float32"===o)l=new Float32Array(s);else if("int32"===o)l=new Int32Array(s);else if("bool"===o)l=new Uint8Array(s);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${t}': ${o}`);{l=new Float32Array(s);const e=new Float32Array(l.length/2),a=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],a[t]=l[2*t+1];const r=cr(e,i,"float32"),o=cr(a,i,"float32");n[t]=ur(r,o),r.dispose(),o.dispose()}}r+=u*a}"complex64"!==o&&(n[t]=cr(l,i,o))}return n}(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new nd(ju.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=ju.Instance.transformGraph(e.modelInitializer);this.initializer=new nd(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=(n=e,yr.getSaveHandlers(n));if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}var n;if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Oa||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,n,a)=>(t[n]=e[a],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function sd(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}model.json?tfjs-format=file`);const n=new rd(e,t);return await n.load(),n}var od=function(){return(od=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)};function id(e,t,n,a){return new(n||(n=Promise))((function(r,s){function o(e){try{u(a.next(e))}catch(e){s(e)}}function i(e){try{u(a.throw(e))}catch(e){s(e)}}function u(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,i)}u((a=a.apply(e,t||[])).next())}))}function ud(e,t){var n,a,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,a&&(r=2&s[0]?a.return:s[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,s[1])).done)return r;switch(a=0,r&&(s=[2&s[0],r.value]),s[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,a=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!((r=(r=o.trys).length>0&&r[r.length-1])||6!==s[0]&&2!==s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],a=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}function ld(e,t,n,a){return new(n||(n=Promise))((function(r,s){function o(e){try{u(a.next(e))}catch(e){s(e)}}function i(e){try{u(a.throw(e))}catch(e){s(e)}}function u(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,i)}u((a=a.apply(e,t||[])).next())}))}function cd(e,t){var n,a,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,a&&(r=2&s[0]?a.return:s[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,s[1])).done)return r;switch(a=0,r&&(s=[2&s[0],r.value]),s[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,a=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=(r=o.trys).length>0&&r[r.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],a=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}var dd=function(e){return{startEndTensor:e,startPoint:Ts(e,[0,0],[-1,2]),endPoint:Ts(e,[0,2],[-1,2])}},pd={strides:[8,16],anchors:[2,6]};function hd(e,t){var n,a,r;if(e.topLeft instanceof Oa&&e.bottomRight instanceof Oa){var s=Wo((function(){return[xs([Ts(Rs(t-1,e.topLeft),0,1),Ts(e.topLeft,1,1)]),xs([Rs(t-1,Ts(e.bottomRight,0,1)),Ts(e.bottomRight,1,1)])]}));n=s[0],a=s[1],null!=e.landmarks&&(r=Wo((function(){var n=Rs(As([t-1,0]),e.landmarks),a=As([1,-1]);return Is(n,a)})))}else{var o=e.topLeft,i=o[0],u=o[1],l=e.bottomRight,c=l[0],d=l[1];n=[t-1-i,u],a=[t-1-c,d],null!=e.landmarks&&(r=e.landmarks.map((function(e){return[t-1-e[0],e[1]]})))}var p={topLeft:n,bottomRight:a};return null!=r&&(p.landmarks=r),null!=e.probability&&(p.probability=e.probability instanceof Oa?e.probability.clone():e.probability),p}function fd(e,t){return Wo((function(){var n;return n=e.hasOwnProperty("box")?e.box:e,Es(function(e,t){var n=Is(e.startPoint,t),a=Is(e.endPoint,t),r=bs([n,a],1);return dd(r)}(n,t).startEndTensor)}))}var md=function(){function e(e,t,n,a,r,s){this.blazeFaceModel=e,this.width=t,this.height=n,this.maxFaces=a,this.anchorsData=function(e,t,n){for(var a=[],r=0;r<n.strides.length;r++)for(var s=n.strides[r],o=Math.floor((t+s-1)/s),i=Math.floor((e+s-1)/s),u=n.anchors[r],l=0;l<o;l++)for(var c=s*(l+.5),d=0;d<i;d++)for(var p=s*(d+.5),h=0;h<u;h++)a.push([p,c]);return a}(t,n,pd),this.anchors=Fs(this.anchorsData),this.inputSizeData=[t,n],this.inputSize=As([t,n]),this.iouThreshold=r,this.scoreThreshold=s}return e.prototype.getBoundingBoxes=function(e,t,n){return void 0===n&&(n=!0),ld(this,void 0,void 0,(function(){var a,r,s,o,i,u,l,c,d,p,h,f,m,g,y=this;return cd(this,(function(x){switch(x.label){case 0:return a=Wo((function(){var t=ci.resizeBilinear(e,[y.width,y.height]),n=Is(Rs(ks(t,255),.5),2),a=y.blazeFaceModel.predict(n),r=Es(a),s=function(e,t,n){var a=Ts(e,[0,1],[-1,2]),r=ys(a,t),s=Ts(e,[0,3],[-1,2]),o=ks(s,n),i=ks(r,n),u=ks(o,2),l=Rs(i,u),c=ys(i,u),d=Is(l,n),p=Is(c,n);return bs([d,p],1)}(r,y.anchors,y.inputSize),o=Ts(r,[0,0],[-1,1]);return[r,s,Es(Cs(o))]})),r=a[0],s=a[1],o=a[2],i=console.warn,console.warn=function(){},u=ci.nonMaxSuppression(s,o,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=i,[4,u.array()];case 1:return l=x.sent(),u.dispose(),c=l.map((function(e){return Ts(s,[e,0],[1,-1])})),t?[3,3]:[4,Promise.all(c.map((function(e){return ld(y,void 0,void 0,(function(){var t;return cd(this,(function(n){switch(n.label){case 0:return[4,e.array()];case 1:return t=n.sent(),e.dispose(),[2,t]}}))}))})))];case 2:c=x.sent(),x.label=3;case 3:for(d=e.shape[1],p=e.shape[2],h=t?ks([p,d],this.inputSize):[p/this.inputSizeData[0],d/this.inputSizeData[1]],f=[],m=function(e){var a=c[e],s=Wo((function(){var s=dd(a instanceof Oa?a:Fs(a));if(!n)return s;var i,u=l[e];return i=t?Ts(y.anchors,[u,0],[1,2]):y.anchorsData[u],{box:s,landmarks:Ns(Es(Ts(r,[u,5],[1,-1])),[6,-1]),probability:Ts(o,[u],[1]),anchor:i}}));f.push(s)},g=0;g<c.length;g++)m(g);return s.dispose(),o.dispose(),r.dispose(),[2,{boxes:f,scaleFactor:h}]}}))}))},e.prototype.estimateFaces=function(e,t,n,a){return void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===a&&(a=!0),ld(this,void 0,void 0,(function(){var r,s,o,i,u,l,c=this;return cd(this,(function(d){switch(d.label){case 0:return r=function(e){return e instanceof Oa?[e.shape[0],e.shape[1]]:[e.height,e.width]}(e),s=r[1],o=Wo((function(){return e instanceof Oa||(e=es(e)),ws(zr(e,"float32"),0)})),[4,this.getBoundingBoxes(o,t,a)];case 1:return i=d.sent(),u=i.boxes,l=i.scaleFactor,o.dispose(),t?[2,u.map((function(e){var t=fd(e,l),r={topLeft:Ts(t,[0],[2]),bottomRight:Ts(t,[2],[2])};if(a){var o=e,i=o.landmarks,u=o.probability,c=o.anchor,d=Is(ys(i,c),l);r.landmarks=d,r.probability=u}return n&&(r=hd(r,s)),r}))]:[2,Promise.all(u.map((function(e){return ld(c,void 0,void 0,(function(){var t,r,o,i,u,c,d,p,h,f,m,g=this;return cd(this,(function(y){switch(y.label){case 0:return t=fd(e,l),a?[3,2]:[4,t.array()];case 1:return u=y.sent(),r={topLeft:u.slice(0,2),bottomRight:u.slice(2)},[3,4];case 2:return[4,Promise.all([e.landmarks,t,e.probability].map((function(e){return ld(g,void 0,void 0,(function(){return cd(this,(function(t){return[2,e.array()]}))}))})))];case 3:o=y.sent(),i=o[0],u=o[1],c=o[2],d=e.anchor,h=(p=l)[0],f=p[1],m=i.map((function(e){return[(e[0]+d[0])*h,(e[1]+d[1])*f]})),r={topLeft:u.slice(0,2),bottomRight:u.slice(2),landmarks:m,probability:c},function(e){e.startEndTensor.dispose(),e.startPoint.dispose(),e.endPoint.dispose()}(e.box),e.landmarks.dispose(),e.probability.dispose(),y.label=4;case 4:return t.dispose(),n&&(r=hd(r,s)),[2,r]}}))}))})))]}}))}))},e}();function gd(e){var t=void 0===e?{}:e,n=t.maxFaces,a=void 0===n?10:n,r=t.inputWidth,s=void 0===r?128:r,o=t.inputHeight,i=void 0===o?128:o,u=t.iouThreshold,l=void 0===u?.3:u,c=t.scoreThreshold,d=void 0===c?.75:c,p=t.modelUrl;return ld(this,void 0,void 0,(function(){var e;return cd(this,(function(t){switch(t.label){case 0:return null==p?[3,2]:[4,sd(p)];case 1:return e=t.sent(),[3,4];case 2:return[4,sd("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0})];case 3:e=t.sent(),t.label=4;case 4:return[2,new md(e,s,i,a,l,d)]}}))}))}var yd={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],leftEyeIris:[468,469,470,471,472],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]};function xd(e){return[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])]}function bd(e){return[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2]}function vd(e,t){void 0===t&&(t=1.5);var n=bd(e),a=xd(e),r=[t*a[0]/2,t*a[1]/2];return{startPoint:[n[0]-r[0],n[1]-r[1]],endPoint:[n[0]+r[0],n[1]+r[1]],landmarks:e.landmarks}}function kd(e){var t=bd(e),n=xd(e),a=Math.max.apply(Math,n)/2;return{startPoint:[t[0]-a,t[1]-a],endPoint:[t[0]+a,t[1]+a],landmarks:e.landmarks}}var wd=[[1,0,0],[0,1,0],[0,0,1]];function Id(e,t){return[[1,0,e],[0,1,t],[0,0,1]]}function Nd(e,t){for(var n=0,a=0;a<e.length;a++)n+=e[a]*t[a];return n}function $d(e,t){for(var n=[],a=0;a<e.length;a++)n.push(e[a][t]);return n}function Cd(e,t){for(var n=[],a=e.length,r=0;r<a;r++){n.push([]);for(var s=0;s<a;s++)n[r].push(Nd(e[r],$d(t,s)))}return n}function Td(e,t){var n=Math.cos(e),a=Math.sin(e),r=[[n,-a,0],[a,n,0],[0,0,1]],s=Cd(Id(t[0],t[1]),r);return Cd(s,Id(-t[0],-t[1]))}var Ed=[13,yd.midwayBetweenEyes[0]],Sd=[3,2],Rd=yd.leftEyeLower0,Ad=[Rd[0],Rd[Rd.length-1]],Fd=yd.rightEyeLower0,_d=[Fd[0],Fd[Fd.length-1]],Od=[{key:"EyeUpper0",indices:[9,10,11,12,13,14,15]},{key:"EyeUpper1",indices:[25,26,27,28,29,30,31]},{key:"EyeUpper2",indices:[41,42,43,44,45,46,47]},{key:"EyeLower0",indices:[0,1,2,3,4,5,6,7,8]},{key:"EyeLower1",indices:[16,17,18,19,20,21,22,23,24]},{key:"EyeLower2",indices:[32,33,34,35,36,37,38,39,40]},{key:"EyeLower3",indices:[54,55,56,57,58,59,60,61,62]},{key:"EyebrowUpper",indices:[63,64,65,66,67,68,69,70]},{key:"EyebrowLower",indices:[48,49,50,51,52,53]}];function Dd(e,t,n,a){for(var r=0;r<Od.length;r++){var s=Od[r],o=s.key,i=s.indices,u=yd[""+n+o];if(null==a||a.includes(o))for(var l=0;l<i.length;l++){var c=i[l];e[u[l]]=[t[c][0],t[c][1],(t[c][2]+e[u[l]][2])/2]}}}var Md=function(){function e(e,t,n,a,r,s,o){this.regionsOfInterest=[],this.runsWithoutFaceDetector=0,this.boundingBoxDetector=e,this.meshDetector=t,this.irisModel=o,this.meshWidth=n,this.meshHeight=a,this.maxContinuousChecks=r,this.maxFaces=s}return e.prototype.transformRawCoords=function(e,t,n,a){var r,s,o,i,u=this,l=xd({startPoint:t.startPoint,endPoint:t.endPoint}),c=[l[0]/this.meshWidth,l[1]/this.meshHeight],d=e.map((function(e){return[c[0]*(e[0]-u.meshWidth/2),c[1]*(e[1]-u.meshHeight/2),e[2]]})),p=Td(n,[0,0]),h=d.map((function(e){return function(e,t){return[Nd(e,t[0]),Nd(e,t[1])]}(e,p).concat([e[2]])})),f=(s=[[(r=a)[0][0],r[1][0]],[r[0][1],r[1][1]]],o=[r[0][2],r[1][2]],i=[-Nd(s[0],o),-Nd(s[1],o)],[s[0].concat(i[0]),s[1].concat(i[1]),[0,0,1]]),m=bd({startPoint:t.startPoint,endPoint:t.endPoint}).concat([1]),g=[Nd(m,f[0]),Nd(m,f[1])];return h.map((function(e){return[e[0]+g[0],e[1]+g[1],e[2]]}))},e.prototype.getLeftToRightEyeDepthDifference=function(e){return e[Ad[0]][2]-e[_d[0]][2]},e.prototype.getEyeBox=function(e,t,n,a,r){void 0===r&&(r=!1);var s=kd(vd(this.calculateLandmarksBoundingBox([e[n],e[a]]),2.3)),o=xd(s),i=ci.cropAndResize(t,[[s.startPoint[1]/this.meshHeight,s.startPoint[0]/this.meshWidth,s.endPoint[1]/this.meshHeight,s.endPoint[0]/this.meshWidth]],[0],[64,64]);return r&&(i=ci.flipLeftRight(i)),{box:s,boxSize:o,crop:i}},e.prototype.getEyeCoords=function(e,t,n,a){void 0===a&&(a=!1);for(var r=[],s=0;s<76;s++){var o=e[3*s],i=e[3*s+1],u=e[3*s+2];r.push([(a?1-o/64:o/64)*n[0]+t.startPoint[0],i/64*n[1]+t.startPoint[1],u])}return{rawCoords:r,iris:r.slice(71)}},e.prototype.getAdjustedIrisCoords=function(e,t,n){var a=e[yd[n+"EyeUpper0"][3]][2],r=e[yd[n+"EyeLower0"][4]][2],s=(a+r)/2;return t.map((function(e,t){var n=s;return 2===t?n=a:4===t&&(n=r),[e[0],e[1],n]}))},e.prototype.predict=function(e,t){return id(this,void 0,void 0,(function(){var n,a,r,s,o=this;return ud(this,(function(i){switch(i.label){case 0:return this.shouldUpdateRegionsOfInterest()?[4,this.boundingBoxDetector.getBoundingBoxes(e,!1,!0)]:[3,2];case 1:return n=i.sent(),a=n.boxes,r=n.scaleFactor,0===a.length?(this.regionsOfInterest=[],[2,null]):(s=a.map((function(e){var t,n,a={startPoint:Es(e.box.startPoint).arraySync(),endPoint:Es(e.box.endPoint).arraySync()},s=kd(vd((n=r,{startPoint:[(t=a).startPoint[0]*n[0],t.startPoint[1]*n[1]],endPoint:[t.endPoint[0]*n[0],t.endPoint[1]*n[1]]})));return od({},s,{landmarks:e.landmarks.arraySync()})})),a.forEach((function(e){null!=e&&null!=e.startPoint&&(e.startEndTensor.dispose(),e.startPoint.dispose(),e.endPoint.dispose())})),this.updateRegionsOfInterest(s),this.runsWithoutFaceDetector=0,[3,3]);case 2:this.runsWithoutFaceDetector++,i.label=3;case 3:return[2,Wo((function(){return o.regionsOfInterest.map((function(n,a){var r,s=n.landmarks.length>=468,i=Ed[0],u=Ed[1];!1===s&&(i=Sd[0],u=Sd[1]),r=function(e,t){var n;return(n=Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]))-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}(n.landmarks[i],n.landmarks[u]);var l=bd({startPoint:n.startPoint,endPoint:n.endPoint}),c=[l[0]/e.shape[2],l[1]/e.shape[1]],d=e,p=wd;0!==r&&(d=ci.rotateWithOffset(e,r,0,c),p=Td(-r,l));var h={startPoint:n.startPoint,endPoint:n.endPoint},f=ks(function(e,t,n){var a=t.shape[1],r=t.shape[2],s=[[e.startPoint[1]/a,e.startPoint[0]/r,e.endPoint[1]/a,e.endPoint[0]/r]];return ci.cropAndResize(t,s,[0],n,"bilinear",0)}(h,d,[o.meshHeight,o.meshWidth]),255),m=o.meshDetector.predict(f),g=m[1],y=m[2],x=Ns(y,[-1,3]).arraySync();if(t){var b=o.getEyeBox(x,f,Ad[0],Ad[1],!0),v=b.box,k=b.boxSize,w=b.crop,I=o.getEyeBox(x,f,_d[0],_d[1]),N=I.box,$=I.boxSize,C=I.crop,T=o.irisModel.predict(xs([w,C])).dataSync(),E=T.slice(0,228),S=o.getEyeCoords(E,v,k,!0),R=S.rawCoords,A=S.iris,F=T.slice(228),_=o.getEyeCoords(F,N,$),O=_.rawCoords,D=_.iris,M=o.getLeftToRightEyeDepthDifference(x);Math.abs(M)<30?(Dd(x,R,"left"),Dd(x,O,"right")):M<1?Dd(x,R,"left",["EyeUpper0","EyeLower0"]):Dd(x,O,"right",["EyeUpper0","EyeLower0"]);var L=o.getAdjustedIrisCoords(x,A,"left"),P=o.getAdjustedIrisCoords(x,D,"right");x=x.concat(L).concat(P)}var B=o.transformRawCoords(x,n,r,p),V=Fs(B),W=vd(o.calculateLandmarksBoundingBox(B)),z=kd(W);return o.regionsOfInterest[a]=od({},z,{landmarks:V.arraySync()}),{coords:Fs(x,[x.length,3]),scaledCoords:V,box:W,flag:Es(g)}}))}))]}}))}))},e.prototype.updateRegionsOfInterest=function(e){for(var t=0;t<e.length;t++){var n=e[t],a=this.regionsOfInterest[t],r=0;if(a&&a.startPoint){var s=n.startPoint,o=s[0],i=s[1],u=n.endPoint,l=u[0],c=u[1],d=a.startPoint,p=d[0],h=d[1],f=a.endPoint,m=f[0],g=f[1],y=Math.max(o,p),x=Math.max(i,h),b=(Math.min(l,m)-y)*(Math.min(c,g)-x);r=b/((l-o)*(c-i)+(m-p)*(g-i)-b)}r<.25&&(this.regionsOfInterest[t]=n)}this.regionsOfInterest=this.regionsOfInterest.slice(0,e.length)},e.prototype.clearRegionOfInterest=function(e){null!=this.regionsOfInterest[e]&&(this.regionsOfInterest=this.regionsOfInterest.slice(0,e).concat(this.regionsOfInterest.slice(e+1)))},e.prototype.shouldUpdateRegionsOfInterest=function(){var e=this.regionsOfInterest.length,t=0===e;return 1===this.maxFaces||t?t:e!==this.maxFaces&&this.runsWithoutFaceDetector>=this.maxContinuousChecks},e.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map((function(e){return e[0]})),n=e.map((function(e){return e[1]}));return{startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,n)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,n)]}},e}(),Ld=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]];function Pd(e){return id(this,void 0,void 0,(function(){var t,n,a,r,s,o,i,u,l,c,d,p,h,f,m,g;return ud(this,(function(y){switch(y.label){case 0:return t=e.maxContinuousChecks,n=void 0===t?5:t,a=e.detectionConfidence,r=void 0===a?.9:a,s=e.maxFaces,o=void 0===s?10:s,i=e.iouThreshold,u=void 0===i?.3:i,l=e.scoreThreshold,c=void 0===l?.75:l,d=e.shouldLoadIrisModel,p=void 0===d||d,h=e.modelUrl,f=e.detectorModelUrl,m=e.irisModelUrl,p?[4,Promise.all([Bd(f,o,u,c),Vd(h),Wd(m)])]:[3,2];case 1:return g=y.sent(),[3,4];case 2:return[4,Promise.all([Bd(f,o,u,c),Vd(h)])];case 3:g=y.sent(),y.label=4;case 4:return[2,new Gd(g[0],g[1],n,r,o,p?g[2]:null)]}}))}))}function Bd(e,t,n,a){return id(this,void 0,void 0,(function(){return ud(this,(function(r){return[2,gd({modelUrl:e,maxFaces:t,iouThreshold:n,scoreThreshold:a})]}))}))}function Vd(e){return id(this,void 0,void 0,(function(){return ud(this,(function(t){return null!=e?[2,sd(e)]:[2,sd("https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",{fromTFHub:!0})]}))}))}function Wd(e){return id(this,void 0,void 0,(function(){return ud(this,(function(t){return null!=e?[2,sd(e)]:[2,sd("https://tfhub.dev/mediapipe/tfjs-model/iris/1/default/2",{fromTFHub:!0})]}))}))}function zd(e,t){if(e.mesh instanceof Oa){var n=Wo((function(){var n=As([t-1,0,0]),a=As([1,-1,1]);return Wo((function(){return[xs([Rs(t-1,Ts(e.boundingBox.topLeft,0,1)),Ts(e.boundingBox.topLeft,1,1)]),xs([Rs(t-1,Ts(e.boundingBox.bottomRight,0,1)),Ts(e.boundingBox.bottomRight,1,1)]),Is(Rs(n,e.mesh),a),Is(Rs(n,e.scaledMesh),a)]}))})),a=n[0],r=n[1],s=n[2],o=n[3];return Object.assign({},e,{boundingBox:{topLeft:a,bottomRight:r},mesh:s,scaledMesh:o})}return Object.assign({},e,{boundingBox:{topLeft:[t-1-e.boundingBox.topLeft[0],e.boundingBox.topLeft[1]],bottomRight:[t-1-e.boundingBox.bottomRight[0],e.boundingBox.bottomRight[1]]},mesh:e.mesh.map((function(e){var n=e.slice(0);return n[0]=t-1-e[0],n})),scaledMesh:e.scaledMesh.map((function(e){var n=e.slice(0);return n[0]=t-1-e[0],n}))})}var Ud,Gd=function(){function e(e,t,n,a,r,s){this.kind="MediaPipeFaceMesh",this.pipeline=new Md(e,t,192,192,n,r,s),this.detectionConfidence=a}return e.getAnnotations=function(){return yd},e.getUVCoords=function(){return Ld},e.prototype.estimateFaces=function(e){return id(this,void 0,void 0,(function(){var t,n,a,r,s,o,i,u,l,c,d,p,h=this;return ud(this,(function(f){switch(f.label){case 0:if(t=e.returnTensors,n=void 0!==t&&t,a=e.flipHorizontal,r=void 0!==a&&a,s=e.predictIrises,o=void 0===s||s,i=e.input,o&&null==this.pipeline.irisModel)throw new Error("The iris model was not loaded as part of facemesh. Please initialize the model with facemesh.load({shouldLoadIrisModel: true}).");return u=function(e){return e instanceof Oa?[e.shape[0],e.shape[1]]:[e.height,e.width]}(i),l=u[1],c=Wo((function(){return i instanceof Oa||(i=es(i)),ws(zr(i,"float32"),0)})),"webgl"!==Qa.backendName?[3,2]:(p=he().get("WEBGL_PACK_DEPTHWISECONV"),he().set("WEBGL_PACK_DEPTHWISECONV",!0),[4,this.pipeline.predict(c,o)]);case 1:return d=f.sent(),he().set("WEBGL_PACK_DEPTHWISECONV",p),[3,4];case 2:return[4,this.pipeline.predict(c,o)];case 3:d=f.sent(),f.label=4;case 4:return c.dispose(),null!=d&&d.length>0?[2,Promise.all(d.map((function(e,t){return id(h,void 0,void 0,(function(){var a,s,i,u,c,d,p,h,f,m,g,y,x,b,v=this;return ud(this,(function(k){switch(k.label){case 0:return a=e.coords,s=e.scaledCoords,i=e.box,u=e.flag,c=[u],n||(c=c.concat([a,s])),[4,Promise.all(c.map((function(e){return id(v,void 0,void 0,(function(){return ud(this,(function(t){return[2,e.array()]}))}))})))];case 1:if(d=k.sent(),p=d[0],u.dispose(),p<this.detectionConfidence&&this.pipeline.clearRegionOfInterest(t),n)return h={kind:"MediaPipePredictionTensors",faceInViewConfidence:p,mesh:a,scaledMesh:s,boundingBox:{topLeft:As(i.startPoint),bottomRight:As(i.endPoint)}},r?[2,zd(h,l)]:[2,h];for(b in f=d.slice(1),m=f[0],g=f[1],s.dispose(),a.dispose(),y={kind:"MediaPipePredictionValues",faceInViewConfidence:p,boundingBox:{topLeft:i.startPoint,bottomRight:i.endPoint},mesh:m,scaledMesh:g},r&&(y=zd(y,l)),x={},yd)(o||!1===b.includes("Iris"))&&(x[b]=yd[b].map((function(e){return y.scaledMesh[e]})));return y.annotations=x,[2,y]}}))}))})))]:[2,[]]}}))}))},e}();(Ud||(Ud={})).mediapipeFacemesh="mediapipe-facemesh";const Hd={},jd={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Kd(e){if(!(e in Hd)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete Hd[e]}),!1),1===e?t.getContext("webgl",jd)||t.getContext("experimental-webgl",jd):t.getContext("webgl2",jd)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;Hd[e]=t}const t=Hd[e];return t.isContextLost()?(delete Hd[e],Kd(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Hd[e])}var Xd,qd,Yd;function Qd(e,t){return[t,e]}function Zd(e){const t=P(e);return W(Math.ceil(t/4))}function Jd(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function ep(e,t){const n=e;let a,r,s,o,i,u,l,c,d,p;return 2===he().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,l=4,c=1,d=n.HALF_FLOAT,p=n.FLOAT):(a=e.RGBA,r=e.RGBA,s=e.RGBA,o=n.RGBA,i=e.RGBA,l=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT),u=e.RGBA,{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:p}}function tp(e,t){const n=t();return he().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function np(e){return!!(he().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function ap(e,t){return dp(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(Xd||(Xd={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(qd||(qd={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Yd||(Yd={}));const rp=/ERROR: [0-9]+:([0-9]+):/g;function sp(e,t){if(tp(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function op(e,t,n,a,r,s,o){const i=e.getAttribLocation(t,n);return-1!==i&&(tp(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),tp(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,s,o))),tp(e,(()=>e.enableVertexAttribArray(i))),!0)}function ip(e,t,n,a){tp(e,(()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),tp(e,(()=>e.activeTexture(e.TEXTURE0+n))),tp(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,a))),tp(e,(()=>e.uniform1i(n,a)))}function up(e,t,n){tp(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),tp(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function lp(e,t){tp(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),tp(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function cp(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function dp(e,t,n){const a=tp(e,(()=>t()));if(null==a)throw new Error(n);return a}function pp(e,t=2){return P(e.slice(0,e.length-t))}function hp(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function fp(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[pp(e),...hp(e)]),t}function mp(e){return e%2==0}function gp(e,t){if(B(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],a=t.slice(-1)[0];if(n===a)return!0;if(mp(n)&&mp(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&mp(e[0])&&mp(t[0])}let yp,xp;function bp(e,t){return null!=e.getExtension(t)}function vp(e){try{if(null!=Kd(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function kp(e){const t=ep(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function wp(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&O("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const Ip=he();function Np(){let e,t,n,a,r,s,o,i,u,l;return 2===he().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",s="outputColor",o="out vec4 outputColor;",i="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function $p(e,t,n="index"){const a=ne(t);return a.map(((t,r)=>`int ${e[r]} = ${n} / ${t}; ${r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${t}`:`index -= ${e[r]} * ${t}`};`)).join("")}function Cp(e){const t=ne(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Ip.registerFlag("HAS_WEBGL",(()=>Ip.getNumber("WEBGL_VERSION")>0)),Ip.registerFlag("WEBGL_VERSION",(()=>vp(2)?2:vp(1)?1:0)),Ip.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),Ip.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===Ip.get("WEBGL_VERSION"))),Ip.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),Ip.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),Ip.registerFlag("WEBGL_PACK",(()=>Ip.getBool("HAS_WEBGL"))),Ip.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>Ip.getBool("WEBGL_PACK"))),Ip.registerFlag("WEBGL_PACK_CLIP",(()=>Ip.getBool("WEBGL_PACK"))),Ip.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>!1)),Ip.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>Ip.getBool("WEBGL_PACK"))),Ip.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>Ip.getBool("WEBGL_PACK"))),Ip.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>Ip.getBool("WEBGL_PACK"))),Ip.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>Ip.getBool("WEBGL_PACK"))),Ip.registerFlag("WEBGL_PACK_REDUCE",(()=>Ip.getBool("WEBGL_PACK"))),Ip.registerFlag("WEBGL_LAZILY_UNPACK",(()=>Ip.getBool("WEBGL_PACK"))),Ip.registerFlag("WEBGL_CONV_IM2COL",(()=>Ip.getBool("WEBGL_PACK"))),Ip.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==yp){const t=Kd(e);yp=t.getParameter(t.MAX_TEXTURE_SIZE)}return yp}(Ip.getNumber("WEBGL_VERSION")))),Ip.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==xp){const t=Kd(e);xp=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,xp)}(Ip.getNumber("WEBGL_VERSION")))),Ip.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=Ip.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=Kd(e);return t=bp(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:bp(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),Ip.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>Ip.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ja())),Ip.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=Kd(e);if(1===e){if(!bp(t,"OES_texture_float"))return!1}else if(!bp(t,"EXT_color_buffer_float"))return!1;return kp(t)}(Ip.getNumber("WEBGL_VERSION")))),Ip.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!Ip.getBool("WEBGL_FORCE_F16_TEXTURES")&&Ip.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),Ip.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>function(e){if(0===e)return!1;const t=Kd(e);if(1!==e){if(bp(t,"EXT_color_buffer_float"))return kp(t);const e="EXT_color_buffer_half_float";if(bp(t,e)){const n=t.getExtension(e);return function(e,t){const n=ep(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),s}(t,n)}return!1}return!!bp(t,"OES_texture_float")&&!!bp(t,"WEBGL_color_buffer_float")&&kp(t)}(Ip.getNumber("WEBGL_VERSION")))),Ip.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=Ip.getNumber("WEBGL_VERSION"))&&null!=Kd(e).fenceSync;var e})),Ip.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>Ip.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),Ip.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),Ip.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Ja()&&Ip.getBool("IS_CHROME")?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}));const Tp="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class Ep{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Xd.DENSE;const t=Zd(e),n=Np();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${$p(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Sp{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Xd.DENSE;const t=Zd(e),n=Np();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${$p(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Rp{constructor(e){this.variableNames=["A"],this.outTexUsage=qd.DOWNLOAD;const t=Np();this.outputShape=e,this.userCode=`\n      ${Tp}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class Ap{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qd.DOWNLOAD;const t=Np();this.outputShape=e,this.userCode=`\n      ${Tp}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class Fp{constructor(e,t,n=!1){this.variableNames=["A"];const a=Np(),[r,s]=t;this.outputShape=e;let o="result";n&&(o="floor(result * 255. + 0.5)"),this.userCode=`\n      ${Cp(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${s};\n        int c = imod(flatIndex, ${s});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${s}.0, ${r}.0);\n        vec4 values = ${a.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${a.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class _p{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const a=Np(),[r,s]=t;this.outputShape=e;let o="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let n=0;n<=1;n++){const i=2*t+n;o+=`\n          localCoords = coords;\n          if(localCoords[2] + ${n} < ${e[2]}) {\n            localCoords[2] += ${n};\n            if(localCoords[1] + ${t} < ${e[1]}) {\n              localCoords[1] += ${t};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${s};\n              c = imod(flatIndex, ${s});\n              uv = (vec2(c, r) + halfCR) / vec2(${s}.0, ${r}.0);\n              values = ${a.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${i}] = values[0];\n              } else if(offset == 1) {\n                result[${i}] = values[1];\n              } else if(offset == 2) {\n                result[${i}] = values[2];\n              } else {\n                result[${i}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${Cp(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${o}\n\n        ${a.output} = ${i};\n      }\n    `}}function Op(e,t,n,a,r,s){!function(e,t){const n=he().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const o=function(e){return dp(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return tp(e,(()=>e.bindTexture(i,o))),tp(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),tp(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),tp(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),tp(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),tp(e,(()=>e.texImage2D(i,0,a,t,n,0,r,s,null))),tp(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),o}function Dp(e){return e.internalFormatFloat}function Mp(e){return e.internalFormatHalfFloat}function Lp(e){return e.downloadTextureFormat}function Pp(e){return e.internalFormatPackedFloat}function Bp(e){return e.internalFormatPackedHalfFloat}class Vp{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=he().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){Hd[e]=t}(t,e)):this.gl=Kd(t);let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(1===he().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=ap(this.gl,e),bp(this.gl,t))this.textureHalfFloatExtension=ap(this.gl,t);else if(he().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),bp(this.gl,a))this.colorBufferHalfFloatExtension=ap(this.gl,a);else if(he().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",bp(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!bp(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=function(e){return function(e,t){const n=dp(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return tp(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),tp(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=dp(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return tp(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),tp(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return dp(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=ep(this.gl,this.textureHalfFloatExtension)}get debug(){return he().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;tp(e,(()=>e.finish())),tp(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),tp(e,(()=>e.deleteFramebuffer(this.framebuffer))),tp(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),tp(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),tp(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=Qd(t,n);return Op(e,r,s,Dp(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=Qd(t,n);return Op(e,r,s,Mp(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=Qd(t,n);return Op(e,r,s,Lp(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){tp(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?tp(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):tp(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),tp(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,r,s){let o,i,u;tp(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(o=new Uint8Array(n*a*4),i=e.UNSIGNED_BYTE,u=e.RGBA):(o=new Float32Array(n*a*4),i=e.FLOAT,u=s.internalFormatPackedFloat),o.set(r),tp(e,(()=>e.texImage2D(e.TEXTURE_2D,0,u,n,a,0,e.RGBA,i,o))),tp(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=Jd(t,n);return Op(e,r,s,Bp(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=Jd(t,n);return Op(e,r,s,Pp(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(lp(this.gl,this.framebuffer),this.outputTexture=null),tp(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,a){const[r,s]=Qd(t,n),o=new Uint8Array(t*n*4);return tp(e,(()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return function(e,t,n,a,r,s,o,i){const u=e,l=new Float32Array(function(e,t){const[n,a]=Jd(e,t);return n*a*4}(s,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n,a){const r=e.createBuffer();tp(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return tp(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),tp(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),tp(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(he().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const a=new Float32Array(t*n*4);return tp(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=function(e,t){const n=dp(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(tp(e,(()=>e.shaderSource(n,t))),tp(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=rp.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const a=+n[1],r=e.split("\n"),s=r.length.toString().length+2,o=r.map(((e,t)=>z((t+1).toString(),s)+e));let i=0;for(let e=0;e<o.length;e++)i=Math.max(o[e].length,i);const u=o.slice(0,a-1),l=o.slice(a-1,a),c=o.slice(a);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${z(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t,e),a=function(e){const t=Np();return function(e,t){const n=dp(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(tp(e,(()=>e.shaderSource(n,t))),tp(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t),r=function(e){return dp(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);return tp(t,(()=>t.attachShader(r,a))),tp(t,(()=>t.attachShader(r,n))),function(e,t){if(tp(e,(()=>e.linkProgram(t))),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,r),this.debug&&sp(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=function(e,t,n){return tp(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),op(e,t,"clipSpacePos",n,3,20,0)&&op(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&tp(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&sp(this.gl,this.program),tp(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return dp(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),tp(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),ip(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=Jd(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&sp(this.gl,this.program),cp(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),tp(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),tp(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=ap(this.gl,2===he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await U((()=>this.disposed||this.isQueryAvailable(e,he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||U((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),up(this.gl,e,this.framebuffer),this.debug&&cp(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(up(this.gl,this.outputTexture,this.framebuffer),this.debug&&cp(this.gl)):lp(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;up(a,e,this.framebuffer),this.debug&&cp(a),this.outputTexture=e,tp(a,(()=>a.viewport(0,0,t,n))),tp(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),tp(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:Wp}=r;function zp(e,t,n,a){const r=[];e.forEach((e=>{const t=P(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`))}));const s=r.join("\n"),o=e.map((e=>function(e,t,n=!1){let a="";a+=n?Gp(e):Up(e);const r=e.shapeInfo.logicalShape,s=t.logicalShape;return r.length<=s.length&&(a+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=Wp(e.shapeInfo.logicalShape,t.logicalShape),u=Qp(o),l=o-s;let c;const d=["x","y","z","w","u","v"];c=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map((e=>`coords.${d[e+l]} = 0;`)).join("\n");let p="";p=o<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+l]}`)).join(", ");let h="return outputValue;";const f=1===P(e.shapeInfo.logicalShape),m=1===P(t.logicalShape);if(1!==s||f||m){if(f&&!m)h=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=s-2,t=s-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?h="return vec4(outputValue.x);":i.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${a}(${p});\n      ${h}\n    }\n  `}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=t.texShape,o=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===u&&null==e.shapeInfo.flatOffset&&B(o,s))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=Qp(u),c=Wp(e.shapeInfo.logicalShape,t.logicalShape),d=u-i;let p;const h=["x","y","z","w","u","v"];p=0===i?"":u<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${h[e+d]} = 0;`)).join("\n");let f="";return f=u<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+d]}`)).join(", "),`\n    float ${r}() {\n      ${l} coords = getOutputCoords();\n      ${p}\n      return get${a}(${f});\n    }\n  `}(e,t)),a}(e,t,a))).join("\n"),i=t.texShape,u=Np(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,d,p=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Hp}\n    ${jp}\n    ${Kp}\n  `}(u);return t.isPacked?(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(B(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),r=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),r=a*Math.ceil(e[e.length-2]/2);let s=r,o="",i="b, r, c";for(let t=2;t<e.length-1;t++)s*=e[e.length-t-1],o=`\n      int b${t} = index / ${s};\n      index -= b${t} * ${s};\n    `+o,i=`b${t}, `+i;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${i});\n    }\n  `}(e,t)}}(t.logicalShape,i),d=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=t)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(e,t){return B(e,t)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=$p(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=$p(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=$p(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=$p(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}var n}(t.logicalShape,i),d=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),a&&(p+=Xp),[p,l,d,s,c,o,n].join("\n")}function Up(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[a,r]=e.shapeInfo.texShape;if(1===a&&1===r)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[s,o]=e.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${s}, ${o}, ${qp(t)});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${Yp(e)}\n      }\n    `;const a=e.shapeInfo.texShape,r=a[0],s=a[1];if(1===s&&1===r)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const o=qp(t);return 1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${r}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===r?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${s}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${s}, index + ${o});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape;if(null!=r&&B(t,r)){const e=r[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${r[1]}.0, ${e}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `}const{newShape:s,keptDims:o}=j(t),i=s;if(i.length<t.length){const t=["row","col"];return`\n      ${Up(Zp(e,i))}\n      float ${a}(int row, int col) {\n        return ${a}(${Jp(t,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${Yp(e)}\n      }\n    `;const u=r[0],l=r[1],c=qp(n);return 1===l?`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===u?`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${u}, ${l}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[1]*t[2],s=t[2],{newShape:o,keptDims:i}=j(t),u=o;if(u.length<t.length){const t=["row","col","depth"];return`\n        ${Up(Zp(e,u))}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${Jp(t,i)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${r}, ${s}, 1)));\n        ${Yp(e)}\n      }\n    `;const l=e.shapeInfo.texShape,c=l[0],d=l[1],p=e.shapeInfo.flatOffset;if(d===r&&null==p)return`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${s}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${c}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `;if(d===s&&null==p)return`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${c}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r} + col * ${s} + depth + ${qp(n)};\n        vec2 uv = uvFromFlat(${c}, ${d}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[3],s=t[2]*r,o=t[1]*s,{newShape:i,keptDims:u}=j(t);if(i.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${Up(Zp(e,i))}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${Jp(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${s}, ${r}, 1)));\n        ${Yp(e)}\n      }\n    `;const l=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,d=c[0],p=c[1];if(p===o&&null==l)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${s}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===r&&null==l)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${s} +\n          depth * ${r} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${qp(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,o=t[2]*s,i=t[1]*o,{newShape:u,keptDims:l}=j(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${Up(Zp(e,u))}\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        return ${a}(${Jp(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${o}, ${s}, ${r})) +\n          depth3;\n        ${Yp(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1];if(h===i&&null==c)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===r&&null==c)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${a}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} + depth * ${s} +\n          depth2 * ${r} + depth3 + ${qp(n)};\n      vec2 uv = uvFromFlat(${p}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=j(t);if(r.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Up(Zp(e,r))}\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${a}(${Jp(t,s)});\n      }\n    `}const o=t[5],i=t[4]*o,u=t[3]*i,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Yp(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===c&&null==d)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${i}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===o&&null==d)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${i} + depth3 * ${o} + depth4 + ${qp(n)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function Gp(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Np().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=e.shapeInfo.texShape,r=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],s=Np();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${r[0]}, ${r[1]}, index);\n      return ${s.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=r[0],o=r[1],i=Np();if(null!=r&&B(t,r))return`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${s}.0);\n\n        return ${i.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===t[0]){const n=[1,2],r=["b","row","col"];return`\n        ${Gp(Zp(e,t.slice(1)))}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${Jp(r,n)});\n        }\n      `}const o=s[0],i=s[1],u=Math.ceil(t[2]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${o}, ${i}, ${u*Math.ceil(t[1]/2)}, ${u}, b, row, col);\n      return ${Np().texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],i=o[0],u=o[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),d="int b, int row, int col",p=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let e=2;e<n-1;e++)d=`int b${e}, `+d,c*=t[n-e-1],p=`b${e} * ${c} + `+p;return`\n    vec4 ${r}(${d}) {\n      int index = ${p};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${i});\n      return ${Np().texture2D}(${a}, uv);\n    }\n  `}(e)}}const Hp="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",jp="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Kp="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Xp="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function qp(e){return`offset${e}`}function Yp(e){const t=e.name,n=P(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Qp(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Zp(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Jp(e,t){return t.map((t=>e[t])).join(", ")}function eh(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const a=e.logicalShape,r=t[n],s=r.shape;if(!B(a,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${s} must match`);if(e.isUniform&&r.isUniform)return;const o=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!B(o,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${i} must match`)}))}function th(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&O("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}function nh(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const ah={kernelName:xe,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;th(t,"abs");let a=new Float32Array(P(t.shape));return a=nh(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,"float32")}};function rh(e){return(t,n,a,r,s)=>{const o=go(t,n),i=o.length,u=ne(o),l=K(s,P(o)),c=t.length,d=n.length,p=ne(t),h=ne(n),f=fo(t,o),m=fo(n,o);if(f.length+m.length===0)for(let t=0;t<l.length;++t)l[t]=e(a[t%a.length],r[t%r.length]);else for(let t=0;t<l.length;++t){const n=ce(t,i,u),s=n.slice(-c);f.forEach((e=>s[e]=0));const o=le(s,c,p),g=n.slice(-d);m.forEach((e=>g[e]=0));const y=le(g,d,h);l[t]=e(a[o],r[y])}return[l,o]}}function sh(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",o)},i}const oh={kernelName:ze,backendName:"cpu",kernelFunc:sh};function ih(e,t,n="float32"){if("complex64"===n)return sh({inputs:{real:ih(e,t,"float32"),imag:ih(e,t,"float32")},backend:e});const a=oe(P(t),n);return e.makeTensorInfo(t,n,a)}function uh(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const lh={kernelName:Ct,backendName:"cpu",kernelFunc:uh};function ch(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const dh={kernelName:yn,backendName:"cpu",kernelFunc:ch};function ph(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if("complex64"===s){if("complex64"===r.dtype)return uh({inputs:{x:r},backend:n});const e=ih(n,r.shape,r.dtype),t=ph({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=sh({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=ch({inputs:{input:r},backend:n}),t=ph({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!q(r.dtype,s)){const e=uh({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s){const e=n.data.get(r.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(r.shape,"int32",t)}if("bool"===s){const e=n.data.get(r.dataId).values,t=xa([0],r.dtype),[a,s]=rh(((e,t)=>e!==t?1:0))(r.shape,[],e,t,"bool");return n.makeTensorInfo(s,"bool",a)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}const hh={kernelName:Be,backendName:"cpu",kernelFunc:ph};function fh(e,t,n,a){return null==n?({inputs:n,backend:r})=>{const{a:s,b:o}=n,i=r;th([s,o],e);const u=i.data.get(s.dataId).values,l=i.data.get(o.dataId).values,c=a||s.dtype,[d,p]=t(s.shape,o.shape,u,l,c);return i.makeTensorInfo(p,c,d)}:({inputs:e,backend:r})=>{const{a:s,b:o}=e,i=r;if("complex64"===s.dtype||"complex64"===o.dtype){const e=ph({inputs:{x:s},backend:i,attrs:{dtype:"complex64"}}),t=i.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,u=i.data.get(a.dataId).values,l=i.data.get(r.dataId).values,c=ph({inputs:{x:o},backend:i,attrs:{dtype:"complex64"}}),d=i.data.get(c.dataId),p=d.complexTensorInfos.real,h=d.complexTensorInfos.imag,f=i.data.get(p.dataId).values,m=i.data.get(h.dataId).values,[g,y,x]=n(s.shape,o.shape,u,l,f,m),b=i.makeTensorInfo(x,"float32",g),v=i.makeTensorInfo(x,"float32",y),k=sh({inputs:{real:b,imag:v},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(v),k}{const e=i.data.get(s.dataId).values,n=i.data.get(o.dataId).values,r=a||s.dtype,[u,l]=t(s.shape,o.shape,e,n,r);return i.makeTensorInfo(l,r,u)}}}function mh(e){return(t,n,a,r,s,o)=>{const i=go(t,n),u=P(i),l=i.length,c=ne(i),d=K("float32",u),p=K("float32",u),h=fo(t,i),f=fo(n,i),m=au(a,r),g=au(s,o),y=t.length,x=ne(t),b=n.length,v=ne(n);if(h.length+f.length===0)for(let t=0;t<d.length;t++){const n=t%m.length,a=t%g.length,r=e(m[2*n],m[2*n+1],g[2*a],g[2*a+1]);d[t]=r.real,p[t]=r.imag}else for(let t=0;t<d.length;t++){const n=ce(t,l,c),a=n.slice(-y);h.forEach((e=>a[e]=0));const r=le(a,y,x),s=n.slice(-b);f.forEach((e=>s[e]=0));const o=le(s,b,v),i=e(m[2*r],m[2*r+1],g[2*o],g[2*o+1]);d[t]=i.real,p[t]=i.imag}return[d,p,i]}}const gh=rh(((e,t)=>e+t)),yh=mh(((e,t,n,a)=>({real:e+n,imag:t+a}))),xh=fh(ke,gh,yh),bh={kernelName:ke,backendName:"cpu",kernelFunc:xh};function vh(e,t,n,a,r){const s=P(a),o=oe(r,n);for(let n=0;n<e.length;n++){const a=e[n];if(a<0)throw new Error("Input x must be non-negative!");a>=r||(o[a]+=s>0?t[n]:1)}return o}function kh(e,t,n,a=!1){const r=e.shape[0],s=e.shape[1],o=Wr([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<s;r++){const s=e.get(i,r);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(a?o.set(1,i,s):t.size>0?o.set(o.get(i,s)+t.get(i,r),i,s):o.set(o.get(i,s)+1,i,s))}return o}function wh(e){return(t,n,a)=>{const r=K(n,t.length);for(let n=0;n<t.length;++n)r[n]=e(t[n],a);return r}}function Ih(e,t,n){return({inputs:a,attrs:r,backend:s})=>{const{x:o}=a;if(th(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,u=i.data.get(o.dataId).values,l=P(o.shape),c=n||o.dtype,d=X(c,l);for(let e=0;e<l;++e)d[e]=t(u[e],r);return i.makeTensorInfo(o.shape,c,d)}}function Nh(e,t,n){return({inputs:a,attrs:r,backend:s})=>{const{x:o}=a;if(th(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,u=i.data.get(o.dataId).values,l=n||o.dtype,c=t(u,l,r);return i.makeTensorInfo(o.shape,l,c)}}const $h=wh((e=>Math.ceil(e))),Ch=Nh(Ve,$h),Th={kernelName:Ve,backendName:"cpu",kernelFunc:Ch};function Eh(e,t,n,a){const r=X(n,P(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=P(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const s="string"===n?mu(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[i+t]=s[o++]}a+=e.shape[1]}))}return r}const Sh=wh((e=>Math.exp(e))),Rh=Nh(ht,Sh),Ah={kernelName:ht,backendName:"cpu",kernelFunc:Rh},Fh=wh((e=>Math.expm1(e))),_h=Nh(mt,Fh),Oh={kernelName:mt,backendName:"cpu",kernelFunc:_h},Dh=wh((e=>Math.floor(e))),Mh=Nh(bt,Dh),Lh={kernelName:bt,backendName:"cpu",kernelFunc:Mh};function Ph(e,t,n){const a=Wr(n,e.dtype);for(let n=0;n<a.size;++n){const r=a.indexToLoc(n).slice(),s=r[0],o=r[2],i=t.locToIndex([s,o]);r[2]=t.values[i];const u=e.locToIndex(r);a.values[n]=e.values[u]}return a}const Bh=rh(((e,t)=>e>t?1:0)),Vh=fh(Nt,Bh,null,"bool"),Wh={kernelName:Nt,backendName:"cpu",kernelFunc:Vh},zh=rh(((e,t)=>e<t?1:0)),Uh=fh(_t,zh,null,"bool"),Gh={kernelName:_t,backendName:"cpu",kernelFunc:Uh};function Hh(e,t,n){const a=(t-e)/(n-1),r=oe(n,"float32");r[0]=e;for(let e=1;e<r.length;e++)r[e]=r[e-1]+a;return r}const jh=wh((e=>Math.log(e))),Kh=Nh(Mt,jh),Xh={kernelName:Mt,backendName:"cpu",kernelFunc:Kh};function qh(e,t,n,a){const r=K(a,P(n));for(let n=0;n<r.length;++n){const a=n*t;let s=e[a];for(let n=0;n<t;++n){const t=e[a+n];t>s&&(s=t)}r[n]=s}return r}const Yh=rh(((e,t)=>Math.max(e,t))),Qh=fh(Gt,Yh),Zh={kernelName:Gt,backendName:"cpu",kernelFunc:Qh},Jh=rh(((e,t)=>Math.min(e,t))),ef=fh(Zt,Jh),tf={kernelName:Zt,backendName:"cpu",kernelFunc:ef},nf=rh(((e,t)=>e*t)),af=mh(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),rf=fh(nn,nf,af),sf={kernelName:nn,backendName:"cpu",kernelFunc:rf};function of(e,t,n){const a=ya(-1,n);return nf([],t,a,e,n)}const uf={kernelName:an,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;th(a,"neg");const r=n.data.get(a.dataId).values,[s,o]=of(r,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,s)}},lf=rh(((e,t)=>e!==t?1:0)),cf=fh(rn,lf,null,"bool"),df={kernelName:rn,backendName:"cpu",kernelFunc:cf};function pf(e,t,n,a,r){const s=t.length,o=P(t),i=ne(t),u=ne(r),l=K(n,P(r));for(let t=0;t<o;++t){const n=ce(t,s,i),r=new Array(n.length);for(let e=0;e<r.length;e++)r[e]=n[a[e]];l[le(r,s,u)]=e[t]}return l}function hf(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;th(r,"transpose");const o=r.shape.length,i=new Array(o);for(let e=0;e<i.length;e++)i[e]=r.shape[s[e]];const u=pf(a.data.get(r.dataId).values,r.shape,r.dtype,s,i);return{dataId:a.write(u,i,r.dtype),shape:i,dtype:r.dtype}}const ff={kernelName:Jn,backendName:"cpu",kernelFunc:hf};function mf(e,t,n,a){const[r,s]=Co(e,a),o=za(t,"int32"),i=oe(P(r),o),u=P(s);for(let e=0;e<i.length;++e){const t=e*u;let a=1;for(let e=0;e<u;++e)a*=n[t+e];i[e]=a}return{outVals:i,outShape:r,outDtype:o}}const gf={kernelName:mn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;th(r,"prod");const i=r.shape.length,u=H(s,r.shape),l=So(u,i);let c=u,d=r;const p=[];null!=l&&(d=hf({inputs:{x:r},backend:n,attrs:{perm:l}}),p.push(d),c=Ao(c.length,i));const h=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=mf(d.shape,d.dtype,h,c);let y=m;return o&&(y=To(m,u)),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function yf(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return oe(0,a);const r=oe(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),r[0]=e;for(let e=1;e<r.length;e++)r[e]=r[e-1]+n;return r}const xf=wh((e=>1/Math.sqrt(e))),bf=Nh(En,xf),vf={kernelName:En,backendName:"cpu",kernelFunc:bf};function kf(e,t,n,a,r){const s=hs(a,t,n),o=P(n),i=ne(a);if(s){const n=fs(t,i);return"string"===r?e.slice(n,n+o):e.subarray(n,n+o)}const u=Wr(a,r,"string"===r?mu(e):e),l=Wr(n,r);for(let e=0;e<l.size;++e){const n=l.indexToLoc(e),a=n.map(((e,n)=>e+t[n]));l.set(u.get(...a),...n)}return"string"===r?gu(l.values):l.values}function wf(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:o}=a;th(r,"slice");const[i,u]=ms(r,s,o);ts(r,i,u);const l=kf(n.data.get(r.dataId).values,i,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,l)}const If={kernelName:Fn,backendName:"cpu",kernelFunc:wf},Nf=rh(((e,t)=>{const n=e-t;return n*n})),$f=fh(Un,Nf),Cf={kernelName:Un,backendName:"cpu",kernelFunc:$f};function Tf(e,t,n,a){const r=Wr(e,t.dtype);for(let e=0;e<r.size;e++){const s=r.indexToLoc(e),o=new Array(s.length);for(let e=0;e<o.length;e++)o[e]=s[e]*n[e]+a[e];r.set(t.get(...o),...s)}return r}const Ef=rh(((e,t)=>e-t)),Sf=mh(((e,t,n,a)=>({real:e-n,imag:t-a}))),Rf=fh(Hn,Ef,Sf),Af={kernelName:Hn,backendName:"cpu",kernelFunc:Rf};function Ff(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const a=Wr(n,e.dtype);for(let t=0;t<a.values.length;++t){const n=a.indexToLoc(t),r=new Array(e.rank);for(let t=0;t<r.length;t++)r[t]=n[t]%e.shape[t];const s=e.locToIndex(r);a.values[t]=e.values[s]}return a}function _f(e,t,n,a,r){const s=t[t.length-1],[o,i]=[e.length/s,s],u=K(n,o*a),l=K("int32",o*a);for(let t=0;t<o;t++){const n=t*i,r=e.subarray(n,n+i),s=[];for(let e=0;e<r.length;e++)s.push({value:r[e],index:e});s.sort(((e,t)=>t.value-e.value));const o=t*a,c=u.subarray(o,o+a),d=l.subarray(o,o+a);for(let e=0;e<a;e++)c[e]=s[e].value,d[e]=s[e].index}const c=t.slice();return c[c.length-1]=a,[Wr(c,n,u),Wr(c,"int32",l)]}function Of(e,t,n,a){const r=H(t,n)[0],s=[1,n[0],1];for(let e=0;e<r;e++)s[0]*=n[e];s[1]=n[r];for(let e=r+1;e<n.length;e++)s[2]*=n[e];const o={},i=new Int32Array(n[r]),u=new Ra(s,a,e),l=[],c=1===s[0]&&1===s[2];for(let t=0;t<n[r];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<s[0];n++)for(let a=0;a<s[2];a++)e.push(u.get(n,t,a));n=e.join(",")}if(void 0!==o[n])i[t]=o[n];else{const e=Object.keys(o).length;o[n]=e,i[t]=e,l.push(t)}}const d=s.slice();d[1]=Object.keys(o).length;const p=new Ra(d,a);l.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let a=0;a<s[2];a++)p.set(u.get(n,e,a),n,t,a)}));const h=n.slice();return h[r]=d[1],{outputValues:p.values,outputShape:h,indices:i}}const{addImpl:Df,bincountImpl:Mf,bincountReduceImpl:Lf,ceilImpl:Pf,concatImpl:Bf,expImpl:Vf,expm1Impl:Wf,floorImpl:zf,gatherV2Impl:Uf,greaterImpl:Gf,lessImpl:Hf,linSpaceImpl:jf,logImpl:Kf,maxImpl:Xf,maximumImpl:qf,minimumImpl:Yf,multiplyImpl:Qf,negImpl:Zf,prodImpl:Jf,rangeImpl:em,rsqrtImpl:tm,simpleAbsImpl:nm,sliceImpl:am,stridedSliceImpl:rm,subImpl:sm,tileImpl:om,topKImpl:im,transposeImpl:um,uniqueImpl:lm}=w;function cm(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function dm(e,t){return 1===t?[e]:cm(e,t)}class pm{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=dm("rc",t),a=Qp(t),r=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let a="";for(let r=e-2;r<e;r++)a+=`${n[r]} >= ${t[r]}`,r<e-1&&(a+="||");return a}(t,e,n),s=function(e,t,n,a){if(1===e)return"";const r=a.slice(-2);return`\n    int r = ${r[0]};\n    int c = ${r[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),o=function(e,t){const n=e.length,a=function(e,t){const n=[];for(let a=0;a<=1;a++)for(let r=0;r<=1;r++){let s=`${0===a?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let n=2;n<e;n++)s=`${t[t.length-1-n]},`+s;n.push(s)}return n}(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${a[0]}),\n          cEdge ? 0. : getA(${a[1]}),\n          rEdge ? 0. : getA(${a[2]}),\n          rEdge || cEdge ? 0. : getA(${a[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${a} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}}class hm{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var a;this.userCode=`\n      ${a=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${$p(["r","c","d"],a)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${Cp(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class fm{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const a=gm(t,n),r=ym(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const s=mm(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[r].shift();return this.usedTextures[r].push(e),e}let o;return a===Yd.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===Yd.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===Yd.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===Yd.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===Yd.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=gm(n,a),s=ym(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);const o=mm(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),i=he().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=o):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[s],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function mm(e,t,n,a,r){const s=function(e,t){switch(e){case Yd.PACKED_2X2_FLOAT32:return Pp(t);case Yd.PACKED_2X2_FLOAT16:return Bp(t);case Yd.UNPACKED_FLOAT32:return Dp(t);case Yd.UNPACKED_FLOAT16:return Mp(t);case Yd.PACKED_4X1_UNSIGNED_BYTE:return Lp(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,a);let o;if(r){const[t,n]=Jd(e[0],e[1]);o=t*n}else{const[t,n]=Qd(e[0],e[1]);o=t*n}return o*function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,s)}function gm(e,t){if(e===qd.UPLOAD)return Yd.PACKED_2X2_FLOAT32;if(e===qd.RENDER||null==e)return function(e){return he().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Yd.PACKED_2X2_FLOAT32:Yd.UNPACKED_FLOAT32:e?Yd.PACKED_2X2_FLOAT16:Yd.UNPACKED_FLOAT16}(t);if(e===qd.DOWNLOAD||e===qd.PIXELS)return Yd.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function ym(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class xm{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const bm="return abs(x);",vm="return x;";class km{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class wm{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=dm("rc",t),a=Qp(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),o=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${a} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const Im=yu,Nm={};class $m extends R{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!he().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=Kd(he().getNumber("WEBGL_VERSION"));this.binaryCache=((t=he().getNumber("WEBGL_VERSION"))in Nm||(Nm[t]={}),Nm[t]),this.gpgpu=new Vp(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new fm(this.gpgpu),this.numMBBeforeWarning=null==he().global.screen?1024:he().global.screen.height*he().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new S(this,Vo())}nextDataId(){return $m.nextDataId++}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(e,t,n){if((he().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||he().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:qd.UPLOAD,refCount:1}),a}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,a,r){if(he().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:qd.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:s,shape:o,isPacked:i}=t;if(null!=s){let t;t=i?new km(o,vm):new xm(o,vm);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const u=null!=this.activeTimers;let l,c;return u&&(l=ba()),c="complex64"===a?au(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=ba()-l),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:s,complexTensorInfos:o,isPacked:i}=t;if(null!=r){let t;t=i?new km(a,vm):new xm(a,vm);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:s}],s),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(!he().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===he().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,l,c=null;if("complex64"!==s&&he().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(t.texture,...Zd(a))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);l=au(e[0],e[1])}else if(null==c)l=this.getValuesFromTexture(e);else{const e=P(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}null!=u&&this.disposeIntermediateTensorInfo(u);const d=this.convertAndCacheOnCPU(e,l),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Vo().removeDataId(e,this),this.pendingDeletes--),d}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>ka(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Wr(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!np(n)){if(he().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=P(t);if(he().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture,...Zd(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),s}const s=he().getBool("WEBGL_PACK")&&!0===a,o=s?fp(t):t,i=s?new Ap(o):new Rp(o),u=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=L(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=L(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);o.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),o.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ba(),endMs:null}}endTimer(e){return he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ba(),e)}async getQueryTime(e){if(he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:s,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,u=this.dataRefCount.get(i);u>1?this.dataRefCount.set(i,u-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,s)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}getCPUBackend(){return he().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Vo().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(e,t=128){const n=this.getCPUBackend();return he().getBool("IS_TEST")||this.warnedAboutCPUBackend||null!=n||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&e.every((e=>null==this.texData.get(e.dataId).texture&&P(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){tu("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return Im(e.shape,t)}packedUnaryOp(e,t,n){const a=new km(e.shape,t),r=this.compileAndRun(a,[e],n);return Vo().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=nm(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(he().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,bm,e.dtype);const t=new xm(e.shape,bm),n=this.compileAndRun(t,[e]);return Vo().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Z(n[0])){const r=n.map((e=>va(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:a}=this.makeTensorInfo(e,t,n);return Vo().makeTensorFromDataId(a,e,t,this)}unpackTensor(e){const t=new wm(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new pm(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[pp(e.shape),...hp(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[pp(t),...hp(t)],s=new hm(r,n),o=this.runWebGLProgram(s,[a],e.dtype,null,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:a,dtype:r}=t,s=fp(a);let o;return o=n?new Sp(s):new Ep(s),{dtype:r,shape:a,dataId:this.runWebGLProgram(o,[{shape:s,dtype:r,dataId:e}],r,null,!0).dataId}}runWebGLProgram(e,t,n,a,r=!1){const s=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(s.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===Xd.DENSE){const t=Zd(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===P(s.shape))return o.values=K(s.dtype,0),s;const i=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&P(t.shape)<=he().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),i.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!gp(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),i.push(t),n=this.texData.get(t.dataId),e.shape=a}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(s.dataId);const l={shape:s.shape,texData:o,isUniform:!1},c=function(e,t,n){let a="";t.concat(n).forEach((e=>{const t=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0,n=e.isUniform?"uniform":e.texData.texShape;a+=`${e.shape}_${n}_${t}`}));const r=e.userCode;let s=e.constructor.name;return s+="_"+a+"_"+r,s}(e,u,l),d=this.getAndSaveBinary(c,(()=>function(e,t,n,a){const r=t.userCode,s=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),o=s.map((e=>e.shapeInfo)),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},u=zp(s,i,r,t.packedInputs),l=e.createProgram(u);let c=null;const d=e.getUniformLocation(l,"NAN",!1);1===he().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(l,"INFINITY",!1));const p={};for(let n=0;n<t.variableNames.length;n++){const a=t.variableNames[n],r=!1;p[a]=e.getUniformLocation(l,a,r),p[`offset${a}`]=e.getUniformLocation(l,`offset${a}`,r)}return{program:t,source:u,webGLProgram:l,uniformLocations:p,inShapeInfos:o,outShapeInfo:i,infLoc:c,nanLoc:d}}(this.gpgpu,e,u,l))),p=null!=this.activeTimers;let h;p&&(h=this.startTimer()),function(e,t,n,a,r){eh(t.inShapeInfos,n),eh([t.outShapeInfo],[a]);const s=a.texData.texture,o=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s,o[0],o[1]):e.setOutputMatrixTexture(s,o[0],o[1]),e.setProgram(t.webGLProgram),1===he().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,a)=>{const r=t.program.variableNames[a],s=t.uniformLocations[r],o=t.uniformLocations[`offset${r}`];if(null!=s)if(n.isUniform)if(P(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=n.texData.slice&&null!=o&&e.gl.uniform1i(o,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,s,a)})),null!=r&&r(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,d,u,l,a),i.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(h=this.endTimer(h),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)}));const f=he().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const e=ba();e-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!he().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===r){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,a,r=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(he().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Wo((()=>{if(!he().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=he().getBool("DEBUG");he().set("DEBUG",!1);const t=this.abs($s(1e-8)).dataSync()[0];if(he().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:s,usage:o,isPacked:i}=t;if(null!=s)return;const u=null!=this.activeTimers;let l;u&&(l=ba());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=he().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map(((t,n)=>n>=e.length-2?_(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=j(e);e=t.newShape}let a=P(e);if(e.length<=1&&a<=n)return[1,a];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=pp(e);let n=2,r=2;return e.length&&([n,r]=hp(e)),a=t*(n/2)*(r/2),W(a).map((e=>2*e))}return W(a)}(n,i),t.texShape=c),null!=r){const e=fp(n);let s,o=c[1],d=c[0];const p=r instanceof Uint8Array;i?([o,d]=Jd(c[0],c[1]),s=new _p(e,[d,o],p)):s=new Fp(e,[d,o],p);const h=this.makeTensorInfo([d,o],a);this.texData.get(h.dataId).usage=p?qd.PIXELS:qd.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(h.dataId),o,d,r);const f=!0,m=this.runWebGLProgram(s,[h],a,null,f),g=this.texData.get(m.dataId);t.texture=g.texture,t.texShape=g.texShape,t.isPacked=g.isPacked,t.usage=g.usage,this.disposeIntermediateTensorInfo(h),this.texData.delete(m.dataId),t.values=null,u&&(this.uploadWaitMs+=ba()-l)}else{const e=this.acquireTexture(c,o,a,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*Q(t)}}$m.nextDataId=0,er()&&Uo("webgl",(()=>new $m),2);class Cm{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=go(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class Tm{constructor(e,t,n,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=go(t,n);const r=this.outputShape.length;let s="";if(a)if(0===r||1===P(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${Qp(r)} coords = getOutputCoords();\n        `,1===r)s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=dm("coords",r);s+=`\n            bool nextRowOutOfBounds =\n              (${e[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${e[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function Em(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const Sm={kernelName:Ct,backendName:"webgl",kernelFunc:Em};function Rm(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),o=n.texData.get(s.dataId),i=Em({inputs:{x:a},backend:n}),u=Em({inputs:{x:r},backend:n});return o.complexTensorInfos={real:i,imag:u},s}const Am={kernelName:ze,backendName:"webgl",kernelFunc:Rm},Fm="return (a < 0.) ? b * a : a;",_m="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Om={kernelName:Ft,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,o=n.makeTensorInfo([],"float32",ya(s,"float32")),i=he().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tm(_m,r.shape,o.shape):new Cm(Fm,r.shape,o.shape),u=n.runWebGLProgram(i,[r,o],r.dtype);return n.disposeIntermediateTensorInfo(o),u}},Dm="return (a < 0.) ? b * a : a;",Mm="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Lm={kernelName:fn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=he().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tm(Mm,a.shape,r.shape):new Cm(Dm,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)}};function Pm({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:r,backend:s})=>{const{x:o}=r,i=s,u=a||o.dtype;if(i.shouldExecuteOnCPU([o])&&null!=n){const e=i.texData.get(o.dataId),t=n(e.values,u);return i.makeTensorInfo(o.shape,u,t)}let l;return l=he().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new km(o.shape,t):new xm(o.shape,e),i.runWebGLProgram(l,[o],u)}}function Bm({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:r,dtype:s}){return({inputs:o,backend:i})=>{const{a:u,b:l}=o,c=i;if(a&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[a,r]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,a]=t,r={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:a.dataId,dtype:a.dtype,shape:l.shape},o=new Cm(e,u.shape,l.shape);return c.runWebGLProgram(o,[r,s],za(n.dtype,a.dtype))})),s=Rm({inputs:{real:a,imag:r},backend:c});return c.disposeIntermediateTensorInfo(a),c.disposeIntermediateTensorInfo(r),s}const d=s||za(u.dtype,l.dtype);if(c.shouldExecuteOnCPU([u,l])&&null!=r){const e=c.texData.get(u.dataId),t=c.texData.get(l.dataId),[n,a]=r(u.shape,l.shape,e.values,t.values,d),s=c.makeTensorInfo(a,d);return c.texData.get(s.dataId).values=n,s}let p;return p=he().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Tm(t,u.shape,l.shape,n):new Cm(e,u.shape,l.shape),c.runWebGLProgram(p,[u,l],d)}}function Vm(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?Mm:Dm;if("leakyrelu"===e)return t?_m:Fm;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class Wm{constructor(e,t,n,a=!1,r=!1,s=!1,o=null,i=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const l=a?e[1]:e[2],c=Math.ceil(l/2),d=a?"i * 2, rc.y":"rc.y, i * 2",p=r?"rc.z, i * 2":"i * 2, rc.z",h=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";o&&(m=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,g="result = activation(result);");const y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let x="rc.x",b="rc.x";e[0]<t[0]?x=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(b=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${m}\n\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${x};\n          int batchB = ${b};\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}class zm{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=go(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Um="return a * b;";function Gm(e){const{inputs:t,backend:n}=e,{a,b:r}=t,s=za(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),s=new zm("return areal * breal - aimag * bimag;",a.shape,r.shape),o=new zm("return areal * bimag + aimag * breal;",a.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],u=n.runWebGLProgram(s,i,"float32"),l=n.runWebGLProgram(o,i,"float32"),c=Rm({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[o,i]=Qf(a.shape,r.shape,e.values,t.values,s),u=n.makeTensorInfo(i,s);return n.texData.get(u.dataId).values=o,u}let o;return o=he().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tm(Um,a.shape,r.shape):new Cm(Um,a.shape,r.shape),n.runWebGLProgram(o,[a,r],s)}const Hm={kernelName:nn,backendName:"webgl",kernelFunc:Gm};function jm(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,o=n,i=P(r.shape),u=G(s,i),l=P(u);O(i===l,(()=>`The new shape (${u}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`));const c=o.texData.get(r.dataId);return!c.isPacked||gp(r.shape,u)||null!==c.texture&&gp(c.shape,u)?(o.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype}):function(e,t,n){const a=[pp(e.shape),...hp(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[pp(t),...hp(t)],o=new hm(s,a),i=n.runWebGLProgram(o,[r],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}(r,u,o)}const Km={kernelName:vn,backendName:"webgl",kernelFunc:jm};class Xm{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];const o=4*Math.floor(n/4),i=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${V(e)?e.toPrecision(2):e}, ones);`}let l="";r%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===i}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class qm{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let o="0.0",i="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",i="min"):"max"===t&&(o="-1.0 / 1e-20",i="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n      }\n    `,p="vec4";"all"===t?(o="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(o="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}function Ym(e,t,n,a){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=Mi(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let s=e;for(let o=0;o<r.length;o++){const{inSize:i,windowSize:u,outSize:l}=r[o];let c,d;c="mean"===n?0===o?new Xm({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},i):new Xm({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l}):new qm({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},n),d=s,s=a.runWebGLProgram(c,[s],t),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return s}class Qm{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const a=Qp(this.rank),r=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let t=0;t<e.length;t++)a[e[t]]=n[t];return a.join()}(t);this.userCode=`\n    void main() {\n      ${a} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class Zm{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const a=Qp(this.rank),r=cm("rc",this.rank),s=new Array(this.rank);for(let e=0;e<t.length;e++)s[t[e]]=r[e];const o=`vec2(${s.slice(-2).join()})`,i=`++${r[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${s.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${a} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${i}) {\n        result[1] = ${u};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${i}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Jm(e,t,n){const a=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Zm(e.shape,t):new Qm(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function eg(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;return function(e,t,n,a){const r=t,s=e.shape.length,o=H(r,e.shape);let i=o;const u=So(i,s),l=null!=u;let c=e;l&&(c=Jm(e,u,a),i=Ao(i.length,s)),Eo("sum",i,s);const[d,p]=Co(c.shape,i);let h=d;n&&(h=To(d,o));const f=P(p),m=jm({inputs:{x:c},attrs:{shape:[P(e.shape)/f,f]},backend:a}),g=Ym(m,Ua(e.dtype),"sum",a),y=jm({inputs:{x:g},attrs:{shape:h},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(c),y}(r,s,o,n)}const tg={kernelName:Bn,backendName:"webgl",kernelFunc:eg};function ng(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,o=n,i=r.shape.length,u=new Array(i);for(let e=0;e<u.length;e++)u[e]=r.shape[s[e]];let l;if(o.shouldExecuteOnCPU([r])){const e=o.texData.get(r.dataId).values,t=um(e,r.shape,r.dtype,s,u);l=o.makeTensorInfo(u,r.dtype),o.texData.get(l.dataId).values=t}else l=Jm(r,s,o);return l}const ag={kernelName:Jn,backendName:"webgl",kernelFunc:ng};function rg({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,d=n?e.shape[l-2]:e.shape[l-1],p=a?t.shape[c-1]:t.shape[c-2],h=n?e.shape[l-1]:e.shape[l-2],f=a?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=P(m),x=P(g);O(l>=2&&c>=2&&(y===x||1===y||1===x),(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`));const b=(y>x?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([h,f]);O(d===p,(()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`));const v=n?[y,d,h]:[y,h,d],k=a?[x,f,p]:[x,p,f],w=jm({inputs:{x:e},backend:r,attrs:{shape:v}}),I=jm({inputs:{x:t},backend:r,attrs:{shape:k}}),N=[w,I],$=Math.max(y,x),C=n?w.shape[1]:w.shape[2],T=null!=s,E=null!=o,S="leakyrelu"===u,R=null!=u?Vm(u,!0):null;let A;if((1===h||1===f)&&C>1e3&&!1===(T||E||S||null!=R)){let e=w,t=I;n&&(e=ng({inputs:{x:w},backend:r,attrs:{perm:[0,2,1]}}),N.push(e)),a&&(t=ng({inputs:{x:I},backend:r,attrs:{perm:[0,2,1]}}),N.push(t));const s=1===f;let o=e;1!==f&&(o=jm({inputs:{x:e},backend:r,attrs:{shape:[$,C,1]}}),N.push(o));const i=1===f?2:1;let u=t;s&&(u=jm({inputs:{x:t},backend:r,attrs:{shape:[$,1,C]}}),N.push(u));const l=Gm({inputs:{a:o,b:u},backend:r});A=eg({inputs:{x:l},backend:r,attrs:{axis:i,keepDims:!0}}),N.push(l)}else{const u=za(e.dtype,t.dtype),l=new Wm(v,k,[$,h,f],n,a,T,R,E,S),c=[w,I];if(null!=s&&c.push(s),E&&c.push(o),S){const e=r.makeTensorInfo([],"float32",ya(i,"float32"));c.push(e),N.push(e)}A=r.runWebGLProgram(l,c,u)}const F=jm({inputs:{x:A},backend:r,attrs:{shape:b}});N.push(A);for(const e of N)r.disposeIntermediateTensorInfo(e);return F}const sg={kernelName:ia,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=a;return rg({a:r,b:s,transposeA:u,transposeB:l,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}},og="return abs(x);",ig={kernelName:xe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=nm(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=he().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new km(a.shape,og):new xm(a.shape,og),n.runWebGLProgram(r,[a],a.dtype)}},ug=Pm({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),lg={kernelName:be,backendName:"webgl",kernelFunc:ug},cg=Pm({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),dg={kernelName:ve,backendName:"webgl",kernelFunc:cg},pg="return a + b;",hg=Bm({opSnippet:pg,packedOpSnippet:pg,supportsComplex:!0,cpuKernelImpl:Df}),fg={kernelName:ke,backendName:"webgl",kernelFunc:hg};class mg{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}}class gg{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}}const yg={kernelName:we,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,r=n;if(1===r.length)return Em({inputs:{x:r[0]},backend:a});if(r.length>he().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),s=e({inputs:r.slice(t),backend:a});return e({inputs:[n,s],backend:a})}const s=r.map((e=>e.dtype)).reduce(((e,t)=>za(e,t))),o=r.map((e=>e.shape)),i=he().getBool("WEBGL_PACK")?new gg(r[0].shape,o):new mg(r[0].shape,o);return a.runWebGLProgram(i,r,s)}},xg={kernelName:Ie,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,u=H(s,r.shape);let l=u;const c=So(l,i);let d=r;null!=c&&(d=ng({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Ao(l.length,i)),Eo("all",l,i);const[p,h]=Co(d.shape,l),f=jm({inputs:{x:d},backend:n,attrs:{shape:[-1,P(h)]}}),m=Ym(f,f.dtype,"all",n);let g;return g=jm(o?{inputs:{x:m},backend:n,attrs:{shape:To(p,u)}}:{inputs:{x:m},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},bg={kernelName:Ne,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,u=H(s,r.shape);let l=u;const c=So(l,i);let d=r;null!=c&&(d=ng({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Ao(l.length,i)),Eo("any",l,i);const[p,h]=Co(d.shape,l),f=jm({inputs:{x:d},backend:n,attrs:{shape:[-1,P(h)]}}),m=Ym(f,f.dtype,"any",n);let g;return g=jm(o?{inputs:{x:m},backend:n,attrs:{shape:To(p,u)}}:{inputs:{x:m},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};class vg{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];const o="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class kg{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,u=Qp(i),l=dm("coords",i);let c,d;if(1===s){d=i+1;const e=Qp(d);c=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[i-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[i-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[i-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[i-2]};`}else d=i,c=`\n        ${u} sourceLocR = coords;\n        ++${l[i-1]};\n        ${u} sourceLocG = coords;\n        ++${l[i-2]};\n        ${u} sourceLocA = coords;\n        --${l[i-1]};\n        ${u} sourceLocB = coords;\n        --${l[i-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),h="."+p[d-1],f=p.map((e=>"int "+e)),m=dm("sourceLocR",d-1).concat("inIdx.r"),g=dm("sourceLocG",d-1).concat("inIdx.g"),y=dm("sourceLocB",d-1).concat("inIdx.b"),x=dm("sourceLocA",d-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",v=a?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${x.join()})));`,k=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,w=a?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${l[i-1]} < ${o[i-1]-1};\n        bool hasNextRow = ${l[i-2]} < ${o[i-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${k};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${k};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function wg(e,t,n,a=null){let r=t.shape[0],s=t.shape[1];null!=a&&(r=a.shape[0],s=a.shape[1]);const o=Mi(s),i={windowSize:o,inSize:s,batchSize:r,outSize:Math.ceil(s/o)},u=new vg(i,n,null==a),l=[t];null!=a&&l.push(a);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const d=wg(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function Ig(e,t,n,a=null){const r=null!=a?a.shape:t.shape,s=Mi(r[r.length-1]),o=new kg(r,s,n,null==a),i=null==a?[t]:[t,a],u=e.runWebGLProgram(o,i,"int32");if(u.shape.length===t.shape.length){const a=Ig(e,t,n,u);return e.disposeIntermediateTensorInfo(u),a}return u}function Ng(e,t,n,a){const r=[n];if(Eo("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!he().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],[s,o]=Co(t.shape,r),i=P(o),u=jm({inputs:{x:t},backend:e,attrs:{shape:[-1,i]}});n.push(u);const l=wg(e,u,a);n.push(l);const c=jm({inputs:{x:l},backend:e,attrs:{shape:s}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),c}return Ig(e,t,a)}const $g={kernelName:$e,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=H(s,r.shape);const i=So(o,r.shape.length);let u=r;const l=[];null!=i&&(u=ng({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(u),o=Ao(o.length,u.shape.length)),Eo("argMax",[o[0]],u.shape.length);const c=Ng(n,u,o[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},Cg={kernelName:Ce,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=H(s,r.shape);const i=So(o,r.shape.length);let u=r;const l=[];null!=i&&(u=ng({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(u),o=Ao(o.length,u.shape.length)),Eo("argMin",[o[0]],u.shape.length);const c=Ng(n,u,o[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},Tg=Pm({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Eg={kernelName:Te,backendName:"webgl",kernelFunc:Tg},Sg=Pm({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),Rg={kernelName:Ee,backendName:"webgl",kernelFunc:Sg},Ag=Pm({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),Fg={kernelName:Se,backendName:"webgl",kernelFunc:Ag},_g=Bm({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Og={kernelName:Ae,backendName:"webgl",kernelFunc:_g},Dg=Pm({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Mg={kernelName:Re,backendName:"webgl",kernelFunc:Dg};class Lg{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${i});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${a?r?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / count");const b=4*Math.floor(s/4),v=s%4,k=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${b}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${k}\n          }\n\n          int xC = xCCorner + ${b};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${k}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class Pg{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const x="avg"===t;let b="0.0";if(x||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${i}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / count");const k=4*Math.floor(s/4),w=s%4,I=`\n      if (${x}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${i}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${k}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${I}\n            }\n\n            int xC = xCCorner + ${k};\n            if (${1===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${2===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${3===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${I}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}}const Bg={kernelName:Fe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;wp(r,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=a;O(Ni(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const l=fi(r.shape,s,o,1,i,u);if(1===l.filterWidth&&1===l.filterHeight&&B(l.inShape,l.outShape))return Em({inputs:{x:r},backend:n});const c=new Lg(l,"avg",!1);return n.runWebGLProgram(c,[r],"float32")}},Vg={kernelName:Oe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=a,c=mi(r.shape,s,o,[1,1,1],i,u,l),d=new Pg(c,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}};class Wg{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=i-1-e.padInfo.top,c=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zg{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=p-1-e.padInfo.left,g=1/(t*n*a);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Ug={kernelName:De,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=a,d=mi(o.shape,i,u,[1,1,1],l,c),p=new zg(d);return n.runWebGLProgram(p,[r],o.dtype)}},Gg={kernelName:_e,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s;wp([r,s],"avgPoolGrad");const{filterSize:i,strides:u,pad:l}=a,c=fi(o.shape,i,u,1,l),d=new Wg(c);return n.runWebGLProgram(d,[r],o.dtype)}},Hg={kernelName:Me,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;return rg({a:r,b:s,transposeA:o,transposeB:i,backend:n})}};class jg{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],go(e,t),go(e,n);let o="0.0";null!=a&&(go(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=r&&(go(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Kg{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],go(e,t),go(e,n);let o="vec4(0.0)";null!=a&&(go(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(go(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Xg={kernelName:kt,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,mean:r,variance:s,offset:o,scale:i}=e;O(r.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),O(null==o||r.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),O(null==i||r.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[a,r,s];let c=null;null!=o&&(c=o.shape,l.push(o));let d=null;null!=i&&(d=i.shape,l.push(i));const p=he().getBool("WEBGL_PACK_NORMALIZATION")?new Kg(a.shape,r.shape,s.shape,c,d,u):new jg(a.shape,r.shape,s.shape,c,d,u);return t.runWebGLProgram(p,l,l[0].dtype)}};class qg{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Qp(this.rank),n=`uniform int start[${this.rank}];`,a=function(e){if(1===e)return"sourceLoc";if(e<=6)return Yg.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${Yg[t]} = start[${t}] + coords.${Yg[t]};`)).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${r}\n        setOutput(getSource(${a}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const Yg=["x","y","z","w","u","v"];class Qg{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=Qp(this.rank),n=dm("coords",this.rank),a=dm("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${a.slice(-2).join()})`,s=`getChannel(getSource(${a.join()}), ${r})`,o=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${a[this.rank-1]};\n        result.y = ${s};\n        --${a[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${a[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${a[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${a[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${o}\n        ${i}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}function Zg(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:o}=a,[i,u]=ms(r,s,o);if(ts(r,i,u),0===P(u))return n.makeTensorInfo(u,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=am(e.values,i,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,t)}const{isPacked:l}=n.texData.get(r.dataId),c=hs(r.shape,i,u);if(l||!c){const e=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qg(u):new qg(u),t=e.getCustomSetupFunc(i);return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){const r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),o=a.texData.get(s.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=fs(t,ne(e.shape));r.slice&&(i+=r.slice.flatOffset),o.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const u=a.dataRefCount.get(o.slice.origDataId)||1;return a.dataRefCount.set(o.slice.origDataId,u+1),s}(r,i,u,n)}const Jg={kernelName:Fn,backendName:"webgl",kernelFunc:Zg},ey={kernelName:Le,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a;O(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),u=Pi(r.shape,s,i),l=Bi(u.length,s.length),c=Vi(r.shape,s,i),d=Wi(o,s.length),p=zi(c,o,s.length),h=[],f=jm({inputs:{x:r},backend:n,attrs:{shape:u}}),m=ng({inputs:{x:f},backend:n,attrs:{perm:l}}),g=jm({inputs:{x:m},backend:n,attrs:{shape:c}}),y=Zg({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return h.push(f),h.push(m),h.push(g),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},ty={kernelName:Pe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o}=a,i=n.readSync(r.dataId),u=n.readSync(s.dataId),l=Mf(i,u,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,l)}},ny=Bm({opSnippet:"return float(a != b);",dtype:"bool"}),ay={kernelName:rn,backendName:"webgl",kernelFunc:ny};function ry(e){const{inputs:t,backend:n}=e,{input:a}=t;return Em({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const sy={kernelName:yn,backendName:"webgl",kernelFunc:ry},oy={kernelName:Be,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return Em({inputs:{x:s},backend:a});const t=Os(s.shape),n=e({inputs:{x:s},backend:a,attrs:{dtype:"float32"}}),r=Rm({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===s.dtype){const t=ry({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:o}});return a.disposeIntermediateTensorInfo(t),n}if(!q(s.dtype,o)){const e=Em({inputs:{x:s},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:o}}if("int32"===o)return function(e,t){const n=new xm(e.shape,"return float(int(x));"),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(s,a);if("bool"===o){const e=a.makeTensorInfo([],"bool",K("bool",1)),t=ny({inputs:{a:s,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},iy="return ceil(x);",uy=Pm({opSnippet:iy,packedOpSnippet:iy,cpuKernelImpl:Pf}),ly={kernelName:Ve,backendName:"webgl",kernelFunc:uy};class cy{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,a)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(a,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(a,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class dy{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,a)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(a,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(a,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}const py={kernelName:We,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:o}=a;let i;i=he().getBool("WEBGL_PACK_CLIP")?new dy(r.shape):new cy(r.shape);const u=i.getCustomSetupFunc(s,o);return n.runWebGLProgram(i,[r],r.dtype,u)}};class hy{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function fy(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const my={kernelName:Ue,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new hy(a.shape),o=[fy(a,r.complexTensorInfos.real),fy(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};class gy{constructor(e){this.outputShape=[],this.outputShape=pi(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const a=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${a}));`)}const a=t.length,r=t[t.length-1];n.push(`else setOutput(getT${a}(yR, yC-${r}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class yy{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=pi(e,t);const n=this.outputShape,a=n.length,r=Qp(a),s=dm("coords",a),o=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,t)=>`T${t}`));const i=new Array(e.length-1);i[0]=e[0][t];for(let n=1;n<i.length;n++)i[n]=i[n-1]+e[n][t];const u=o[t],l=o.slice(-2),c=o.join();let d=`if (${u} < ${i[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let e=1;e<i.length;e++){const t=i[e-1];d+=`\n        if (${u} < ${i[e]}  && ${u} >= ${i[e-1]}) {\n          return getChannel(\n            getT${e}(${xy(o,u,t)}),\n            vec2(${xy(l,u,t)}));\n        }`}const p=i.length,h=i[i.length-1];d+=`\n        return getChannel(\n          getT${p}(${xy(o,u,h)}),\n          vec2(${xy(l,u,h)}));`,this.userCode=`\n      float getValue(${o.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[a-1]} = ${s[a-1]} + 1;\n        if (${s[a-1]} < ${n[a-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[a-2]} = ${s[a-2]} + 1;\n        if (${s[a-2]} < ${n[a-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[a-1]} = ${s[a-1]} - 1;\n        if (${s[a-2]} < ${n[a-2]} &&\n            ${s[a-1]} < ${n[a-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function xy(e,t,n){const a=e.indexOf(t);return e.map(((e,t)=>t===a?`${e} - ${n}`:e)).join()}function by(e){const{inputs:t,backend:n}=e,{input:a}=t;return Em({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const vy={kernelName:Et,backendName:"webgl",kernelFunc:by};function ky(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>ry({inputs:{input:e},backend:n}))),r=e.map((e=>by({inputs:{input:e},backend:n}))),s=ky(a,t,n),o=ky(r,t,n),i=Rm({inputs:{real:s,imag:o},backend:n});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}if("string"===a){const{tensors2D:r,outShape:s}=wy(e,t,n),o=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=1===r[0].shape[0],u=Bf(o,s,a,i),l=pi(e.map((e=>e.shape)),t),c=n.makeTensorInfo(l,a,u);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}if(e.length>he().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const a=Math.floor(e.length/2),r=ky(e.slice(0,a),t,n),s=ky(e.slice(a),t,n),o=ky([r,s],t,n);return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}if(he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const r=new yy(e.map((e=>e.shape)),t);return n.runWebGLProgram(r,e,a)}const{tensors2D:r,outShape:s}=wy(e,t,n),o=new gy(r.map((e=>e.shape))),i=n.runWebGLProgram(o,r,a);r.forEach((e=>n.disposeIntermediateTensorInfo(e)));const u=jm({inputs:{x:i},attrs:{shape:s},backend:n});return n.disposeIntermediateTensorInfo(i),u}function wy(e,t,n){const a=pi(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>jm({inputs:{x:e},attrs:{shape:[-1,P(e.shape.slice(t))]},backend:n}))),outShape:a}}function Iy(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=H(r,t[0].shape)[0],o=pi(t.map((e=>e.shape)),s);if(0===P(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>P(e.shape)>0));return 1===i.length?Em({inputs:{x:i[0]},backend:n}):(di(i.map((e=>e.shape)),s),ky(i,s,n))}const Ny={kernelName:Ge,backendName:"webgl",kernelFunc:Iy};class $y{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,x=m?3:1;let b="",v="";n&&(b=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${i}, ${u});\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${x}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${k}\n        ${v}\n        setOutput(result);\n      }\n    `}}class Cy{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${s}, ${o});\n      const ivec3 pads = ivec3(${t}, ${n}, ${a});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ty{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:a,inChannels:r,strideWidth:s,strideHeight:o,padInfo:i,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:d}=n,{left:p,top:h}=i,f=r*a,m=Np(),g="channelsLast"===d,y=g?0:1,x=g?1:2;let b="";for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)b+=`\n          blockIndex = rc.y + ${a};\n          pos = rc.x + ${n};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${o} - ${h};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${s}. - ${p}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${f}.) / ${r}.));\n\n              if(d1 < ${t[x]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${r}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*n+a}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*n+a}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${b}\n\n        ${m.output} = result;\n      }\n    `}}function Ey({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const u=e.shape,l=a.texData.get(e.dataId),c=n.inChannels,d=u[0]*u[1]*u[2],p=n.outChannels,h="channelsLast"===n.dataFormat;let f;const m=[],g=(1===d||1===p)&&c>1e3,y=u[2]%2!=0&&!!l.isPacked;if(!g&&he().getBool("WEBGL_LAZILY_UNPACK")&&he().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&y){const c=h?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),d={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},p=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,O(gp(l.shape,d.shape),(()=>`packed reshape ${l.shape} to ${d.shape} isn't free`));const g=jm({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(g);const y=rg({a:d,b:g,backend:a,transposeA:!1,transposeB:!1,bias:r,activation:i,preluActivationWeights:s,leakyreluAlpha:o}),x=a.texData.get(y.dataId);O(x.isPacked,(()=>"batchMatMul result is expected to be packed")),l.shape=p,x.shape=n.outShape,f=Em({inputs:{x:y},backend:a}),f.shape=n.outShape,m.push(y)}else{const l=jm({inputs:{x:e},backend:a,attrs:{shape:[1,h?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),c=jm({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=rg({a:l,b:c,transposeA:!1,transposeB:!1,backend:a,bias:r,activation:i,preluActivationWeights:s,leakyreluAlpha:o});f=jm({inputs:{x:d},backend:a,attrs:{shape:n.outShape}}),m.push(l),m.push(c),m.push(d)}for(const e of m)a.disposeIntermediateTensorInfo(e);return f}function Sy({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:d,outHeight:p,dataFormat:h}=n,f="channelsLast"===h,m=u*l*c,g=p*d,y=[m,g],x=[],b=jm({inputs:{x:e},backend:a,attrs:{shape:e.shape.slice(1)}}),v=jm({inputs:{x:t},backend:a,attrs:{shape:[1,m,P(t.shape)/m]}});x.push(b),x.push(v);const k=new Ty(y,b.shape,n),w=a.runWebGLProgram(k,[b],"float32"),I=jm({inputs:{x:w},backend:a,attrs:{shape:[1,y[0],y[1]]}});x.push(w),x.push(I);const N=null!=r,$=null!=s,C="leakyrelu"===i,T=i?Vm(i,!0):null,E=new Wm(I.shape,v.shape,[1,g,n.outChannels],!0,!1,N,T,$,C),S=[I,v];if(r&&S.push(r),$&&S.push(s),C){const e=a.makeTensorInfo([],"float32",ya(o,"float32"));S.push(e),x.push(e)}const R=a.runWebGLProgram(E,S,"float32"),A=jm({inputs:{x:R},backend:a,attrs:{shape:f?[1,p,d,n.outChannels]:[1,n.outChannels,p,d]}});x.push(R);for(const e of x)a.disposeIntermediateTensorInfo(e);return A}const Ry={kernelName:He,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:c}=a,d=$i(u),p=gi(r.shape,s.shape,o,l,i,c,!1,d);let h;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(he().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])h=Sy({x:r,filter:s,convInfo:p,backend:n});else{const e=new $y(p);h=n.runWebGLProgram(e,[r,s],"float32")}else h=Ey({x:r,filter:s,convInfo:p,backend:n});const f=jm({inputs:{x:h},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(h),f}};class Ay{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Fy{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s="channelsLast"===e.dataFormat,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=s?1:2,l=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _y{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,o=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${r};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${a} - ${o};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Oy{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${a}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${a} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Dy={kernelName:je,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:c}=a,d=$i(u),p=gi(r.shape,c,o,1,i,l,!1,d),h=new Ay(p);return n.runWebGLProgram(h,[r,s],"float32")}},My={kernelName:Ke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=a,d=$i(l),p=gi(o,s.shape,i,1,u,c,!1,d),h=new Fy(p);return n.runWebGLProgram(h,[r,s],"float32")}},Ly={kernelName:Xe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:u}=a,l=yi(r.shape,s.shape,o,u,i),c=new Cy(l);return n.runWebGLProgram(c,[r,s],"float32")}},Py={kernelName:qe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,filterShape:u}=a,l=yi(r.shape,u,o,1,i),c=new _y(l);return n.runWebGLProgram(c,[r,s],"float32")}},By={kernelName:Ye,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:o,strides:i,inputShape:u}=a,l=yi(u,s.shape,i,1,o),c=new Oy(l);return n.runWebGLProgram(c,[r,s],"float32")}},Vy=Pm({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),Wy={kernelName:Qe,backendName:"webgl",kernelFunc:Vy},zy=Pm({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Uy={kernelName:Ze,backendName:"webgl",kernelFunc:zy};class Gy{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,u]=e,[l]=t,[c,d]=n;this.outputShape=[l,c,d,u];const p="bilinear"===a?1:0,[h,f]=[o-1+".0",i-1+".0"],[m,g,y]=c>1?[""+(o-1)/(c-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[x,b,v]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${x});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${b};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Hy={kernelName:et,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=a,c=new Gy(r.shape,s.shape,i,u,l);return n.runWebGLProgram(c,[r,s,o],"float32")}};class jy{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const a=e.length,r=t?"0.0":`getX(${Ky(a,"coords")})`,s=e[e.length-1];let o="",i="";t?(o=n?"end != "+(s-1):"end != 0",i=n?"end + 1":"end - 1"):(o=n?`end + pow2 < ${s}`:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${Qp(a)} coords = getOutputCoords();\n        int end = ${Xy(a,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${i};\n          ${Xy(a,"coords")} = idx;\n          val += getX(${Ky(a,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function Ky(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function Xy(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const qy={kernelName:Je,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a,u=r.shape.length,l=So([s],u);let c=r;null!=l&&(c=ng({inputs:{x:r},backend:n,attrs:{perm:l}}));const d=Ao(1,u)[0];if(d!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${s}`);const p=c.shape[d];let h=Em({inputs:{x:c},backend:n});for(let e=0;e<=Math.ceil(Math.log2(p))-1;e++){const t=new jy(c.shape,!1,i),a=t.getCustomSetupFunc(e),r=h;h=n.runWebGLProgram(t,[h],h.dtype,a),n.disposeIntermediateTensorInfo(r)}if(o){const e=new jy(c.shape,o,i),t=h;h=n.runWebGLProgram(e,[h],h.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=l){const e=ng({inputs:{x:h},backend:n,attrs:{perm:Ro(l)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),e}return h}},Yy={kernelName:tt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o,binaryOutput:i}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(s.dataId),a=Mf(e,t,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(s),a=Lf(e,t,o,i);return n.makeTensorInfo(a.shape,s.dtype,a.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class Qy{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Zy={kernelName:nt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:o}=a;O(s>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${s}`));const i=r.shape[0],u="NHWC"===o?r.shape[1]:r.shape[2],l="NHWC"===o?r.shape[2]:r.shape[3],c="NHWC"===o?r.shape[3]:r.shape[1],d=u*s,p=l*s,h=c/(s*s),f=new Qy("NHWC"===o?[i,d,p,h]:[i,h,d,p],s,o);return n.runWebGLProgram(f,[r],r.dtype)}};class Jy{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.inHeight,o=e.inWidth,i=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,m=e.outChannels/e.inChannels;let g="",y="";n&&(g=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${i}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${d};\n\n          if (xR < 0 || xR >= ${s}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${o}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${y}\n        setOutput(result);\n      }\n    `}}class ex{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const s=e.inHeight,o=e.inWidth,i=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,m=f;let g="int xR; int xC; int xCOffset;";for(let e=0;e<h;e++)for(let t=0;t<f;t++)g+=`\n          vec4 xTexelR${e}C${2*t} = vec4(0.);\n          vec4 wR${e}C${t} = vec4(0.);\n          vec4 xR${e}C${t} = vec4(0.);`;for(let e=0;e<h;e++)for(let t=0;t<m;t++){const n=2*t;if(g+=`\n          xR = xRCorner + ${e*d};\n          xC = xCCorner + ${n*p};\n        `,1===c){if(n<f&&(g+=u%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    xTexelR${e}C${n}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${s} && xCOffset >= 0 && xCOffset < ${o}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${e}C${n} = vec4(previous.zw, xTexelR${e}C${n}.xy);\n                } else {\n                  xR${e}C${n} = vec4(0, 0, xTexelR${e}C${n}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${s} && xC >= 0 && xC < ${o}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xR${e}C${n} = xTexelR${e}C${n};\n              `,n+1<f)){const t=u%2==0?_(p):p;p%2==0&&u%2==1||p%2!=0&&u%2!=1?(g+=`\n                  xCOffset = xC + ${u%2} + ${t};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,p>1&&(g+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${s} &&\n                      xCOffset >= 0 && xCOffset < ${o}) {\n                      xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${e}C${n} = vec4(0.);\n                    }\n                  `),g+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.xy);\n                `):g+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${s} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${e}C${n+1} = xTexelR${e}C${n+2};\n                `}}else n<f&&(g+=`\n              if(xR >= 0 && xR < ${s}) {\n            `,u%2==1?(g+=`\n                xCOffset = xC + 1 - ${c};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n              `,n+1<f&&(g+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${c};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${e}C${n+1} = vec4(xTexelR${e}C${n+2}.xy, final.xy);\n                `)):(g+=`\n                if(xC >= 0 && xC < ${o}) {\n                  xTexelR${e}C${n} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${e}C${n} = vec4(0.);\n                }\n\n                xCOffset = xC + ${c};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${e}C${n+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${e}C${n+2} = vec4(0.);\n                }\n\n                xR${e}C${n} = vec4(\n                  xTexelR${e}C${n}.xy, xTexelR${e}C${n+2}.xy);\n              `,n+1<f&&(g+=`\n                  xR${e}C${n+1} = vec4(\n                    xTexelR${e}C${n}.zw, xTexelR${e}C${n+2}.zw);\n                `)),g+="}");n<f&&(g+=`\n            vec4 wTexelR${e}C${n} = getW(${e}, ${n}, d1, q);\n            wR${e}C${n} = vec4(wTexelR${e}C${n}.xz, wTexelR${e}C${n}.xz);\n          `,n+1<f&&(g+=`\n              vec4 wTexelR${e}C${n+1} = getW(${e}, ${n+1}, d1, q);\n              wR${e}C${n+1} =\n                vec4(wTexelR${e}C${n+1}.xz, wTexelR${e}C${n+1}.xz);`))}for(let e=0;e<h;e++)for(let t=0;t<f;t++)g+=`dotProd += xR${e}C${t} * wR${e}C${t};`;let y="",x="";n&&(y=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,x="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${i}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${g}\n\n        vec4 result = dotProd;\n        ${b}\n        ${x}\n        setOutput(result);\n      }\n    `}}const tx={kernelName:at,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=a;let c=u;null==c&&(c=[1,1]),O(Ni(o,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`));const d=gi(r.shape,s.shape,o,c,i,l,!0);let p;return p=he().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new ex(d):new Jy(d),n.runWebGLProgram(p,[r,s],"float32")}};class nx{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ax{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const rx={kernelName:rt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:c}=a,d=gi(r.shape,c,o,i,u,l,!0),p=new nx(d);return n.runWebGLProgram(p,[r,s],"float32")}},sx={kernelName:st,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:c}=a,d=gi(c,s.shape,o,i,u,l,!0),p=new ax(d);return n.runWebGLProgram(p,[r,s],"float32")}};class ox{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const ix={kernelName:ot,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=P(a.shape),o=jm({inputs:{x:a},backend:n,attrs:{shape:[s]}}),i=new ox(s),u=n.runWebGLProgram(i,[o],o.dtype),l=jm({inputs:{x:u},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}};class ux{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:u,dilationWidth:l}=e,{top:c,left:d}=a;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${i}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const lx={kernelName:it,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:u}=a,l=hi(r.shape,s.shape,o,i,"NHWC",u);let c;const d=new ux(l);c=n.runWebGLProgram(d,[r,s],"float32");const p=jm({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),p}},cx=Pm({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),dx={kernelName:lt,backendName:"webgl",kernelFunc:cx},px={kernelName:ct,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=he().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tm("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new Cm("return (b >= 1.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)}},hx=Bm({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"}),fx={kernelName:pt,backendName:"webgl",kernelFunc:hx},mx=Pm({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${qi};\n  float a1 = ${Yi};\n  float a2 = ${Qi};\n  float a3 = ${Zi};\n  float a4 = ${Ji};\n  float a5 = ${eu};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),gx={kernelName:dt,backendName:"webgl",kernelFunc:mx},yx="return exp(x);",xx=Pm({opSnippet:yx,packedOpSnippet:yx,cpuKernelImpl:Vf}),bx={kernelName:ht,backendName:"webgl",kernelFunc:xx};function vx(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,o=s.shape.length,i=s.shape.slice();let u=r;return r<0&&(O(-(o+1)<=r,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),u=o+r+1),i.splice(u,0,1),jm({inputs:{x:s},backend:a,attrs:{shape:i}})}const kx={kernelName:ft,backendName:"webgl",kernelFunc:vx},wx="return exp(x) - 1.0;",Ix=Pm({opSnippet:wx,packedOpSnippet:wx,cpuKernelImpl:Wf}),Nx={kernelName:mt,backendName:"webgl",kernelFunc:Ix};class $x{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${a}.0`:"1.0";let o;if("real"===e)o="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${a});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${a}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Cx(e,t,n){const a=n.texData.get(e.dataId),r=P(e.shape),s=e.shape[e.shape.length-1],o=jm({inputs:{x:e},backend:n,attrs:{shape:[r/s,s]}}),i=o.shape,u=new $x("real",i,t),l=new $x("imag",i,t),c=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],d=n.runWebGLProgram(u,c,"float32"),p=n.runWebGLProgram(l,c,"float32"),h=Rm({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);const f=jm({inputs:{x:h},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(h),f}const Tx={kernelName:gt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Cx(a,!1,n)}};class Ex{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}function Sx(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:s}=n;if(s=s||J(r),"string"===s){const e=X(s,P(a));return e.fill(r),t.makeTensorInfo(a,s,e)}{const e=new Ex(a,r),n=e.getCustomSetupFunc(r);return t.runWebGLProgram(e,[],s,n)}}const Rx={kernelName:yt,backendName:"webgl",kernelFunc:Sx};class Ax{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Fx={kernelName:xt,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,a=t,r=new Ax(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}},_x="return floor(x);",Ox=Pm({opSnippet:_x,packedOpSnippet:_x,cpuKernelImpl:zf}),Dx={kernelName:bt,backendName:"webgl",kernelFunc:Ox},Mx=Bm({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Lx={kernelName:vt,backendName:"webgl",kernelFunc:Mx};class Px{constructor(e){this.variableNames=["A"];const t=Np(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Bx{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Np(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${a}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const Vx={kernelName:sa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:s}=a,o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[u,l]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[l,u],d=[l,u,s];(i||o)&&(null==Wx&&(Wx=document.createElement("canvas").getContext("2d")),Wx.canvas.width=u,Wx.canvas.height=l,Wx.drawImage(r,0,0,u,l),r=Wx.canvas);const p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=qd.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),r);const h=he().getBool("WEBGL_PACK")?new Bx(d):new Px(d),f=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),f}};let Wx;const zx={kernelName:ua,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=a,m=$i(c),g=gi(r.shape,s.shape,u,d,l,p,!1,m);let y;const x=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(he().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])y=Sy({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else{const e=null!=o,t=null!=i,a="leakyrelu"===h,u=h?Vm(h,!1):null,l=new $y(g,e,u,t,a),c=[r,s];if(o&&c.push(o),i&&c.push(i),a){const e=n.makeTensorInfo([],"float32",ya(f,"float32"));c.push(e),x.push(e)}y=n.runWebGLProgram(l,c,"float32")}else y=Ey({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});const b=jm({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return x.push(y),x.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},Ux={kernelName:la,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:h}=a,f=[];let m=c;null==m&&(m=[1,1]),O(Ni(u,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`));const g=gi(r.shape,s.shape,u,m,l,d,!0),y=he().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,x=p?Vm(p,y):null,b=[r,s],v=null!=o,k=null!=i,w="leakyrelu"===p;if(v&&b.push(o),k&&b.push(i),w){const e=n.makeTensorInfo([],"float32",ya(h,"float32"));b.push(e),f.push(e)}let I;I=y?new ex(g,v,x,k,w):new Jy(g,v,x,k,w);const N=n.runWebGLProgram(I,b,"float32");return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class Gx{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const a=Qp(t.length),r=Qp(n.length),s=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${a} strides = ${a}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${s};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const Hx={kernelName:It,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,o=s[s.length-1],[i,u,l,c]=Ui(a,r),d=jm({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),p=jm({inputs:{x:a},backend:n,attrs:{shape:[P(a.shape)/l,l]}}),h=new Gx(o,c,[u,l]),f=n.runWebGLProgram(h,[p,d],p.dtype),m=jm({inputs:{x:f},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};class jx{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Qp(this.rank),a=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let t=0;t<e.length;t++)2===t?a.push("int(getIndices(resRC.x, resRC.z))"):a.push(`${n[t]}`);return a.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}const Kx={kernelName:wt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:o,batchDims:i}=a,u=fu(r,s,H(o,r.shape)[0],i),l=P(s.shape),c=[],d=jm({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=jm({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,l/u.batchSize]}});c.push(d),c.push(p);const h=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),a=Uf(t,e,h);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,a.dtype,a.values)}const f=new jx(d.shape,h),m=n.runWebGLProgram(f,[d,p],d.dtype);c.push(m);const g=jm({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}},Xx=Bm({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Gf,dtype:"bool"}),qx={kernelName:Nt,backendName:"webgl",kernelFunc:Xx},Yx=Bm({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"}),Qx={kernelName:$t,backendName:"webgl",kernelFunc:Yx},Zx={kernelName:Tt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Cx(a,!0,n)}},Jx={kernelName:St,backendName:"webgl",kernelFunc:Pm({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"})},eb={kernelName:Rt,backendName:"webgl",kernelFunc:Pm({opSnippet:"return float(isinf(x));",dtype:"bool"})},tb={kernelName:At,backendName:"webgl",kernelFunc:Pm({opSnippet:"return float(isnan(x));",dtype:"bool"})},nb=Bm({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Hf,dtype:"bool"}),ab={kernelName:_t,backendName:"webgl",kernelFunc:nb},rb=Bm({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"}),sb={kernelName:Ot,backendName:"webgl",kernelFunc:rb},ob={kernelName:Dt,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,o=jf(a,r,s);return t.makeTensorInfo([o.length],"float32",o)}},ib=Pm({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Kf}),ub={kernelName:Mt,backendName:"webgl",kernelFunc:ib},lb=Pm({opSnippet:"return log(1.0 + x);"}),cb={kernelName:Lt,backendName:"webgl",kernelFunc:lb},db=Bm({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),pb={kernelName:Pt,backendName:"webgl",kernelFunc:db},hb=Pm({opSnippet:"return float(!(x >= 1.0));"}),fb={kernelName:Bt,backendName:"webgl",kernelFunc:hb},mb=Bm({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),gb={kernelName:Vt,backendName:"webgl",kernelFunc:mb};class yb{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const s=t,o=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${a}) * sum`;i=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class xb{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,o=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${a}) * sum`;i=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}const bb={kernelName:Wt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:o,alpha:i,beta:u}=a,l=he().getBool("WEBGL_PACK_NORMALIZATION")?new xb(r.shape,s,o,i,u):new yb(r.shape,s,o,i,u);return n.runWebGLProgram(l,[r],r.dtype)}};class vb{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${a}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${a})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const kb={kernelName:zt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:o}=t,{depthRadius:i,bias:u,alpha:l,beta:c}=a,d=new vb(r.shape,i,u,l,c);return n.runWebGLProgram(d,[r,s,o],r.dtype)}};function wb(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:o}=a,i=r.shape.length,u=H(s,r.shape);let l=u;const c=So(l,i),d=null!=c,p=n.shouldExecuteOnCPU([r]);let h=r;if(d){if(p){const e=n.texData.get(h.dataId).values,t=new Array(i);for(let e=0;e<t.length;e++)t[e]=r.shape[c[e]];const a=um(e,r.shape,r.dtype,c,t);h=n.makeTensorInfo(t,r.dtype),n.texData.get(h.dataId).values=a}else h=Jm(r,c,n);l=Ao(l.length,i)}Eo("max",l,i);const[f,m]=Co(h.shape,l);let g,y=f;if(o&&(y=To(f,u)),p){const e=n.texData.get(h.dataId).values,t=Xf(e,P(m),y,r.dtype);g=n.makeTensorInfo(y,r.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,a){const r=P(t),s=jm({inputs:{x:e},attrs:{shape:[P(e.shape)/r,r]},backend:a}),o=Ym(s,e.dtype,"max",a),i=jm({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}(h,m,y,n);return d&&n.disposeIntermediateTensorInfo(h),g}const Ib={kernelName:Ut,backendName:"webgl",kernelFunc:wb},Nb=Bm({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:qf}),$b={kernelName:Gt,backendName:"webgl",kernelFunc:Nb},Cb={kernelName:Ht,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;wp(r,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=a;O(Ni(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const l=fi(r.shape,s,o,1,i,u);if(1===l.filterWidth&&1===l.filterHeight&&B(l.inShape,l.outShape))return Em({inputs:{x:r},backend:n});const c=new Lg(l,"max",!1);return n.runWebGLProgram(c,[r],r.dtype)}},Tb={kernelName:Kt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dataFormat:u,dimRoundingMode:l}=a,c=mi(r.shape,s,o,[1,1,1],i,l,u),d=new Pg(c,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}};class Eb{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,o=r-1-e.padInfo.top,i=s-1-e.padInfo.left,u=r*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Sb{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=i-1-e.padInfo.front,d=u-1-e.padInfo.top,p=l-1-e.padInfo.left,h=i*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Rb={kernelName:Xt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=a,d=mi(o.shape,i,u,[1,1,1],l,c),p=new Pg(d,"max",!0),h=n.runWebGLProgram(p,[o],o.dtype),f=new Sb(d),m=n.runWebGLProgram(f,[r,h],o.dtype);return n.disposeIntermediateTensorInfo(h),m}},Ab={kernelName:jt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:o}=t,i=s;wp([s,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=a,p=fi(i.shape,u,l,1,c,d),h=new Lg(p,"max",!0),f=n.runWebGLProgram(h,[i],i.dtype),m=new Eb(p),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}},Fb={kernelName:qt,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{filterSize:r,strides:s,pad:o,includeBatchInIndex:i}=t,u=n;O(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));const l=[1,1];O(Ni(s,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`));const c=fi(a.shape,r,s,l,o),[d,p]=function(e,t,n,a){let r=new Lg(n,"max",!1);const s=a.runWebGLProgram(r,[e],"float32");return r=new Lg(n,"max",!0,!0,t),[s,a.runWebGLProgram(r,[e],"float32")]}(a,i,c,u);return[d,p]}},_b={kernelName:Yt,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{keepDims:r,axis:s}=t,o=n,i=a.shape.length,u=H(s,a.shape);let l=u;const c=So(l,i),d=null!=c,p=o.shouldExecuteOnCPU([a]),h=[];let f=a;if(d){if(p){const e=o.texData.get(f.dataId).values,t=new Array(i);for(let e=0;e<t.length;e++)t[e]=a.shape[c[e]];const n=um(e,a.shape,a.dtype,c,t);f=o.makeTensorInfo(t,a.dtype),o.texData.get(f.dataId).values=n}else f=Jm(a,c,o);h.push(f),l=Ao(l.length,i)}Eo("sum",l,i);const[m,g]=Co(f.shape,l);let y=m;r&&(y=To(m,u));const x=function(e,t,n,a){const r=P(t),s=jm({inputs:{x:e},attrs:{shape:[P(e.shape)/r,r]},backend:a}),o=Ym(s,"float32","mean",a),i=jm({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}(f,g,y,o);for(const e of h)o.disposeIntermediateTensorInfo(e);return x}},Ob={kernelName:Qt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,u=H(s,r.shape);let l=u;const c=So(l,i);let d=r;null!=c&&(d=ng({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Ao(l.length,r.shape.length)),Eo("min",l,i);const[p,h]=Co(d.shape,l),f=jm({inputs:{x:d},backend:n,attrs:{shape:[-1,P(h)]}}),m=Ym(f,f.dtype,"min",n);let g;return g=jm(o?{inputs:{x:m},backend:n,attrs:{shape:To(p,u)}}:{inputs:{x:m},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},Db=Bm({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Yf}),Mb={kernelName:Zt,backendName:"webgl",kernelFunc:Db};class Lb{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=Qp(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),u="reflect"===n?0:1;this.userCode=1!==a?`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${a}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Pb{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=Qp(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=dm("rc",a),u=dm("source",a),l=`${i[a-1]} < ${this.outputShape[a-1]}`,c=1===a?"source":`vec2(${u.slice(-2).join()})`,d="reflect"===n?0:1;let p="";if(1===a){const e=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${i[a-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${i[a-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${i[a-2]} += 1;\n        if(${i[a-2]} < ${this.outputShape[a-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${i[a-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const Bb={kernelName:Jt,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a}=e,{paddings:r,mode:s}=n,o=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pb(a.shape,r,s):new Lb(a.shape,r,s);return t.runWebGLProgram(o,[a],a.dtype)}},Vb=Bm({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Wb={kernelName:en,backendName:"webgl",kernelFunc:Vb};class zb{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}const Ub=Bm({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Gb={kernelName:ut,backendName:"webgl",kernelFunc:Ub},Hb="return a - b;",jb=Bm({opSnippet:Hb,packedOpSnippet:Hb,supportsComplex:!0,cpuKernelImpl:sm}),Kb={kernelName:Hn,backendName:"webgl",kernelFunc:jb};function Xb(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,o=H([s],r.shape),i=wb({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=To(i.shape,o),l=jm({inputs:{x:i},backend:n,attrs:{shape:u}}),c=jb({inputs:{a:r,b:l},backend:n}),d=xx({inputs:{x:c},backend:n}),p=eg({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),h=jm({inputs:{x:p},backend:n,attrs:{shape:u}}),f=Ub({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}const qb={kernelName:zn,backendName:"webgl",kernelFunc:Xb},Yb={kernelName:tn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:o,normalized:i}=a,u=i?r:Xb({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new zb(l,c,s),p=d.getCustomSetupFunc(o),h=n.runWebGLProgram(d,[u],"int32",p);return i||n.disposeIntermediateTensorInfo(u),h}},Qb="return -x;",Zb={kernelName:an,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=Zf(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=he().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new km(a.shape,Qb):new xm(a.shape,Qb),n.runWebGLProgram(r,[a],a.dtype)}},Jb=to,ev={kernelName:sn,backendName:"webgl",kernelFunc:function(e){tu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=a,l=n.readSync(r.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=Jb(l,c,o,i,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},tv=no,nv={kernelName:on,backendName:"webgl",kernelFunc:function(e){tu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=a,c=n.readSync(r.dataId),d=n.readSync(s.dataId),{selectedIndices:p,validOutputs:h}=tv(c,d,o,i,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},av=ao,rv={kernelName:un,backendName:"webgl",kernelFunc:function(e){tu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=a,c=n.readSync(r.dataId),d=n.readSync(s.dataId),p=o,h=i,f=u,m=l,{selectedIndices:g,selectedScores:y}=av(c,d,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class sv{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${a}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const ov={kernelName:cn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{depth:s,onValue:o,offValue:i}=a,u=P(r.shape),l=new sv(u,s,o,i),c=jm({inputs:{x:r},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(l,[c],r.dtype);n.disposeIntermediateTensorInfo(c);const p=jm({inputs:{x:d},backend:n,attrs:{shape:[...r.shape,s]}});return n.disposeIntermediateTensorInfo(d),p}};function iv(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=ry({inputs:{input:a},backend:n}),t=iv({inputs:{x:e},backend:n}),r=by({inputs:{input:a},backend:n}),s=iv({inputs:{x:r},backend:n}),o=Rm({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return Sx({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const uv={kernelName:aa,backendName:"webgl",kernelFunc:iv},lv={kernelName:ln,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=ry({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=by({inputs:{input:r},backend:a}),o=iv({inputs:{x:s},backend:a}),i=Rm({inputs:{real:n,imag:o},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}return Sx({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}},cv={kernelName:dn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return vx({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{D(s,e.shape,"All tensors passed to stack must have matching shapes"),O(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],u=Iy({inputs:t.map((e=>{const t=vx({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};class dv{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=Qp(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${o});\n      uniform float value;\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class pv{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=Qp(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=dm("rc",a),u=dm("source",a),l=`${i[a-1]} < ${this.outputShape[a-1]}`,c=1===a?"source":`vec2(${u.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${i[a-1]} += 1;\n       if(${l}) {\n      `,1===a?"":`}\n       rc = outputLoc;\n       ${i[a-2]} += 1;\n       if(${i[a-2]} < ${this.outputShape[a-2]}) {`,1===a?"":`  ${i[a-1]} += 1;\n         if(${l}) {`],p=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let e=0,t=1===a?2:4;e<t;e++)h+=`\n        ${d[e]}\n        if (${p}) {\n          result[${e}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;h+=1===a?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${o});\n      uniform float value;\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}const hv=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:o}=a,i=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pv(r.shape,s,o):new dv(r.shape,s,o),u=i.getCustomSetupFunc(o);return n.runWebGLProgram(i,[r],r.dtype,u)},fv={kernelName:pn,backendName:"webgl",kernelFunc:hv},mv=Bm({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),gv={kernelName:hn,backendName:"webgl",kernelFunc:mv},yv={kernelName:mn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,u=[],l=H(s,r.shape);let c=l;const d=So(c,i);let p,h=r;if(null!=d&&(h=ng({inputs:{x:r},backend:n,attrs:{perm:d}}),c=Ao(c.length,i),u.push(h)),Eo("prod",c,i),n.shouldExecuteOnCPU([h])){const e=n.texData.get(h.dataId).values,{outVals:t,outShape:a,outDtype:r}=Jf(h.shape,h.dtype,e,c);p=n.makeTensorInfo(a,r,t)}else{const[e,t]=Co(h.shape,c),a=P(t),s=jm({inputs:{x:h},backend:n,attrs:{shape:[-1,a]}}),o=Ym(s,Ua(r.dtype),"prod",n);p=jm({inputs:{x:o},backend:n,attrs:{shape:e}}),u.push(s),u.push(o)}if(o){u.push(p);const e=To(p.shape,l);p=jm({inputs:{x:p},backend:n,attrs:{shape:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},xv=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:o}=n,i=em(a,r,s,o);return t.makeTensorInfo([i.length],o,i)},bv={kernelName:gn,backendName:"webgl",kernelFunc:xv},vv=Pm({opSnippet:"return 1.0 / x;"}),kv={kernelName:xn,backendName:"webgl",kernelFunc:vv},wv=Pm({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Iv={kernelName:bn,backendName:"webgl",kernelFunc:wv},Nv=Pm({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),$v={kernelName:$n,backendName:"webgl",kernelFunc:Nv};class Cv{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,o,i,u]=e;this.outputShape=[s,t,n,u];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],c=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Tv{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,u]=e;this.outputShape=[s,t,n,u];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],c=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const Ev={kernelName:In,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a,[u,l]=i,c=he().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Tv(r.shape,u,l,s,o):new Cv(r.shape,u,l,s,o);return n.runWebGLProgram(c,[r],"float32")}};class Sv{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,o]=e,i=[n&&s>1?a-1:a,n&&o>1?r-1:r],u=[n&&s>1?s-1:s,n&&o>1?o-1:o],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Rv={kernelName:Nn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a,i=new Sv(s.shape,r.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class Av{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,o,i,u]=e;this.outputShape=[s,t,n,u];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let p;p=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}const Fv={kernelName:kn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a,[u,l]=i,c=new Av(r.shape,u,l,s,o);return n.runWebGLProgram(c,[r],r.dtype)}};class _v{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,o]=e,i=[n&&s>1?a-1:a,n&&o>1?r-1:r],u=[n&&s>1?s-1:s,n&&o>1?o-1:o],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Ov={kernelName:wn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a,i=new _v(s.shape,r.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class Dv{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(a))).join(","),r=Qp(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}class Mv{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const a=dm("rc",n),r=`${a[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${a[n-2]} + 1 < ${this.outputShape[n-2]}`,o=Qp(n);function i(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${a[n]} - 1`:`${a[n]}`}(r,n)));return`getChannel(getX(${a.join(",")}), vec2(${a.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return i(e)}(a.slice())};\n          if(${r}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(a.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice())};\n            if(${r}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Lv={kernelName:Cn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,o=r.shape.length,i=H(s,r.shape);if(0===o)return Em({inputs:{x:r},backend:n});const u=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mv(r.shape,i):new Dv(r.shape,i);return n.runWebGLProgram(u,[r],r.dtype)}};class Pv{constructor(e,t){this.variableNames=["Image"],this.outputShape=[];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(e,t,n,a){return(r,s)=>{null==this.paramsLoc&&(this.paramsLoc=r.getUniformLocationNoThrow(s,"params")),r.gl.uniform4f(this.paramsLoc,e,t,n,a)}}}const Bv={kernelName:oa,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,{radians:r,fillValue:s,center:o}=t,i=n,u=new Pv(a.shape,s),[l,c]=Li(o,a.shape[1],a.shape[2]),d=u.getCustomSetupFunc(l,c,Math.sin(r),Math.cos(r));return i.runWebGLProgram(u,[a],a.dtype,d)}},Vv=Pm({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Wv={kernelName:Tn,backendName:"webgl",kernelFunc:Vv},zv=Pm({opSnippet:"return inversesqrt(x);",cpuKernelImpl:tm}),Uv={kernelName:En,backendName:"webgl",kernelFunc:zv};class Gv{constructor(e,t,n,a,r,s,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=Qp(r.length),u=Qp(s.length);let l="";1===n?l="i":2===n&&(l="i, j");const c=`getIndices(${l})`;let d="";1===a?d="i":2===a&&(d="i, coords[1]");const p=`getUpdates(${d})`,h=t>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const Hv={kernelName:Sn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:o}=a,{sliceRank:i,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=ji(0,r,o),p=[d/l,l];if(0===d)return n.makeTensorInfo(o,r.dtype);const h=jm({inputs:{x:r},backend:n,attrs:{shape:[u,i]}}),f=jm({inputs:{x:s},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new Gv(u,i,h.shape.length,f.shape.length,c,p),y=n.runWebGLProgram(g,[f,h,m],f.dtype),x=jm({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),x}};class jv{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let a=0;a<t.length;a++)o.push(`${n[a]}`),a<e&&s.push(`${n[a]}`);a=s.join(),r=o.join()}const s=Qp(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${a});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const Kv={kernelName:Rn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,o=new jv(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[a,r,s],za(r.dtype,s.dtype))}},Xv=Pm({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Ki};\n  float scale = ${Xi};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),qv={kernelName:An,backendName:"webgl",kernelFunc:Xv},Yv=Pm({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),Qv={kernelName:Mn,backendName:"webgl",kernelFunc:Yv},Zv=Pm({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Jv={kernelName:Dn,backendName:"webgl",kernelFunc:Zv},ek=Pm({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),tk={kernelName:_n,backendName:"webgl",kernelFunc:ek},nk=Pm({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),ak={kernelName:On,backendName:"webgl",kernelFunc:nk},rk=Pm({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),sk={kernelName:Ln,backendName:"webgl",kernelFunc:rk},ok={kernelName:Vn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a;O(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),u=[[0,0]];u.push(...o);for(let e=1+s.length;e<r.shape.length;++e)u.push([0,0]);const l=[],c=hv({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),d=Pi(c.shape,s,i,!1),p=Bi(d.length,s.length,!1),h=Vi(c.shape,s,i,!1),f=jm({inputs:{x:c},backend:n,attrs:{shape:d}}),m=ng({inputs:{x:f},backend:n,attrs:{perm:p}}),g=jm({inputs:{x:m},backend:n,attrs:{shape:h}});return l.push(c),l.push(f),l.push(m),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}},ik={kernelName:jn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:i}=a,{sliceRank:u,numUpdates:l,strides:c,outputSize:d}=ji(0,r,i),p=new Gv(l,u,r.shape.length,s.shape.length,c,[d,1],!1),h=n.runWebGLProgram(p,[s,r,o],s.dtype),f=jm({inputs:{x:h},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),f}},uk={kernelName:Wn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=a,i=H(o,r.shape)[0],u=du(r,s,i),l=r.shape.length,c=new Array(l).fill(0),d=r.shape.slice();return u.map((e=>{const t=[...d];t[i]=e;const a=Zg({inputs:{x:r},backend:n,attrs:{begin:c,size:t}});return c[i]+=e,a}))}},lk=Pm({opSnippet:"return sqrt(x);"}),ck={kernelName:Pn,backendName:"webgl",kernelFunc:lk},dk={kernelName:Gn,backendName:"webgl",kernelFunc:Pm({opSnippet:"return x * x;"})},pk="return (a - b) * (a - b);",hk=Bm({opSnippet:pk,packedOpSnippet:pk}),fk={kernelName:Un,backendName:"webgl",kernelFunc:hk},mk={kernelName:ra,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:a}=e,r=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new xm(a.shape,r);return n.runWebGLProgram(s,[a],a.dtype)}};class gk{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=Qp(n.length),s=Qp(n.length);let o="";if(1===a)o="coords * strides + begin";else{let e=0;o=n.map(((t,a)=>(e++,1===n.length?`coords * strides[${a}] + begin[${a}]`:`coords[${e-1}] * strides[${a}] + begin[${a}]`))).join(",")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}const yk={kernelName:Kn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=a,{nonStrided:h,$begin:f,$strides:m,size:g,newShape:y,outShape:x}=gs(r.shape,s,o,i,u,l,c,d,p),b=jm({inputs:{x:r},backend:n,attrs:{shape:y}});let v;if(h){const e=Zg({inputs:{x:b},backend:n,attrs:{begin:f,size:g}});v=jm({inputs:{x:e},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(e)}else if(x.some((e=>0===e)))v=n.makeTensorInfo(x,r.dtype,[]);else if(n.shouldExecuteOnCPU([b])){const e=n.texData.get(b.dataId).values,t=Wr(b.shape,b.dtype,e),a=rm(x,t,m,f);v=n.makeTensorInfo(x,b.dtype,a.values)}else{const e=new gk(f,m,x);v=n.runWebGLProgram(e,[b],b.dtype)}const k=jm({inputs:{x:v},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),k}},xk=Pm({opSnippet:"return tan(x);"}),bk={kernelName:Xn,backendName:"webgl",kernelFunc:xk},vk=Pm({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),kk={kernelName:qn,backendName:"webgl",kernelFunc:vk};class wk{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const a=Qp(this.rank),r=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let t=0;t<e.length;t++)a.push(`imod(${n[t]}, ${e[t]})`);return a.join()}(e);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function Ik(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if("string"===r.dtype){const e=n.readSync(r.dataId).map((e=>ka(e))),t=Wr(r.shape,r.dtype,e),a=om(t,s);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const o=new wk(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}const Nk={kernelName:Yn,backendName:"webgl",kernelFunc:Ik},$k={kernelName:Qn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a,i=n.readSync(r.dataId),[u,l]=im(i,r.shape,r.dtype,s,o);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};class Ck{constructor(e,t,n,a,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(a){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Tk={kernelName:Zn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=a,[c,d,p,h]=r.shape,[f,m]=null!=l?l:[d,p],g=new Ck(d,p,o,i,u,[c,f,m,h]);return n.runWebGLProgram(g,[r,s],"float32")}},Ek={kernelName:ea,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;wp(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=a.readSync(s.dataId),{outputValues:i,outputShape:u,indices:l}=lm(o,r,s.shape,s.dtype);return[a.makeTensorInfo(u,s.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}},Sk={kernelName:ta,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r,i=o.shape.length,u=r.shape[s],l=new Array(i-1);let c=0;for(let e=0;e<i;e++)e!==s&&(l[c++]=o.shape[e]);const d=[],p=new Array(i).fill(0),h=o.shape.slice();h[s]=1;const f=new Array(u);for(let e=0;e<f.length;e++){p[s]=e;const t=Zg({inputs:{x:o},backend:n,attrs:{begin:p,size:h}}),a=jm({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=a,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class Rk{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,o=s*Math.ceil(r/n);this.outputShape=[a,o];const i=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let d="";r%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Ak=[bb,kb,sg,ig,lg,dg,fg,yg,xg,bg,$g,Cg,Eg,Rg,Og,Fg,Mg,Vg,Bg,Ug,Gg,Hg,Xg,ey,ty,oy,ly,py,my,Am,Ny,Dy,My,Ry,Py,By,Ly,Wy,Uy,Hy,qy,Yy,Zy,rx,sx,tx,ix,lx,dx,px,fx,gx,bx,kx,Nx,Tx,Rx,Fx,Dx,Lx,Vx,zx,Ux,Hx,Kx,qx,Qx,Sm,Zx,vy,Jx,eb,tb,Om,ab,sb,ob,cb,ub,pb,fb,gb,Ib,Tb,Cb,Rb,Ab,Fb,$b,_b,Ob,Mb,Bb,Wb,Yb,Hm,Zb,ev,nv,rv,ay,ov,lv,cv,fv,gv,Lm,yv,bv,sy,Gb,kv,$v,Iv,Km,Ev,Rv,Fv,Ov,Lv,Bv,Wv,Uv,Hv,Kv,qv,Qv,Jv,tk,ak,Jg,qb,sk,ok,ik,uk,ck,dk,fk,mk,yk,Kb,tg,bk,kk,Nk,$k,Tk,ag,Ek,Sk,{kernelName:na,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:o}=a,i=r.shape.length,u=[];let l=0;const c=So([l],i);let d=r;null!=c&&(d=ng({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(d),l=Ao(1,i)[0]);const p=hu(d.shape,l,o),h=P([d.shape[l]]),f=jm({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});u.push(f);const m=Ua(r.dtype),g=(e,t,a,r,s)=>{const o=e.shape[0],i=e.shape[1],l=pu(i,s),c=new Rk({windowSize:l,inSize:i,batchSize:o,numSegments:s},t),d=n.compileAndRun(c,[e,a],r);if(u.push(d),d.shape[1]===s)return d;const p=xv({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),h=Ik({inputs:{x:p},backend:n,attrs:{reps:[i/l]}});return u.push(p),u.push(h),g(d,t,h,r,s)},y=jm({inputs:{x:g(f,"unsortedSegmentSum",s,m,o)},backend:n,attrs:{shape:p}});let x=y;if(null!=c){u.push(y);const e=Ro(c);x=ng({inputs:{x},backend:n,attrs:{perm:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}},uv];for(const e of Ak)ma(e);const Fk=yu;class _k extends R{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new S(this,Vo())}nextDataId(){return _k.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,he().get("IS_NODE")&&tu("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&Z(n[0])){const r=n.map((e=>va(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);return"complex64"===t?au(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>ka(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Wr(e.shape,e.dtype,n)}makeOutput(e,t,n){const a=this.write(e,t,n);return Vo().makeTensorFromDataId(a,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=ba();return e(),{kernelMs:ba()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){th([e],"where");const t=this.readSync(e.dataId);return Fk(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}_k.nextDataId=0,Uo("cpu",(()=>new _k),1);const Ok=Ih(lt,(e=>e>=0?e:Math.exp(e)-1)),Dk={kernelName:lt,backendName:"cpu",kernelFunc:Ok};function Mk(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;th([r],"leakyRelu");const o=P(r.shape),i=n.data.get(r.dataId).values,u=K("float32",o);for(let e=0;e<i.length;e++)u[e]=i[e]<0?s*i[e]:i[e];return n.makeTensorInfo(r.shape,"float32",u)}const Lk={kernelName:Ft,backendName:"cpu",kernelFunc:Mk},Pk=rh(((e,t)=>e<0?t*e:e));function Bk(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;th([a,r],"prelu");const s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,[i,u]=Pk(a.shape,r.shape,s,o,a.dtype);return n.makeTensorInfo(u,a.dtype,i)}const Vk={kernelName:fn,backendName:"cpu",kernelFunc:Bk},Wk=Ih(bn,(e=>Math.max(0,e))),zk={kernelName:bn,backendName:"cpu",kernelFunc:Wk},Uk=Ih($n,(e=>Math.min(Math.max(0,e),6))),Gk={kernelName:$n,backendName:"cpu",kernelFunc:Uk};function Hk(e,t,n,a,r){if("linear"===n)return uh({inputs:{x:t},backend:e});if("relu"===n)return Wk({inputs:{x:t},backend:e});if("elu"===n)return Ok({inputs:{x:t},backend:e});if("relu6"===n)return Uk({inputs:{x:t},backend:e});if("prelu"===n)return Bk({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return Mk({inputs:{x:t},backend:e,attrs:{alpha:r}});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function jk(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,o=P(r.shape),i=G(s,o),u=P(i);O(o===u,(()=>`The new shape (${i}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const Kk={kernelName:vn,backendName:"cpu",kernelFunc:jk};function Xk(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;th([r,s],"matMul");const u=r.shape.length,l=s.shape.length,c=o?r.shape[u-2]:r.shape[u-1],d=i?s.shape[l-1]:s.shape[l-2],p=o?r.shape[u-1]:r.shape[u-2],h=i?s.shape[l-2]:s.shape[l-1],f=r.shape.slice(0,-2),m=s.shape.slice(0,-2),g=P(f),y=P(m);O(u>=2&&l>=2&&(g===y||1===g||1===y),(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`));const x=(g>y?r.shape.slice(0,-2):s.shape.slice(0,-2)).concat([p,h]);O(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`));const b=i?[y,h,d]:[y,d,h],v=jk({inputs:{x:r},backend:n,attrs:{shape:o?[g,c,p]:[g,p,c]}}),k=jk({inputs:{x:s},backend:n,attrs:{shape:b}}),w=o?v.shape[1]:v.shape[2],I=o?v.shape[2]:v.shape[1],N=i?k.shape[1]:k.shape[2],$=Math.max(g,y),C=n.data.get(v.dataId).values,T=n.data.get(k.dataId).values,E=ne(v.shape),S=ne(k.shape),[R,A,F]=o?[E[0],1,E[1]]:[E[0],E[1],1],[_,D,M]=i?[1,S[1],S[0]]:[S[1],1,S[0]],L=I*N,B=Wr([$,I,N],v.dtype),V=B.values,W=n.blockSize;for(let e=0;e<$;e++)for(let t=0;t<I;t+=W)for(let n=0;n<N;n+=W)for(let a=0;a<w;a+=W){const r=Math.min(t+W,I),s=Math.min(n+W,N),o=Math.min(a+W,w);for(let i=t;i<r;i++)for(let t=n;t<s;t++){let n=0;for(let r=a;r<o;r++){const a=Math.min(e,g-1)*R,s=Math.min(e,y-1)*M;n+=C[a+i*A+r*F]*T[r*_+t*D+s]}V[e*L+(i*N+t)]+=n}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(x,B.dtype,B.values)}const qk={kernelName:Me,backendName:"cpu",kernelFunc:Xk},Yk={kernelName:ia,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=a;let p,h,f;const m=[];p=Xk({inputs:{a:r,b:s},attrs:{transposeA:u,transposeB:l},backend:n}),o&&(h=xh({inputs:{a:p,b:o},backend:n}),m.push(p),p=h),c&&(f=Hk(n,p,c,i,d),m.push(p),p=f);for(const e of m)n.disposeIntermediateTensorInfo(e);return p}},Qk=Ih(be,(e=>Math.acos(e))),Zk={kernelName:be,backendName:"cpu",kernelFunc:Qk},Jk=Ih(ve,(e=>Math.acosh(e))),ew={kernelName:ve,backendName:"cpu",kernelFunc:Jk},tw={kernelName:we,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;th(t,"addN");const r=a.map((e=>n.data.get(e.dataId).values)),s=Wr(a[0].shape,a[0].dtype),o=s.values;for(let e=0;e<a.length;e++){const t=r[e];for(let e=0;e<o.length;e++)o[e]+=t[e]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}},nw={kernelName:Ie,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;th(r,"all");const i=H(s,r.shape);let u=i;const l=So(u,r.shape.length);let c=r;null!=l&&(c=hf({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Ao(u.length,r.shape.length)),Eo("all",u,c.shape.length);const[d,p]=Co(c.shape,u),h=P(p),f=oe(P(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*h;let n=m[t];for(let e=0;e<h;++e){const a=m[t+e];n=n&&a}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(o){const e=jk({inputs:{x:g},backend:n,attrs:{shape:To(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},aw={kernelName:Ne,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;th(r,"any");const i=H(s,r.shape);let u=i;const l=So(u,r.shape.length);let c=r;null!=l&&(c=hf({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Ao(u.length,r.shape.length)),Eo("any",u,c.shape.length);const[d,p]=Co(c.shape,u),h=P(p),f=oe(P(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*h;let n=m[t];for(let e=0;e<h;++e){const a=m[t+e];n=n||a}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(o){const e=jk({inputs:{x:g},backend:n,attrs:{shape:To(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},rw={kernelName:$e,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;th(r,"argMax");let o=H(s,r.shape);const i=So(o,r.shape.length);let u=r;const l=[];null!=i&&(u=hf({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(u),o=Ao(o.length,u.shape.length)),o=[o[0]],Eo("argMax",o,u.shape.length);const[c,d]=Co(u.shape,o),p=oe(P(c),"int32"),h=P(d),f=n.data.get(u.dataId).values;for(let e=0;e<p.length;++e){const t=e*h;let n=f[t],a=0;for(let e=0;e<h;++e){const r=f[t+e];r>n&&(n=r,a=e)}p[e]=a}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}},sw={kernelName:Ce,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;th(r,"argMin");let o=H(s,r.shape);const i=So(o,r.shape.length);let u=r;const l=[];null!=i&&(u=hf({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(u),o=Ao(o.length,u.shape.length)),o=[o[0]],Eo("argMin",o,u.shape.length);const[c,d]=Co(u.shape,o),p=oe(P(c),"int32"),h=P(d),f=n.data.get(u.dataId).values;for(let e=0;e<p.length;++e){const t=e*h;let n=f[t],a=0;for(let e=0;e<h;++e){const r=f[t+e];r<n&&(n=r,a=e)}p[e]=a}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}},ow=Ih(Te,(e=>Math.asin(e))),iw={kernelName:Te,backendName:"cpu",kernelFunc:ow},uw=Ih(Ee,(e=>Math.asinh(e))),lw={kernelName:Ee,backendName:"cpu",kernelFunc:uw},cw=Ih(Se,(e=>Math.atan(e))),dw={kernelName:Se,backendName:"cpu",kernelFunc:cw},pw=rh(((e,t)=>Math.atan2(e,t))),hw=fh(Ae,pw),fw={kernelName:Ae,backendName:"cpu",kernelFunc:hw},mw=Ih(Re,(e=>Math.atanh(e))),gw={kernelName:Re,backendName:"cpu",kernelFunc:mw};function yw(e,t,n,a,r,s){const o=r.strideHeight,i=r.strideWidth,u=r.dilationHeight,l=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,h=r.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Wr(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],x=r.outShape[2]*r.outShape[3],b=r.outShape[3];for(let t=0;t<r.batchSize;++t){const n=t*y,m=t*a[0];for(let t=0;t<r.inChannels;++t)for(let y=0;y<r.outHeight;++y){const v=y*o-p,k=Math.max(0,v),w=Math.min(r.inHeight,c+v),I=n+y*x;for(let n=0;n<r.outWidth;++n){const o=n*i-h,c=Math.max(0,o),p=Math.min(r.inWidth,d+o);let y=f,x=0,v=0;for(let n=k;n<w;n+=u){const r=m+n*a[1];for(let n=c;n<p;n+=l){const o=e[r+n*a[2]+t];"max"===s&&o>y?y=o:"avg"===s&&(x+=o,v++)}if(isNaN(y))break}g[I+n*b+t]="avg"===s?x/v:y}}}return m}function xw(e,t,n,a,r=!1,s=!1){const o=Wr(a.outShape,"int32"),i=a.strideHeight,u=a.strideWidth,l=a.dilationHeight,c=a.dilationWidth,d=a.effectiveFilterHeight,p=a.effectiveFilterWidth,h=a.padInfo.top,f=a.padInfo.left,m=Wr(t,n,e);for(let e=0;e<a.batchSize;++e)for(let t=0;t<a.inChannels;++t)for(let n=0;n<a.outHeight;++n){const g=n*i-h;let y=g;for(;y<0;)y+=l;const x=Math.min(a.inHeight,d+g);for(let i=0;i<a.outWidth;++i){const d=i*u-f;let h=d;for(;h<0;)h+=c;const b=Math.min(a.inWidth,p+d);let v=Number.NEGATIVE_INFINITY,k=-1;for(let n=y;n<x;n+=l){const o=n-g;for(let i=h;i<b;i+=c){const u=i-d,l=m.get(e,n,i,t);l>v&&(v=l,k=r?s?((e*a.inHeight+n)*a.inWidth+i)*a.inChannels+t:(n*a.inWidth+i)*a.inChannels+t:o*p+u)}}o.set(k,e,n,i,t)}}return o}function bw(e,t,n,a,r,s){const o=r.strideDepth,i=r.strideHeight,u=r.strideWidth,l=r.dilationDepth,c=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterDepth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,x="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=Wr(r.outShape,n),v=b.values,k=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],w=r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[3]*r.outShape[4],N=r.outShape[4];for(let t=0;t<r.batchSize;++t){const n=t*k,b=t*a[0];for(let t=0;t<r.inChannels;++t)for(let k=0;k<r.outDepth;++k){const $=k*o-m;let C=$;for(;C<0;)C+=l;const T=Math.min(r.inDepth,p+$),E=n+k*w;for(let n=0;n<r.outHeight;++n){const o=n*i-g;let p=o;for(;p<0;)p+=c;const m=Math.min(r.inHeight,h+o),k=E+n*I;for(let n=0;n<r.outWidth;++n){const o=n*u-y;let i=o;for(;i<0;)i+=d;const h=Math.min(r.inWidth,f+o),g=k+n*N;let w=x,I=0,$=0;for(let n=C;n<T;n+=l){const r=b+n*a[1];for(let n=p;n<m;n+=c){const o=r+n*a[2];for(let n=i;n<h;n+=d){const r=e[o+n*a[3]+t];if("max"===s&&r>w?w=r:"avg"===s&&(I+=r,$++),isNaN(w))break}if(isNaN(w))break}if(isNaN(w))break}v[g+t]="avg"===s?I/$:w}}}}return b}const vw={kernelName:Fe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;th(r,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=a;O(Ni(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const l=fi(r.shape,s,o,1,i,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&B(l.inShape,l.outShape))c=uh({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=ne(r.shape),a=yw(e,r.shape,r.dtype,t,l,"avg");c=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return c}},kw={kernelName:Oe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=a;th(r,"avgPool3d");const c=mi(r.shape,s,o,1,i,u,l),d=bw(n.data.get(r.dataId).values,r.shape,r.dtype,ne(r.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}},ww={kernelName:De,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=a;th([r,s],"avgPool3DGrad");const c=mi(s.shape,o,i,1,u,l),d=c.strideDepth,p=c.strideHeight,h=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,x=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterDepth,k=c.effectiveFilterHeight,w=c.effectiveFilterWidth,I=v-1-c.padInfo.front,N=w-1-c.padInfo.left,$=k-1-c.padInfo.top,C=Wr(s.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(r);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let a=0;a<c.inHeight;++a)for(let r=0;r<c.inWidth;++r){const s=n-I,o=a-$,i=r-N;let u=0;for(let n=0;n<v;n+=y){const a=(s+n)/d;if(!(a<0||a>=c.outDepth||Math.floor(a)!==a))for(let n=0;n<k;n+=x){const r=(o+n)/p;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let n=0;n<w;n+=b){const s=(i+n)/h;s<0||s>=c.outWidth||Math.floor(s)!==s||(u+=E.get(e,a,r,s,t))}}}C.set(u*T,e,n,a,r,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},Iw={kernelName:_e,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s;th([r,s],"avgPoolGrad");const{filterSize:i,strides:u,pad:l}=a,c=fi(o.shape,i,u,1,l),d=c.strideHeight,p=c.strideWidth,h=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,x=c.effectiveFilterWidth,b=x-1-c.padInfo.left,v=y-1-c.padInfo.top,k=Wr(o.shape,"float32"),w=1/(h*f),I=n.data.get(r.dataId).values,N=Wr(r.shape,"float32",I);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inHeight;++n)for(let a=0;a<c.inWidth;++a){const r=n-v,s=a-b;let o=0;for(let n=0;n<y;n+=m){const a=(r+n)/d;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let n=0;n<x;n+=g){const r=(s+n)/p;r<0||r>=c.outWidth||Math.floor(r)!==r||(o+=N.get(e,a,r,t))}}k.set(o*w,e,n,a,t)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},Nw={kernelName:kt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:o,mean:i,variance:u}=t;O(i.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),O(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),O(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),th([r,i,u,s,o],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);const c=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,p=n.data.get(u.dataId).values,h=s?n.data.get(s.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=h.length,x=p.length,b=d.length;let v=0,k=0,w=0,I=0;for(let e=0;e<c.length;++e)m[e]=f[v++]+(c[e]-d[k++])*h[w++]/Math.sqrt(p[I++]+l),v>=g&&(v=0),k>=b&&(k=0),w>=y&&(w=0),I>=x&&(I=0);return n.makeTensorInfo(r.shape,r.dtype,m)}},$w={kernelName:Le,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a;th([r],"batchToSpaceND");const i=s.reduce(((e,t)=>e*t)),u=Pi(r.shape,s,i),l=Bi(u.length,s.length),c=Vi(r.shape,s,i),d=Wi(o,s.length),p=zi(c,o,s.length),h=jk({inputs:{x:r},backend:n,attrs:{shape:u}}),f=hf({inputs:{x:h},backend:n,attrs:{perm:l}}),m=jk({inputs:{x:f},backend:n,attrs:{shape:c}}),g=wf({inputs:{x:m},backend:n,attrs:{begin:d,size:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}},Cw={kernelName:Pe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o}=a,i=vh(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}},Tw=Ih(We,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),Ew={kernelName:We,backendName:"cpu",kernelFunc:Tw},Sw={kernelName:Ue,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(P(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,i=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values;for(let e=0;e<i.length;e++){const t=i[e],n=u[e];a[e]=Math.hypot(t,n)}return n.makeOutput(a,t.shape,"float32")}};function Rw(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const Aw={kernelName:Et,backendName:"cpu",kernelFunc:Rw};function Fw(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=H(r,t[0].shape)[0];let o=pi(t.map((e=>e.shape)),s);if(0===P(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>P(e.shape)>0));if(1===i.length)return uh({inputs:{x:i[0]},backend:n});if(di(i.map((e=>e.shape)),s),"complex64"===i[0].dtype){const e=i.map((e=>ch({inputs:{input:e},backend:n}))),t=i.map((e=>Rw({inputs:{input:e},backend:n}))),a=Fw({inputs:e,backend:n,attrs:{axis:s}}),r=Fw({inputs:t,backend:n,attrs:{axis:s}}),o=sh({inputs:{real:a,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),o}const u=i.map((e=>{const t=P(e.shape.slice(s));return jk({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),l=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=pi(u.map((e=>e.shape)),1);const c=1===u[0].shape[0],d=Eh(l,o,t[0].dtype,c),p=pi(i.map((e=>e.shape)),s),h=n.makeTensorInfo(p,t[0].dtype,d);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}const _w={kernelName:Ge,backendName:"cpu",kernelFunc:Fw};function Ow(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:c}=a;th([r,s],"conv2d");const d=$i(u),p=gi(r.shape,s.shape,o,l,i,c,!1,d),h=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,y=p.padInfo.left,x=p.padInfo.top,b="channelsLast"===p.dataFormat,v=new Ra(p.outShape,r.dtype),k=ne(r.shape),w=ne(s.shape),I=k[0],N=b?k[1]:k[2],$=b?k[2]:1,C=b?1:k[1],T=v.strides[0],E=b?v.strides[1]:v.strides[2],S=b?v.strides[2]:1,R=b?1:v.strides[1],A=n.data.get(r.dataId).values,F=n.data.get(s.dataId).values,_=v.values;for(let e=0;e<p.batchSize;++e){const t=e*I,n=e*T;for(let e=0;e<p.outHeight;++e){const a=n+e*E,r=e*p.strideHeight-x;for(let e=0;e<h;++e){const n=r+e*m;if(n<0||n>=p.inHeight)continue;const s=e*w[0],o=t+n*N;for(let e=0;e<p.outWidth;++e){const t=a+e*S,n=e*p.strideWidth-y;for(let e=0;e<f;++e){const a=n+e*g;if(a<0||a>=p.inWidth)continue;const r=o+a*$;let i=s+e*w[1];for(let e=0;e<p.inChannels;++e){const n=A[r+e*C];for(let e=0;e<p.outChannels;++e)_[t+e*R]+=n*F[i+e];i+=p.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,_)}const Dw={kernelName:He,backendName:"cpu",kernelFunc:Ow},Mw={kernelName:je,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:c}=a;th([r,s],"conv2dBackpropFilter");const d=$i(u),p=gi(r.shape,c,o,1,i,l,!1,d),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=p,y="channelsLast"===p.dataFormat,x=new Ra(p.filterShape,"float32"),b=p.padInfo.left,v=p.padInfo.top,k=n.data.get(r.dataId).values,w=n.data.get(s.dataId).values,I=new Ra(r.shape,r.dtype,k),N=new Ra(s.shape,s.dtype,w);for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((v-e)/h)),n=Math.min(p.outHeight,(p.inHeight+v-e)/h);for(let a=0;a<g;++a){const r=Math.max(0,Math.ceil((b-a)/f)),s=Math.min(p.outWidth,(p.inWidth+b-a)/f);for(let o=0;o<p.inChannels;++o)for(let i=0;i<p.outChannels;++i){let u=0;for(let l=0;l<p.batchSize;++l)for(let c=t;c<n;++c){const t=e+c*h-v;for(let e=r;e<s;++e){const n=a+e*f-b;u+=y?I.get(l,t,n,o)*N.get(l,c,e,i):I.get(l,o,t,n)*N.get(l,i,c,e)}}x.set(u,e,a,o,i)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},Lw={kernelName:Ke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=a;th([r,s],"conv2dBackpropInput");const d=ne(s.shape),p=ne(r.shape);let h=$i(l);const f=gi(o,s.shape,i,1,u,c,!1,h),m=new Ra(f.inShape,"float32"),g=m.values,y=n.data.get(r.dataId).values,x=n.data.get(s.dataId).values,[b,v,k]=d,{batchSize:w,filterHeight:I,filterWidth:N,inChannels:$,inHeight:C,inWidth:T,outChannels:E,outHeight:S,outWidth:R,strideHeight:A,strideWidth:F}=f;h=f.dataFormat;const _=I-1-f.padInfo.top,O=N-1-f.padInfo.left,D="channelsLast"===h,M=m.strides[0],L=D?m.strides[1]:m.strides[2],P=D?m.strides[2]:1,B=D?1:m.strides[1],V=p[0],W=D?p[1]:p[2],z=D?p[2]:1,U=D?1:p[1];for(let e=0;e<w;++e)for(let t=0;t<$;++t)for(let n=0;n<C;++n){const a=n-_,r=Math.max(0,Math.ceil(a/A)),s=Math.min(S,(I+a)/A);for(let o=0;o<T;++o){const i=o-O,u=Math.max(0,Math.ceil(i/F)),l=Math.min(R,(N+i)/F);let c=0;for(let n=r;n<s;++n){const r=n*A-a;for(let a=u;a<l;++a){const s=V*e+W*n+z*a,o=b*(I-1-r)+v*(N-1-(a*F-i))+k*t;for(let e=0;e<E;++e)c+=y[s+U*e]*x[o+e]}}g[M*e+L*n+P*o+B*t]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},Pw={kernelName:Xe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:u}=a;th([r,s],"conv3d");const l=yi(r.shape,s.shape,o,u,i),{filterDepth:c,filterHeight:d,filterWidth:p,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=l,y=g.front,x=g.left,b=g.top,v=new Ra(l.outShape,r.dtype),k=n.data.get(r.dataId).values,w=n.data.get(s.dataId).values,I=v.values,N=ne(r.shape),$=ne(s.shape);for(let e=0;e<l.batchSize;++e){const t=e*N[0],n=e*v.strides[0];for(let e=0;e<l.outDepth;++e){const a=n+e*v.strides[1],r=e*l.strideDepth-y;for(let e=0;e<c;++e){const n=r+e*h;if(n<0||n>=l.inDepth)continue;const s=e*$[0],o=t+n*N[1];for(let e=0;e<l.outHeight;++e){const t=a+e*v.strides[2],n=e*l.strideHeight-b;for(let e=0;e<d;++e){const a=n+e*f;if(a<0||a>=l.inHeight)continue;const r=s+e*$[1],i=o+a*N[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-x;for(let e=0;e<p;++e){const t=a+e*m;if(t<0||t>=l.inWidth)continue;const s=r+e*$[2],o=i+t*l.inChannels;let u=s;for(let e=0;e<l.inChannels;++e){const t=k[o+e];for(let e=0;e<l.outChannels;++e)I[n+e]+=t*w[u+e];u+=l.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},Bw={kernelName:qe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,filterShape:u}=a;th([r,s],"conv3dBackpropFilterV2");const l=ne(r.shape),c=ne(s.shape),d=yi(r.shape,u,o,1,i),p=d.strideDepth,h=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,x=new Ra(d.filterShape,"float32"),b=x.values,[v,k,w,I]=x.strides,N=n.data.get(s.dataId).values,[$,C,T,E]=c,S=n.data.get(r.dataId).values,[R,A,F,_]=l,O=d.padInfo.front,D=d.padInfo.left,M=d.padInfo.top;for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((O-e)/p)),n=Math.min(d.outDepth,(d.inDepth+O-e)/p),a=e*v;for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((M-r)/h)),o=Math.min(d.outHeight,(d.inHeight+M-r)/h),i=r*k+a;for(let a=0;a<y;++a){const u=Math.max(0,Math.ceil((D-a)/f)),l=Math.min(d.outWidth,(d.inWidth+D-a)/f),c=a*w+i;for(let i=0;i<d.inChannels;++i){const m=i*I+c;for(let c=0;c<d.outChannels;++c){let g=0;for(let m=0;m<d.batchSize;++m){const d=m*R,y=m*$;for(let m=t;m<n;++m){const t=(e+m*p-O)*A+d,n=m*C+y;for(let e=s;e<o;++e){const s=(r+e*h-M)*F+t,o=e*T+n;for(let e=u;e<l;++e){const t=e*E+o;g+=S[(a+e*f-D)*_+s+i]*N[t+c]}}}}b[m+c]=g}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},Vw={kernelName:Ye,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:o,strides:i,inputShape:u}=a;th([r],"conv3dBackpropInputV2");const l=ne(r.shape),c=ne(s.shape),d=yi(u,s.shape,i,1,o),p=new Ra(d.inShape,"float32"),h=p.values,[f,m,g,y]=p.strides,x=n.data.get(r.dataId).values,[b,v,k,w]=l,I=n.data.get(s.dataId).values,[N,$,C,T]=c,{batchSize:E,filterDepth:S,filterHeight:R,filterWidth:A,inChannels:F,inDepth:_,inHeight:O,inWidth:D,outChannels:M,outDepth:L,outHeight:P,outWidth:B,strideDepth:V,strideHeight:W,strideWidth:z}=d,U=S-1-d.padInfo.front,G=R-1-d.padInfo.top,H=A-1-d.padInfo.left;for(let e=0;e<E;++e)for(let t=0;t<F;++t)for(let n=0;n<_;++n){const a=n-U,r=Math.max(0,Math.ceil(a/V)),s=Math.min(L,(S+a)/V);for(let o=0;o<O;++o){const i=o-G,u=Math.max(0,Math.ceil(i/W)),l=Math.min(P,(R+i)/W);for(let c=0;c<D;++c){const d=c-H,p=Math.max(0,Math.ceil(d/z)),E=Math.min(B,(A+d)/z);let F=0;for(let n=r;n<s;++n){const r=n*V-a;for(let a=u;a<l;++a){const s=a*W-i;for(let o=p;o<E;++o){const i=b*e+v*n+k*a+w*o,u=N*(S-1-r)+$*(R-1-s)+C*(A-1-(o*z-d))+T*t;for(let e=0;e<M;++e)F+=x[i+e]*I[u+e]}}}h[f*e+m*n+g*o+y*c+t]=F}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}},Ww=Ih(Qe,(e=>Math.cos(e))),zw={kernelName:Qe,backendName:"cpu",kernelFunc:Ww},Uw=Ih(Ze,(e=>Math.cosh(e))),Gw={kernelName:Ze,backendName:"cpu",kernelFunc:Uw},Hw={kernelName:et,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=a,[c,d,p,h]=r.shape,f=s.shape[0],[m,g]=i,y=Wr([f,m,g,h],"float32"),x=n.data.get(s.dataId).values,b=n.data.get(o.dataId).values,v=n.data.get(r.dataId).values,k=ne(r.shape),w=ne(y.shape);for(let e=0;e<f;e++){const t=4*e,n=x[t],a=x[t+1],r=x[t+2],s=x[t+3],o=b[e];if(o>=c)continue;const i=m>1?(r-n)*(d-1)/(m-1):0,f=g>1?(s-a)*(p-1)/(g-1):0;for(let t=0;t<m;t++){const c=m>1?n*(d-1)+t*i:.5*(n+r)*(d-1);if(c<0||c>d-1)for(let n=0;n<g;n++)for(let a=0;a<h;a++){const r=a+n*w[2]+t*w[1]+e*w[0];y.values[r]=l}else if("bilinear"===u){const n=Math.floor(c),r=Math.ceil(c),i=c-n;for(let u=0;u<g;u++){const c=g>1?a*(p-1)+u*f:.5*(a+s)*(p-1);if(c<0||c>p-1){for(let n=0;n<h;n++){const a=n+u*w[2]+t*w[1]+e*w[0];y.values[a]=l}continue}const d=Math.floor(c),m=Math.ceil(c),x=c-d;for(let a=0;a<h;a++){let s=a+d*k[2]+n*k[1]+o*k[0];const l=v[s];s=a+m*k[2]+n*k[1]+o*k[0];const c=v[s];s=a+d*k[2]+r*k[1]+o*k[0];const p=v[s];s=a+m*k[2]+r*k[1]+o*k[0];const h=l+(c-l)*x,f=p+(v[s]-p)*x;s=a+u*w[2]+t*w[1]+e*w[0],y.values[s]=h+(f-h)*i}}}else for(let n=0;n<g;++n){const r=g>1?a*(p-1)+n*f:.5*(a+s)*(p-1);if(r<0||r>p-1){for(let a=0;a<h;a++){const r=a+n*w[2]+t*w[1]+e*w[0];y.values[r]=l}continue}const i=Math.round(r),u=Math.round(c);for(let a=0;a<h;a++){const r=a+i*k[2]+u*k[1]+o*k[0],s=a+n*w[2]+t*w[1]+e*w[0];y.values[s]=v[r]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},jw={kernelName:Je,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;th(r,"cumsum");const u=So([s],r.shape.length);let l=r;null!=u&&(l=hf({inputs:{x:r},backend:n,attrs:{perm:u}}));const c=Ao(1,r.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const d=za(l.dtype,"int32"),p=oe(P(l.shape),d),h=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<h.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)p[n]=o?0:h[n];else{const a=m(e,t-1);p[n]=o?h[a]+p[a]:h[n]+p[a]}}const g=n.makeTensorInfo(l.shape,d,p);if(null!=u){const e=hf({inputs:{x:g},backend:n,attrs:{perm:Ro(u)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}},Kw={kernelName:tt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o,binaryOutput:i}=a;if(1===r.shape.length){const e=vh(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,e)}if(2===r.shape.length){const e=kh(n.bufferSync(r),n.bufferSync(s),o,i);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},Xw={kernelName:nt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:o}=a;O("NHWC"===o,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`)),O(s>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${s}`));const i=r.shape[0],u=r.shape[1],l=r.shape[2],c=r.shape[3],d=u*s,p=l*s,h=c/(s*s),f=n.data.get(r.dataId).values,m=new Float32Array(i*d*p*h);let g=0;for(let e=0;e<i;++e)for(let t=0;t<d;++t){const n=Math.floor(t/s),a=t%s;for(let t=0;t<p;++t){const r=Math.floor(t/s),o=(a*s+t%s)*h;for(let t=0;t<h;++t){const a=t+o+c*(r+l*(n+u*e));m[g++]=f[a]}}}return n.makeTensorInfo([i,d,p,h],r.dtype,m)}};function qw(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=a;th([r,s],"depthwiseConv2DNative");const c=ne(r.shape),d=ne(s.shape);let p=u;null==p&&(p=[1,1]),O(Ni(o,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`));const h=gi(r.shape,s.shape,o,p,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:x}=h,b=x.left,v=x.top,k=h.outChannels/h.inChannels,w=new Ra(h.outShape,r.dtype),I=n.data.get(r.dataId).values,N=n.data.get(s.dataId).values,$=w.values;for(let e=0;e<h.batchSize;++e){const t=e*c[0],n=e*w.strides[0];for(let e=0;e<h.outHeight;++e){const a=n+e*w.strides[1],r=e*h.strideHeight-b;for(let e=0;e<f;++e){const n=r+e*g;if(n<0||n>=h.inHeight)continue;const s=e*d[0],o=t+n*c[1];for(let e=0;e<h.outWidth;++e){const t=a+e*w.strides[2],n=e*h.strideWidth-v;for(let e=0;e<m;++e){const a=n+e*y;if(a<0||a>=h.inWidth)continue;const r=s+e*d[1],i=o+a*h.inChannels;let u=t,l=r;for(let e=0;e<h.inChannels;++e){const t=I[i+e];for(let e=0;e<k;++e)$[u+e]+=t*N[l+e];u+=k,l+=k}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const Yw={kernelName:at,backendName:"cpu",kernelFunc:qw},Qw={kernelName:rt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:c}=a;th([r,s],"depthwiseConv2dNativeBackpropFilter");const d=gi(r.shape,c,o,i,u,l,!0),{strideHeight:p,strideWidth:h,filterHeight:f,filterWidth:m}=d,g=new Ra(d.filterShape,"float32"),y=d.padInfo.left,x=d.padInfo.top,b=d.outChannels/d.inChannels,v=n.data.get(r.dataId).values,k=new Ra(r.shape,r.dtype,v),w=n.data.get(s.dataId).values,I=new Ra(s.shape,s.dtype,w);for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((x-e)/p)),n=Math.min(d.outHeight,(d.inHeight+x-e)/p);for(let a=0;a<m;++a){const r=Math.max(0,Math.ceil((y-a)/h)),s=Math.min(d.outWidth,(d.inWidth+y-a)/h);for(let o=0;o<d.outChannels;++o){const i=Math.trunc(o/b),u=o%b;let l=0;for(let u=0;u<d.batchSize;++u)for(let c=t;c<n;++c){const t=e+c*p-x;for(let e=r;e<s;++e){const n=a+e*h-y;l+=k.get(u,t,n,i)*I.get(u,c,e,o)}}g.set(l,e,a,i,u)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},Zw={kernelName:st,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:c}=a;th([r,s],"depthwiseConv2DNativeBackpropInput");const d=ne(r.shape),p=ne(s.shape),h=gi(c,s.shape,o,i,u,l,!0),f=new Ra(h.inShape,"float32"),m=f.values,[g,y,x]=f.strides,b=n.data.get(r.dataId).values,[v,k,w]=d,I=n.data.get(s.dataId).values,[N,$,C]=p,{batchSize:T,filterHeight:E,filterWidth:S,inChannels:R,inHeight:A,inWidth:F,outChannels:_,outHeight:O,outWidth:D,strideHeight:M,strideWidth:L}=h,P=E-1-h.padInfo.top,B=S-1-h.padInfo.left,V=_/R;for(let e=0;e<T;++e)for(let t=0;t<R;++t)for(let n=0;n<A;++n){const a=n-P,r=Math.max(0,Math.ceil(a/M)),s=Math.min(O,(E+a)/M);for(let o=0;o<F;++o){const i=o-B,u=Math.max(0,Math.ceil(i/L)),l=Math.min(D,(S+i)/L);let c=0;for(let n=r;n<s;++n){const r=n*M-a;for(let a=u;a<l;++a){const s=v*e+k*n+w*a,o=N*(E-1-r)+$*(S-1-(a*L-i))+C*t;for(let e=0;e<V;++e)c+=b[s+(t*V+e)]*I[o+e]}}m[g*e+y*n+x*o+t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},Jw={kernelName:ot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=P(a.shape),s=n.data.get(a.dataId).values,o=Wr([r,r],a.dtype),i=o.values;for(let e=0;e<s.length;e++)i[e*r+e]=s[e];const u=[...a.shape,...a.shape];return n.makeTensorInfo(u,o.dtype,o.values)}},eI={kernelName:it,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,filter:r}=e,{strides:s,pad:o,dilations:i}=n,u=t,l=u.data.get(a.dataId).values,c=a.shape.length,d=u.data.get(r.dataId).values,p=r.shape.length,{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:x,padInfo:b,strideHeight:v,strideWidth:k,filterHeight:w,filterWidth:I,dilationHeight:N,dilationWidth:$,outShape:C}=hi(a.shape,r.shape,s,o,"NHWC",i),T=P(C),E=C.length,S=X(a.dtype,T);for(let e=0;e<h;++e)for(let t=0;t<y;++t){const n=t*v-b.top;for(let s=0;s<x;++s){const o=s*k-b.left;for(let i=0;i<g;++i){let u=Number.MIN_SAFE_INTEGER;for(let t=0;t<w;++t){const s=n+t*N;if(s>=0&&s<f)for(let n=0;n<I;++n){const h=o+n*$;if(h>=0&&h<m){const o=le([e,s,h,i],c,ne(a.shape)),f=le([t,n,i],p,ne(r.shape)),m=l[o]+d[f];m>u&&(u=m)}}}S[le([e,t,s,i],E,ne(C))]=u}}}return{dataId:u.write(xa(S,a.dtype),C,a.dtype),shape:C,dtype:a.dtype}}},tI={kernelName:"Dilation2DBackpropFilter",backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,filter:r,dy:s}=e,{strides:o,pad:i,dilations:u}=n,l=t,c=re(a.shape,l.data.get(a.dataId).values),d=re(r.shape,l.data.get(r.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:x,strideHeight:b,strideWidth:v,filterHeight:k,filterWidth:w,dilationHeight:I,dilationWidth:N,outShape:$}=hi(a.shape,r.shape,o,i,"NHWC",u);O(s.rank===$.length,(()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${$.length}, but got ${s.rank}`));const C=re($,l.data.get(s.dataId).values),T=ie(r.shape,r.dtype);for(let e=0;e<p;++e)for(let t=0;t<g;++t){const n=t*b-x.top;for(let a=0;a<y;++a){const r=a*v-x.left;for(let s=0;s<m;++s){let o=Number.MIN_SAFE_INTEGER,i=0,u=0;for(let t=0;t<k;++t){const a=n+t*I;if(a>=0&&a<h)for(let n=0;n<w;++n){const l=r+n*N;if(l>=0&&l<f){const r=c[e][a][l][s]+d[t][n][s];r>o&&(o=r,i=t,u=n)}}}T[i][u][s]+=C[e][t][a][s]}}}return{dataId:l.write(xa(T,a.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},nI={kernelName:"Dilation2DBackpropInput",backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,filter:r,dy:s}=e,{strides:o,pad:i,dilations:u}=n,l=t,c=re(a.shape,l.data.get(a.dataId).values),d=re(r.shape,l.data.get(r.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:x,strideHeight:b,strideWidth:v,filterHeight:k,filterWidth:w,dilationHeight:I,dilationWidth:N,outShape:$}=hi(a.shape,r.shape,o,i,"NHWC",u);O(s.rank===$.length,(()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${$.length}, but got ${s.rank}`));const C=re($,l.data.get(s.dataId).values),T=ie(a.shape,a.dtype);for(let e=0;e<p;++e)for(let t=0;t<g;++t){const n=t*b-x.top;for(let a=0;a<y;++a){const r=a*v-x.left;for(let s=0;s<m;++s){let o=Number.MIN_SAFE_INTEGER,i=n<0?0:n,u=r<0?0:r;for(let t=0;t<k;++t){const a=n+t*I;if(a>=0&&a<h)for(let n=0;n<w;++n){const l=r+n*N;if(l>=0&&l<f){const r=c[e][a][l][s]+d[t][n][s];r>o&&(o=r,i=a,u=l)}}}T[e][i][u][s]+=C[e][t][a][s]}}}return{dataId:l.write(xa(T,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},aI={kernelName:ct,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;th([a,r],"eluGrad");const s=new Float32Array(P(r.shape)),o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values;for(let e=0;e<o.length;++e){const t=o[e];s[e]=t>=1?i[e]:i[e]*(t+1)}return n.makeTensorInfo(r.shape,"float32",s)}},rI=rh(((e,t)=>e===t?1:0)),sI=fh(pt,rI,null,"bool"),oI={kernelName:pt,backendName:"cpu",kernelFunc:sI},iI=qi,uI=Yi,lI=Qi,cI=Zi,dI=Ji,pI=eu,hI=Ih(dt,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+iI*n);return t*(1-((((pI*a+dI)*a+cI)*a+lI)*a+uI)*a*Math.exp(-n*n))})),fI={kernelName:dt,backendName:"cpu",kernelFunc:hI};function mI(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,o=r.shape.length,i=r.shape.slice();let u=s;return s<0&&(O(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),u=o+s+1),i.splice(u,0,1),jk({inputs:{x:r},backend:n,attrs:{shape:i}})}const gI={kernelName:ft,backendName:"cpu",kernelFunc:mI},yI=rh(((e,t)=>e/t)),xI=fh(ut,yI),bI={kernelName:ut,backendName:"cpu",kernelFunc:xI};function vI(e,t,n){const a=e.shape,r=a[0],s=a[1],o=n.data.get(e.dataId),i=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,l=[r,s],c=P(l),d=K("float32",c),p=K("float32",c);for(let e=0;e<r;e++){const a=wf({inputs:{x:i},backend:n,attrs:{begin:[e,0],size:[1,s]}}),r=wf({inputs:{x:u},backend:n,attrs:{begin:[e,0],size:[1,s]}}),o=sh({inputs:{real:a,imag:r},backend:n}),{real:l,imag:c}=kI(o,t,n),h=au(l,c);for(let t=0;t<s;t++){const n=iu(h,t);d[e*s+t]=n.real,p[e*s+t]=n.imag}n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o)}const h=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",p),m=sh({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}function kI(e,t,n){const a=P(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0==((i=a)&i-1)){const r=wI(s,o,a,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),s=n.makeTensorInfo([],"float32",ya(a,"float32")),o=uh({inputs:{x:s},backend:n}),u=bI.kernelFunc({inputs:{a:e,b:s},backend:n}),l=bI.kernelFunc({inputs:{a:t,b:o},backend:n}),c=n.data.get(u.dataId).values,d=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),{real:c,imag:d}}return r}return ru(function(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let s=0,o=0;for(let a=0;a<t;a++){const i=cu(r*a,t,n),u=iu(e,a);s+=u.real*i.real-u.imag*i.imag,o+=u.real*i.imag+u.imag*i.real}n&&(s/=t,o/=t),uu(a,s,o,r)}return a}(au(s,o),a,t));var i}function wI(e,t,n,a,r){if(1===n)return{real:e,imag:t};const s=au(e,t),o=n/2,i=su(s),u=i.real,l=i.imag,c=[u.length],d=r.makeTensorInfo(c,"float32",u),p=r.makeTensorInfo(c,"float32",l),h=sh({inputs:{real:d,imag:p},backend:r}),f=ou(s),m=f.real,g=f.imag,y=[m.length],x=r.makeTensorInfo(y,"float32",m),b=r.makeTensorInfo(y,"float32",g),v=sh({inputs:{real:x,imag:b},backend:r}),k=wI(u,l,o,a,r),w=k.real,I=k.imag,N=[w.length],$=r.makeTensorInfo(N,"float32",w),C=r.makeTensorInfo(N,"float32",I),T=sh({inputs:{real:$,imag:C},backend:r}),E=wI(m,g,o,a,r),S=E.real,R=E.imag,A=[S.length],F=r.makeTensorInfo(A,"float32",S),_=r.makeTensorInfo(A,"float32",R),O=sh({inputs:{real:F,imag:_},backend:r}),D=lu(n,a),M=[D.real.length],L=r.makeTensorInfo(M,"float32",D.real),P=r.makeTensorInfo(M,"float32",D.imag),B=sh({inputs:{real:L,imag:P},backend:r}),V=rf({inputs:{a:B,b:O},backend:r}),W=xh({inputs:{a:T,b:V},backend:r}),z=Rf({inputs:{a:T,b:V},backend:r}),U=ch({inputs:{input:W},backend:r}),G=ch({inputs:{input:z},backend:r}),H=Rw({inputs:{input:W},backend:r}),j=Rw({inputs:{input:z},backend:r}),K=Fw({inputs:[U,G],backend:r,attrs:{axis:0}}),X=Fw({inputs:[H,j],backend:r,attrs:{axis:0}}),q=r.data.get(K.dataId).values,Y=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(X),{real:q,imag:Y}}const II={kernelName:gt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=P(a.shape),s=a.shape[a.shape.length-1],o=jk({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),i=vI(o,!1,n),u=jk({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}};function NI(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,o=s||J(r),i=X(o,P(a));return function(e,t,n){e.fill(t)}(i,r),t.makeTensorInfo(a,o,i)}const $I={kernelName:yt,backendName:"cpu",kernelFunc:NI},CI={kernelName:xt,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,r=n,s=K(a.dtype,P(a.shape)),[o,i,u,l]=a.shape,c=r.data.get(a.dataId).values;for(let e=0;e<o;e++){const t=e*u*i*l;for(let e=0;e<i;e++){const n=e*(u*l);for(let a=0;a<u;a++){const r=a*l;for(let i=0;i<l;i++){const d=[o,e,a,i][2],p=Math.round(u-d),h=t+n+r+i;let f=c[h];p>=0&&p<u&&(f=c[t+n+p*l+i]),s[h]=f}}}}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},TI=rh(((e,t)=>Math.floor(e/t))),EI=fh(vt,TI,null,"int32"),SI={kernelName:vt,backendName:"cpu",kernelFunc:EI},RI={kernelName:ua,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=a;let m=Ow({inputs:{x:r,filter:s},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p}});if(o){const e=m;m=xh({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){const e=m;m=Hk(n,m,h,i,f),n.disposeIntermediateTensorInfo(e)}return m}},AI={kernelName:la,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=a;let m=qw({inputs:{x:r,filter:s},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p}});if(o){const e=m;m=xh({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){const e=m;m=Hk(n,m,h,i,f),n.disposeIntermediateTensorInfo(e)}return m}},FI={kernelName:It,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=P(a.shape),o=r.shape,i=o[o.length-1],[u,l,c,d]=Ui(a,r);if(0===l)return n.makeTensorInfo(u,a.dtype,[]);const p=Wr([l,c],a.dtype),h=n.data.get(r.dataId).values,f=n.data.get(a.dataId).values;for(let e=0;e<l;e++){const t=[];let n=0;for(let a=0;a<i;a++){const r=h[e*i+a];n+=r*d[a],t.push(r)}if(n<0||n>=s/c)throw new Error(`Invalid indices: ${t} does not index into ${a.shape}`);for(let t=0;t<c;t++)p.values[e*c+t]=f[n*c+t]}return n.makeTensorInfo(u,p.dtype,p.values)}},_I={kernelName:wt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:o,batchDims:i}=a;th([r,s],"gatherV2");let u=i;null==i&&(u=0);const l=P(s.shape),c=fu(r,s,H(o,r.shape)[0],u),d=jk({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=jk({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}}),h=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize],f=n.bufferSync(p),m=Ph(n.bufferSync(d),f,h);return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.makeTensorInfo(c.outputShape,m.dtype,m.values)}},OI=rh(((e,t)=>e>=t?1:0)),DI=fh($t,OI,null,"bool"),MI={kernelName:$t,backendName:"cpu",kernelFunc:DI},LI={kernelName:Tt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=P(a.shape),s=a.shape[a.shape.length-1],o=jk({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),i=vI(o,!0,n),u=jk({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}},PI={kernelName:St,backendName:"cpu",kernelFunc:Ih(St,(e=>Number.isFinite(e)?1:0),"bool")},BI={kernelName:Rt,backendName:"cpu",kernelFunc:Ih(Rt,(e=>Math.abs(e)===1/0?1:0),"bool")},VI={kernelName:At,backendName:"cpu",kernelFunc:Ih(At,(e=>Number.isNaN(e)?1:0),"bool")},WI=rh(((e,t)=>e<=t?1:0)),zI=fh(Ot,WI,null,"bool"),UI={kernelName:Ot,backendName:"cpu",kernelFunc:zI},GI={kernelName:Dt,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,o=Hh(a,r,s);return t.makeTensorInfo([o.length],"float32",o)}},HI=Ih(Lt,(e=>Math.log1p(e))),jI={kernelName:Lt,backendName:"cpu",kernelFunc:HI},KI=rh(((e,t)=>e&&t)),XI=fh(Pt,KI,null,"bool"),qI={kernelName:Pt,backendName:"cpu",kernelFunc:XI},YI=Ih(Bt,(e=>e?0:1),"bool"),QI={kernelName:Bt,backendName:"cpu",kernelFunc:YI},ZI=rh(((e,t)=>e||t)),JI=fh(Vt,ZI,null,"bool"),eN={kernelName:Vt,backendName:"cpu",kernelFunc:JI},tN={kernelName:Wt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:o,alpha:i,beta:u}=a;th(r,"LRN");const l=r.shape[3],c=l-1,d=n.data.get(r.dataId).values,p=P(r.shape),h=new Float32Array(p);function f(e){const t=e%l;let n=e-t+Math.max(0,t-s);const a=e-t+Math.min(t+s,c);let r=0;for(;n<=a;n++){const e=d[n];r+=e*e}return r}for(let e=0;e<p;e++){const t=f(e),n=d[e]*Math.pow(o+i*t,-u);h[e]=n}return n.makeTensorInfo(r.shape,r.dtype,h)}},nN={kernelName:zt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:o}=t,{depthRadius:i,bias:u,alpha:l,beta:c}=a;th(o,"LRNGrad");const d=P(o.shape),p=o.shape[3],h=n.data.get(o.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let e=0;e<y;e++){const t=e%p,n=e-t+Math.max(0,t-i),a=e-t+Math.min(p,t+i+1);let r=0;for(let e=n;e<a;e++)r+=Math.pow(f[e],2);r=l*r+u;for(let t=n;t<a;t++){let n=-2*l*c*f[t]*m[e]/r;e===t&&(n+=Math.pow(r,-c)),n*=h[e],g[t]+=n}}return n.makeTensorInfo(o.shape,r.dtype,g)}};function aN(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:o}=a,i=n;let u=r.shape;const l=u.length,c=H(s,u);let d=c;const p=So(d,l);let h=i.data.get(r.dataId).values;if(null!=p){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=u[p[t]];h=pf(h,u,r.dtype,p,e),d=Ao(d.length,l),u=e}th(r,"max"),Eo("max",d,l);const[f,m]=Co(u,d),g=qh(h,P(m),f,r.dtype),y=i.write(g,f,r.dtype);let x=f;return o&&(x=To(f,c)),{dataId:y,shape:x,dtype:r.dtype}}const rN={kernelName:Ut,backendName:"cpu",kernelFunc:aN},sN={kernelName:Ht,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;th(r,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=a;O(Ni(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const l=fi(r.shape,s,o,1,i,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&B(l.inShape,l.outShape))c=uh({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=ne(r.shape),a=yw(e,r.shape,r.dtype,t,l,"max");c=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return c}},oN={kernelName:Kt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=a;th(r,"maxPool3d");const c=mi(r.shape,s,o,1,i,u,l),d=bw(n.data.get(r.dataId).values,r.shape,r.dtype,ne(r.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}},iN={kernelName:Xt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=a;th([r,s],"maxPool3DGrad");const c=mi(s.shape,o,i,1,u,l),d=function(e,t){const n=Wr(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const x=y*a-p;let b=x;for(;b<0;)b+=o;const v=Math.min(t.inDepth,l+x);for(let a=0;a<t.outHeight;++a){const l=a*r-h;let p=l;for(;p<0;)p+=i;const k=Math.min(t.inHeight,c+l);for(let r=0;r<t.outWidth;++r){const h=r*s-f;let w=h;for(;w<0;)w+=u;const I=Math.min(t.inWidth,d+h);let N=Number.NEGATIVE_INFINITY,$=-1;for(let t=b;t<v;t+=o){const n=t-x;for(let a=p;a<k;a+=i){const r=a-l;for(let s=w;s<I;s+=u){const o=s-h,i=e.get(m,t,a,s,g);i>=N&&(N=i,$=n*c*d+r*c+o)}}}n.set($,m,y,a,r,g)}}}return n}(n.bufferSync(s),c),p=c.strideDepth,h=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,x=c.effectiveFilterDepth,b=c.effectiveFilterHeight,v=c.effectiveFilterWidth,k=x-1-c.padInfo.front,w=v-1-c.padInfo.left,I=b-1-c.padInfo.top,N=Wr(s.shape,"float32"),$=n.bufferSync(r);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let a=0;a<c.inHeight;++a)for(let r=0;r<c.inWidth;++r){const s=n-k,o=a-I,i=r-w;let u=0;for(let n=0;n<x;n+=m){const a=(s+n)/p;if(!(a<0||a>=c.outDepth||Math.floor(a)!==a))for(let r=0;r<b;r+=g){const s=(o+r)/h;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let o=0;o<v;o+=y){const l=(i+o)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const p=x*b*v-1-d.get(e,a,s,l,t)===n*b*v+r*v+o?1:0;0!==p&&(u+=$.get(e,a,s,l,t)*p)}}}N.set(u,e,n,a,r,t)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}},uN={kernelName:jt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:o}=t,i=s;th([s,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=a,p=fi(i.shape,u,l,1,c,d),h=n.data.get(i.dataId).values,f=Wr(p.outShape,i.dtype,xw(h,i.shape,i.dtype,p).values),m=p.strideHeight,g=p.strideWidth,y=p.dilationHeight,x=p.dilationWidth,b=p.effectiveFilterHeight,v=p.effectiveFilterWidth,k=v-1-p.padInfo.left,w=b-1-p.padInfo.top,I=Wr(i.shape,"float32"),N=n.data.get(r.dataId).values,$=Wr(r.shape,"float32",N);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let n=0;n<p.inHeight;++n)for(let a=0;a<p.inWidth;++a){const r=n-w,s=a-k;let o=0;for(let n=0;n<b;n+=y){const a=(r+n)/m;if(!(a<0||a>=p.outHeight||Math.floor(a)!==a))for(let r=0;r<v;r+=x){const i=(s+r)/g;if(i<0||i>=p.outWidth||Math.floor(i)!==i)continue;const u=b*v-1-f.get(e,a,i,t)===n*v+r?1:0;0!==u&&(o+=$.get(e,a,i,t)*u)}}I.set(o,e,n,a,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},lN={kernelName:qt,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{filterSize:r,strides:s,pad:o,includeBatchInIndex:i}=t,u=n;th(a,"MaxPoolWithArgmax");const l=u.data.get(a.dataId).values,c=fi(a.shape,r,s,[1,1],o),[d,p]=function(e,t,n,a,r){const s=yw(e,0,n,ne(t),r,"max"),o=xw(e,t,n,r,!0,a);return[s.values,o.values]}(l,a.shape,a.dtype,i,c),h=u.write(d,c.outShape,a.dtype),f=u.write(p,c.outShape,a.dtype);return[{dataId:h,shape:c.outShape,dtype:a.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};function cN(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;let i;th(r,"sum"),i="bool"===r.dtype?ph({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):uh({inputs:{x:r},backend:n});const u=i.shape.length,l=H(s,i.shape),c=So(l,u);let d=l,p=i;null!=c&&(p=hf({inputs:{x:i},backend:n,attrs:{perm:c}}),d=Ao(d.length,u)),Eo("sum",d,p.shape.length);const[h,f]=Co(p.shape,d);let m=ih(n,h,za(p.dtype,"int32"));const g=P(f),y=n.data.get(m.dataId).values,x=n.data.get(p.dataId).values;for(let e=0;e<y.length;++e){const t=e*g;let n=0;for(let e=0;e<g;++e)n+=x[t+e];y[e]=n}if(o){const e=m;m=jk({inputs:{x:m},backend:n,attrs:{shape:To(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=c&&n.disposeIntermediateTensorInfo(p),m}const dN={kernelName:Bn,backendName:"cpu",kernelFunc:cN},pN={kernelName:Yt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=H(s,r.shape),u=P(Co(r.shape,i)[1]),l=[],c=n.makeTensorInfo([],"float32",new Float32Array([u]));l.push(c);const d=ph({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});l.push(d);const p=xI({inputs:{a:d,b:c},backend:n});l.push(p);const h=cN({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:o}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},hN={kernelName:Qt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;th(r,"min");const i=H(s,r.shape);let u=i;const l=So(u,r.shape.length);let c=r;null!=l&&(c=hf({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Ao(u.length,r.shape.length)),Eo("min",u,c.shape.length);const[d,p]=Co(c.shape,u),h=P(p),f=oe(P(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*h;let n=m[t];for(let e=0;e<h;++e){const a=m[t+e];a<n&&(n=a)}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(o){const e=jk({inputs:{x:g},backend:n,attrs:{shape:To(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},fN={kernelName:Jt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:o}=a;th(r,"mirrorPad");const i=s.map(((e,t)=>e[0]+r.shape[t]+e[1])),u=s.map((e=>e[0])),l=s.map(((e,t)=>e[0]+r.shape[t])),c="reflect"===o?0:1,d=n.data.get(r.dataId).values,p=r.shape.length,h=ne(r.shape),f=P(i),m=i.length,g=ne(i),y=K(r.dtype,f);for(let e=0;e<f;e++){let t=ce(e,m,g);for(let e=0;e<m;e++)t[e]<u[e]?t[e]=2*u[e]-t[e]-c:t[e]>=l[e]&&(t[e]=2*(l[e]-1)-t[e]+c);t=t.map(((e,t)=>e-u[t]));const n=le(t,p,h);y[e]=d[n]}return{dataId:n.write(y,i,r.dtype),shape:i,dtype:r.dtype}}},mN=rh(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),gN=fh(en,mN),yN={kernelName:en,backendName:"cpu",kernelFunc:gN};function xN(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,o=r.shape.length;let i=s;if(-1===i&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);const u=H([i],r.shape),l=aN({inputs:{x:r},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=To(l.shape,u),d=jk({inputs:{x:l},backend:n,attrs:{shape:c}}),p=Rf({inputs:{a:r,b:d},backend:n}),h=Rh({inputs:{x:p},backend:n}),f=cN({inputs:{x:h},backend:n,attrs:{axis:u,keepDims:!1}}),m=jk({inputs:{x:f},backend:n,attrs:{shape:c}}),g=xI({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const bN={kernelName:zn,backendName:"cpu",kernelFunc:xN},vN={kernelName:tn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:o,normalized:i}=a;th(r,"multinomial");const u=i?r:xN({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],d=n.data.get(u.dataId).values,p=[l,s],h=oe(P(p),"int32");for(let e=0;e<l;++e){const t=e*c,n=new Float32Array(c-1);n[0]=d[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+d[t+e];const a=hc.alea(o.toString()),r=e*s;for(let e=0;e<s;++e){const t=a();h[r+e]=n.length;for(let a=0;a<n.length;a++)if(t<n[a]){h[r+e]=a;break}}}return i||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(p,"int32",h)}},kN=to,wN={kernelName:sn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=a;th(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=kN(l,c,o,i,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},IN=no,NN={kernelName:on,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=a;th(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:p,validOutputs:h}=IN(c,d,o,i,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},$N=ao,CN={kernelName:un,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=a;th(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,p=o,h=i,f=u,m=l,{selectedIndices:g,selectedScores:y}=$N(c,d,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},TN={kernelName:cn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{depth:s,onValue:o,offValue:i}=a;th(r,"oneHot");const u=P(r.shape),l=new Float32Array(u*s);l.fill(i);const c=n.data.get(r.dataId).values;for(let e=0;e<u;++e)c[e]>=0&&c[e]<s&&(l[e*s+c[e]]=o);return n.makeTensorInfo([...r.shape,s],"int32",l)}};function EN(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=ch({inputs:{input:a},backend:n}),t=EN({inputs:{x:e},backend:n}),r=Rw({inputs:{input:a},backend:n}),s=EN({inputs:{x:r},backend:n}),o=sh({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return NI({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const SN={kernelName:aa,backendName:"cpu",kernelFunc:EN},RN={kernelName:ln,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=ch({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=Rw({inputs:{input:r},backend:a}),o=EN({inputs:{x:s},backend:a}),i=sh({inputs:{real:n,imag:o},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}return NI({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function AN(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return mI({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{D(s,e.shape,"All tensors passed to stack must have matching shapes"),O(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],u=Fw({inputs:t.map((e=>{const t=mI({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const FN={kernelName:dn,backendName:"cpu",kernelFunc:AN},_N={kernelName:pn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:o}=a;th(r,"pad");const i=s.map(((e,t)=>e[0]+r.shape[t]+e[1])),u=s.map((e=>e[0])),l=n.data.get(r.dataId).values,c=P(r.shape),d=r.shape.length,p=ne(r.shape),h=P(i),f=i.length,m=ne(i),g=K(r.dtype,h);0!==o&&g.fill(o);for(let e=0;e<c;e++)g[le(ce(e,d,p).map(((e,t)=>e+u[t])),f,m)]=l[e];return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}},ON=rh(((e,t)=>Math.pow(e,t))),DN=fh(hn,ON),MN={kernelName:hn,backendName:"cpu",kernelFunc:DN},LN={kernelName:gn,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:o}=n,i=yf(a,r,o,s);return t.makeTensorInfo([i.length],s,i)}},PN=Ih(xn,(e=>1/e)),BN={kernelName:xn,backendName:"cpu",kernelFunc:PN},VN={kernelName:In,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a;th(r,"resizeBilinear");const u=ne(r.shape),[l,c]=i,[d,p,h,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(P([d,l,c,f])),y=[s&&l>1?p-1:p,s&&c>1?h-1:h],x=[s&&l>1?l-1:l,s&&c>1?c-1:c];let b=0;const v=y[0]/x[0],k=y[1]/x[1];for(let e=0;e<d;e++)for(let t=0;t<l;t++){let n;n=o?v*(t+.5)-.5:v*t;const a=Math.max(0,Math.floor(n)),r=n-a,s=Math.min(p-1,Math.ceil(n)),i=e*u[0]+a*u[1],l=e*u[0]+s*u[1];for(let e=0;e<c;e++){let t;t=o?k*(e+.5)-.5:k*e;const n=Math.max(0,Math.floor(t)),a=t-n,s=Math.min(h-1,Math.ceil(t)),c=i+n*u[2],d=l+n*u[2],p=i+s*u[2],y=l+s*u[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],s=t+(m[p+e]-t)*a,o=s+(n+(m[y+e]-n)*a-s)*r;g[b++]=o}}}return n.makeTensorInfo([d,l,c,f],"float32",g)}},WN={kernelName:Nn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a;th([s,r],"resizeBilinearGrad");const i=ne(r.shape),[u,l,c,d]=r.shape,[,p,h]=s.shape,f=new Float32Array(u*l*c*d),m=[o&&p>1?l-1:l,o&&h>1?c-1:c],g=[o&&p>1?p-1:p,o&&h>1?h-1:h],y=m[0]/g[0],x=m[1]/g[1],b=n.data.get(s.dataId).values;let v=0;for(let e=0;e<u;e++){const t=e*i[0];for(let e=0;e<p;e++){const n=e*y,a=Math.floor(n),r=Math.min(Math.ceil(n),l-1),s=t+a*i[1],o=t+r*i[1],u=n-a,p=1-u;for(let e=0;e<h;e++){const t=e*x,n=Math.floor(t),a=Math.min(Math.ceil(t),c-1),r=t-n,l=1-r,h=s+n*i[2],m=s+a*i[2],g=o+n*i[2],y=o+a*i[2],k=p*l,w=p*r,I=u*l,N=u*r;for(let e=0;e<d;e++){const t=b[v++];f[h+e]+=t*k,f[m+e]+=t*w,f[g+e]+=t*I,f[y+e]+=t*N}}}}return n.makeTensorInfo([u,c,l,d],"float32",f)}},zN={kernelName:kn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a;th(r,"resizeNearestNeighbor");const u=ne(r.shape),[l,c]=i,[d,p,h,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(d*l*c*f),y=[s&&l>1?p-1:p,s&&c>1?h-1:h],x=[s&&l>1?l-1:l,s&&c>1?c-1:c],b=y[0]/x[0],v=y[1]/x[1];let k=0;for(let e=0;e<d;e++){const t=e*u[0];for(let e=0;e<l;e++){const n=o?b*(e+.5):b*e;let a=Math.min(p-1,s?Math.round(n):Math.floor(n));o&&(a=Math.max(0,a));const r=t+a*u[1];for(let e=0;e<c;e++){const t=o?v*(e+.5):v*e;let n=Math.min(h-1,s?Math.round(t):Math.floor(t));o&&(n=Math.max(0,n));const a=r+n*u[2];for(let e=0;e<f;e++){const t=m[a+e];g[k++]=t}}}}return n.makeTensorInfo([d,l,c,f],r.dtype,g)}},UN={kernelName:wn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a;th([s,r],"resizeNearestNeighborGrad");const i=ne(r.shape),u=ne(s.shape),[l,c,d,p]=r.shape,[,h,f]=s.shape,m=new Float32Array(l*c*d*p),g=n.data.get(s.dataId).values,y=[o&&h>1?c-1:c,o&&f>1?d-1:d],x=[o&&h>1?h-1:h,o&&f>1?f-1:f],b=y[0]/x[0],v=y[1]/x[1],k=1/b,w=1/v,I=2*Math.ceil(k)+2,N=2*Math.ceil(w)+2;for(let e=0;e<l;e++){const t=e*i[0];for(let e=0;e<c;e++){const n=t+e*i[1],a=Math.floor(e*k),r=Math.floor(a-I/2);for(let a=0;a<d;a++){const s=n+a*i[2],l=Math.floor(a*w),y=Math.floor(l-N/2);for(let n=0;n<p;n++){let i=0;for(let s=0;s<I;s++){const l=s+r;if(l<0||l>=h)continue;const p=t+l*u[1],m=l*b;if(e===Math.min(c-1,o?Math.round(m):Math.floor(m)))for(let e=0;e<N;e++){const t=e+y;if(t<0||t>=f)continue;const r=p+t*u[2],s=t*v;a===Math.min(d-1,o?Math.round(s):Math.floor(s))&&(i+=g[r+n])}}m[s+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}},GN={kernelName:Cn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;th(r,"reverse");const o=r.shape.length,i=H(s,r.shape);if(0===o)return uh({inputs:{x:r},backend:n});const u=new Ra(r.shape,r.dtype),l=n.bufferSync(r);for(let e=0;e<u.size;e++){const t=u.indexToLoc(e),n=t.slice();i.forEach((e=>n[e]=r.shape[e]-1-n[e])),u.set(l.get(...n),...t)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},HN={kernelName:oa,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,{radians:r,fillValue:s,center:o}=t,i=n,u=K(a.dtype,P(a.shape)),[l,c,d,p]=a.shape,[h,f]=Li(o,c,d),m=Math.sin(r),g=Math.cos(r),y=i.data.get(a.dataId).values;for(let e=0;e<l;e++){const t=e*d*c*p;for(let e=0;e<c;e++){const n=e*(d*p);for(let a=0;a<d;a++){const r=a*p;for(let o=0;o<p;o++){const i=[l,e,a,o],x=i[2],b=i[1];let v=(x-h)*g-(b-f)*m,k=(x-h)*m+(b-f)*g;v=Math.round(v+h),k=Math.round(k+f);let w=s;"number"!=typeof s&&(w=3===o?255:s[o]),v>=0&&v<d&&k>=0&&k<c&&(w=y[t+k*(d*p)+v*p+o]),u[t+n+r+o]=w}}}}return{dataId:i.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},jN=Ih(Tn,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),KN={kernelName:Tn,backendName:"cpu",kernelFunc:jN};function XN(e,t,n,a,r,s,o,i,u,l){const c=[a/r,r],d=e.values,p=t.values;if(0===a)return Wr(n,t.dtype);const h=Wr(c,t.dtype);h.values.fill(u);for(let e=0;e<s;e++){const s=[];let u=0;for(let t=0;t<o;t++){const n=d[e*o+t];s.push(n),u+=n*i[t]}if(u<0||u>=a/r)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<r;n++)l?h.values[u*r+n]+=p[e*r+n]:h.values[u*r+n]=0===t.rank?p[0]:p[e*r+n]}return h}const qN={kernelName:Sn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:o}=a,{sliceRank:i,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=ji(0,r,o),p=XN(n.bufferSync(r),n.bufferSync(s),o,d,l,u,i,c,0,!0);return n.makeTensorInfo(o,p.dtype,p.values)}},YN={kernelName:Rn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;th([a,r,s],"select");const o=a.shape.length,i=n.data.get(a.dataId).values,u=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,c=za(r.dtype,s.dtype),d=oe(P(r.shape),c);let p=0;const h=0===o||o>1||1===r.shape.length?1:P(r.shape.slice(1));for(let e=0;e<i.length;e++)for(let t=0;t<h;t++)1===i[e]?d[p++]=u[e]:d[p++]=l[e];return n.makeTensorInfo(r.shape,c,d)}},QN=Ki,ZN=Xi,JN=Ih(An,(e=>e>=0?ZN*e:QN*(Math.exp(e)-1))),e$={kernelName:An,backendName:"cpu",kernelFunc:JN},t$=Ih(Mn,(e=>1/(1+Math.exp(-e)))),n$={kernelName:Mn,backendName:"cpu",kernelFunc:t$},a$=Ih(Dn,(e=>e<0?-1:e>0?1:0)),r$={kernelName:Dn,backendName:"cpu",kernelFunc:a$},s$=Ih(_n,(e=>Math.sin(e))),o$={kernelName:_n,backendName:"cpu",kernelFunc:s$},i$=Ih(On,(e=>Math.sinh(e))),u$={kernelName:On,backendName:"cpu",kernelFunc:i$},l$=Math.log(1.1920928955078125e-7)+2,c$=Ih(Ln,(e=>{const t=e>-l$,n=e<l$,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),d$={kernelName:Ln,backendName:"cpu",kernelFunc:c$},p$={kernelName:Vn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a;th([r],"spaceToBatchND");const i=P(s),u=[[0,0]];u.push(...o);for(let e=1+s.length;e<r.shape.length;++e)u.push([0,0]);const l=_N.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),c=Pi(l.shape,s,i,!1),d=Bi(c.length,s.length,!1),p=Vi(l.shape,s,i,!1),h=jk({inputs:{x:l},backend:n,attrs:{shape:c}}),f=hf({inputs:{x:h},backend:n,attrs:{perm:d}}),m=jk({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}},h$={kernelName:jn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:i}=a,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=ji(0,r,i),h=XN(n.bufferSync(r),n.bufferSync(s),i,p,c,l,u,d,n.data.get(o.dataId).values[0],!1);return n.makeTensorInfo(i,h.dtype,h.values)}},f$={kernelName:Wn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=a,i=H(o,r.shape)[0],u=du(r,s,i),l=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map((e=>{const t=[...c];t[i]=e;const a=wf({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,a}))}},m$=Ih(Pn,(e=>Math.sqrt(e))),g$={kernelName:Pn,backendName:"cpu",kernelFunc:m$},y$={kernelName:Gn,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,a=t;th(n,"square");const r=a.data.get(n.dataId).values,s=new Float32Array(r.length);for(let e=0;e<r.length;++e){const t=r[e];s[e]=t*t}return{dataId:a.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},x$=Ih(ra,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),b$={kernelName:ra,backendName:"cpu",kernelFunc:x$},v$={kernelName:Kn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=a;th(r,"stridedSlice");const{nonStrided:h,$begin:f,$strides:m,size:g,newShape:y,outShape:x}=gs(r.shape,s,o,i,u,l,c,d,p),b=jk({inputs:{x:r},backend:n,attrs:{shape:y}});let v;if(h){const e=wf({inputs:{x:b},backend:n,attrs:{begin:f,size:g}});v=jk({inputs:{x:e},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(e)}else if(x.some((e=>0===e)))v=n.makeTensorInfo(x,r.dtype,[]);else{const e=Tf(x,n.bufferSync(b),m,f);v=n.makeTensorInfo(e.shape,e.dtype,e.values)}const k=jk({inputs:{x:v},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),k}},k$=Ih(Xn,(e=>Math.tan(e))),w$={kernelName:Xn,backendName:"cpu",kernelFunc:k$},I$=Ih(qn,(e=>Math.tanh(e)));function N$(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return F(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return F(0,n,t-1)}(e,t);case"nearest":return function(e,t){return F(0,e,t-1)}(e,t);case"constant":default:return function(e,t){return e}(e)}}function $$(e,t,n,a,r,s,o,i,u,l,c){return 0<=i&&i<t&&0<=u&&u<n?e[o*a+i*r+u*s+l]:c}function C$(e,t,n,a,r,s,o,i,u,l,c){return $$(e,t,n,a,r,s,o,Math.round(i),Math.round(u),l,c)}function T$(e,t,n,a,r,s,o,i,u,l,c){const d=Math.floor(i),p=Math.floor(u),h=d+1,f=p+1;return(h-i)*((f-u)*$$(e,t,n,a,r,s,o,d,p,l,c)+(u-p)*$$(e,t,n,a,r,s,o,d,f,l,c))+(i-d)*((f-u)*$$(e,t,n,a,r,s,o,h,p,l,c)+(u-p)*$$(e,t,n,a,r,s,o,h,f,l,c))}const E$=[Yk,ah,Zk,ew,bh,tw,nw,aw,rw,sw,iw,lw,dw,fw,gw,vw,kw,ww,Iw,qk,Nw,$w,Cw,hh,Th,Ew,oh,Sw,_w,Mw,Lw,Dw,Bw,Vw,Pw,zw,Gw,Hw,jw,Kw,Xw,Yw,Qw,Zw,Jw,eI,nI,tI,bI,Dk,aI,oI,fI,Ah,gI,Oh,II,$I,CI,Lh,SI,RI,AI,FI,_I,Wh,MI,lh,LI,Aw,PI,BI,VI,Lk,Gh,UI,GI,Xh,jI,qI,QI,eN,tN,nN,Zh,sN,oN,iN,uN,lN,rN,pN,hN,tf,fN,yN,vN,sf,uf,wN,NN,CN,df,TN,RN,FN,_N,MN,Vk,gf,LN,dh,BN,zk,Gk,Kk,VN,WN,zN,UN,GN,HN,KN,vf,qN,YN,e$,n$,r$,o$,u$,If,bN,d$,p$,h$,f$,g$,y$,Cf,b$,v$,Af,dN,w$,{kernelName:qn,backendName:"cpu",kernelFunc:I$},{kernelName:Yn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;th(r,"tile");const o=Ff(n.bufferSync(r),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:Qn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a;th(r,"topk");const i=n.data.get(r.dataId).values,[u,l]=_f(i,r.shape,r.dtype,s);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},ff,{kernelName:Zn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=n,[c,d,p,h]=r.shape,[f,m]=null!=l?l:[d,p],g=[c,f,m,h],y=ne(r.shape),x=y[0],b=y[1],v=y[2],k=K(r.dtype,P(g));k.fill(u);const w=a.data.get(r.dataId).values,I=a.data.get(s.dataId).values;for(let e=0;e<c;++e){const t=1===s.shape[0]?I:I.subarray(8*e,8*e+8);for(let n=0;n<f;++n)for(let a=0;a<m;++a)for(let r=0;r<h;++r){let s;const l=t[6]*a+t[7]*n+1;if(0===l)continue;const c=(t[0]*a+t[1]*n+t[2])/l,h=(t[3]*a+t[4]*n+t[5])/l,f=N$(c,p,i),m=N$(h,d,i);switch(o){case"nearest":s=C$(w,d,p,x,b,v,e,m,f,r,u);break;case"bilinear":s=T$(w,d,p,x,b,v,e,m,f,r,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}k[e*x+n*b+a*v+r]=s}return a.makeTensorInfo(g,r.dtype,k)}return{dataId:a.write(k,g,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:ea,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;th(s,"unique");const o=a.data.get(s.dataId).values,{outputValues:i,outputShape:u,indices:l}=Of(o,r,s.shape,s.dtype);return[a.makeTensorInfo(u,s.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}},{kernelName:ta,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r.shape.length,i=r.shape[s],u=new Array(o-1);let l=0;for(let e=0;e<o;e++)e!==s&&(u[l++]=r.shape[e]);const c=new Array(o).fill(0),d=r.shape.slice();d[s]=1;const p=new Array(i);for(let e=0;e<p.length;e++){c[s]=e;const t=wf({inputs:{x:r},backend:n,attrs:{begin:c,size:d}});p[e]=jk({inputs:{x:t},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(t)}return p}},{kernelName:na,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:o}=a;th(r,"unsortedSegmentSum");const i=[],u=[],l=r.shape.length-s.shape.length;let c=s;for(let e=0;e<l;++e){const t=mI({inputs:{input:c},backend:n,attrs:{dim:e+1}});c=t,u.push(t)}for(let e=0;e<o;++e){const t=ya(e,"int32"),a=n.makeTensorInfo([],"int32",t),s=sI({inputs:{a,b:c},backend:n}),o=ph({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=rf({inputs:{a:o,b:r},backend:n}),d=cN({inputs:{x:l},backend:n,attrs:{axis:0,keepDims:!1}});i.push(d),u.push(a),u.push(s),u.push(o),u.push(l),u.push(d)}const d=AN({inputs:i,backend:n,attrs:{axis:0}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},SN];for(const e of E$)ma(e);function S$(e,t){(t=Object.assign({fullscreen:!0,quitFullscreenOnFinished:!1,repeatTesting:2,pip:!0,pipWidth:208},t)).fullscreen;const n=document.createElement("div");n.className="calibration-background",n.innerHTML='\n<div class="calibration-instruction">\n\t<h1>📏 Live Viewing Distance Calibration</h1>\n\t<p>\n\t\tWe\'ll measure your viewing distance. To do this, we\'ll perform a <em>blind spot test</em>.\n\t\tCover or close one of your eyes and focus on the black cross.\n\t\tPress <b>SPACE</b> when the red circle disappears.\n    We\'ll measure for several trials. After each trial, please move closer or farther,\n    stay still again, and repeat the above. The toolbox will then start live estimating of\n    your viewing distance. <b>Please enable camera access.</b>\n\t</p>\n</div>\n<canvas id="video-canvas"></canvas>',document.body.appendChild(n);const a=document.querySelector("#video-canvas"),r=a.getContext("2d"),s=document.querySelector("video");let o,i,u;const l=()=>{if(r.drawImage(s,0,0,a.width,a.height),c&&c[0])for(let e of c[0].scaledMesh)r.fillRect(e[0],e[1],1,1);requestAnimationFrame(l)};let c,d;var p;p=s,document.write('<video id="face-video"></video>'),navigator.getUserMedia({video:{}},(e=>{p.srcObject=e,p.play(),((e,n)=>{({width:o,height:i}=e.getTracks()[0].getSettings()),u=t.pipWidth/o,a.style.width=(a.width=t.pipWidth)+"px",a.style.height=(a.height=u*i)+"px",r.translate(t.pipWidth,0),r.scale(-1,1),requestAnimationFrame(l),async function(){const e=await function(e,t){return void 0===e&&(e=Ud.mediapipeFacemesh),void 0===t&&(t={}),id(this,void 0,void 0,(function(){return ud(this,(function(n){if(e===Ud.mediapipeFacemesh)return[2,Pd(t)];throw new Error(e+" is not a valid package name.")}))}))}(Ud.mediapipeFacemesh,{shouldLoadIrisModel:!0,maxFace:1,detectionConfidence:.95,iouThreshold:.4}).then(h.style.display="block");d=setInterval((async()=>{c=await e.estimateFaces({input:a})}),200)}()})(e)}),(e=>console.error(e))),T(n,t,(e=>{}));let h=document.getElementById("#blind-spot-canvas");h.style.display="none"}var R$=n(556);N()(R$.Z,{insert:"head",singleton:!1}),R$.Z.locals})(),a})()}));